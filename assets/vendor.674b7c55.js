function Qn(t) {
  if (t === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return t;
}
function Sf(t, e) {
  (t.prototype = Object.create(e.prototype)),
    (t.prototype.constructor = t),
    (t.__proto__ = e);
}
/*!
 * GSAP 3.5.1
 * https://greensock.com
 *
 * @license Copyright 2008-2020, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var un = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: { lineHeight: "" },
  },
  Er = { duration: 0.5, overwrite: !1, delay: 0 },
  Dn = 1e8,
  Ht = 1 / Dn,
  Dl = Math.PI * 2,
  Ig = Dl / 4,
  Ng = 0,
  Tf = Math.sqrt,
  Fg = Math.cos,
  Bg = Math.sin,
  Oe = function (e) {
    return typeof e == "string";
  },
  Te = function (e) {
    return typeof e == "function";
  },
  bn = function (e) {
    return typeof e == "number";
  },
  Il = function (e) {
    return typeof e == "undefined";
  },
  Kn = function (e) {
    return typeof e == "object";
  },
  We = function (e) {
    return e !== !1;
  },
  Ef = function () {
    return typeof window != "undefined";
  },
  Af = function (e) {
    return Te(e) || Oe(e);
  },
  Lf =
    (typeof ArrayBuffer == "function" && ArrayBuffer.isView) || function () {},
  hn = Array.isArray,
  Nl = /(?:-?\.?\d|\.)+/gi,
  Pf = /[-+=.]*\d+[.e\-+]*\d*[e\-\+]*\d*/g,
  Ar = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
  Fl = /[-+=.]*\d+(?:\.|e-|e)*\d*/gi,
  Cf = /[+-]=-?[\.\d]+/,
  Rf = /[#\-+.]*\b[a-z\d-=+%.]+/gi,
  ye,
  In,
  Bl,
  Of,
  $e = {},
  ga = {},
  Df,
  If = function (e) {
    return (ga = Lr(e, $e)) && Bn;
  },
  zl = function (e, n) {
    return console.warn(
      "Invalid property",
      e,
      "set to",
      n,
      "Missing plugin? gsap.registerPlugin()"
    );
  },
  Nf = function (e, n) {
    return !n && console.warn(e);
  },
  Ff = function (e, n) {
    return (e && ($e[e] = n) && ga && (ga[e] = n)) || $e;
  },
  Ys = function () {
    return 0;
  },
  Ul = {},
  vi = [],
  kl = {},
  Bf,
  Qe = {},
  Gl = {},
  zf = 30,
  ya = [],
  Hl = "",
  Vl = function (e) {
    var n = e[0],
      i,
      r;
    if ((Kn(n) || Te(n) || (e = [e]), !(i = (n._gsap || {}).harness))) {
      for (r = ya.length; r-- && !ya[r].targetTest(n); );
      i = ya[r];
    }
    for (r = e.length; r--; )
      (e[r] && (e[r]._gsap || (e[r]._gsap = new ud(e[r], i)))) ||
        e.splice(r, 1);
    return e;
  },
  Zi = function (e) {
    return e._gsap || Vl(Fn(e))[0]._gsap;
  },
  Uf = function (e, n, i) {
    return (i = e[n]) && Te(i)
      ? e[n]()
      : (Il(i) && e.getAttribute && e.getAttribute(n)) || i;
  },
  Ke = function (e, n) {
    return (e = e.split(",")).forEach(n) || e;
  },
  Bt = function (e) {
    return Math.round(e * 1e5) / 1e5 || 0;
  },
  zg = function (e, n) {
    for (var i = n.length, r = 0; e.indexOf(n[r]) < 0 && ++r < i; );
    return r < i;
  },
  Zs = function (e, n, i) {
    var r = bn(e[1]),
      s = (r ? 2 : 1) + (n < 2 ? 0 : 1),
      o = e[s],
      a;
    if ((r && (o.duration = e[1]), (o.parent = i), n)) {
      for (a = o; i && !("immediateRender" in a); )
        (a = i.vars.defaults || {}), (i = We(i.vars.inherit) && i.parent);
      (o.immediateRender = We(a.immediateRender)),
        n < 2 ? (o.runBackwards = 1) : (o.startAt = e[s - 1]);
    }
    return o;
  },
  _a = function () {
    var e = vi.length,
      n = vi.slice(0),
      i,
      r;
    for (kl = {}, vi.length = 0, i = 0; i < e; i++)
      (r = n[i]),
        r && r._lazy && (r.render(r._lazy[0], r._lazy[1], !0)._lazy = 0);
  },
  kf = function (e, n, i, r) {
    vi.length && _a(), e.render(n, i, r), vi.length && _a();
  },
  Gf = function (e) {
    var n = parseFloat(e);
    return (n || n === 0) && (e + "").match(Rf).length < 2
      ? n
      : Oe(e)
      ? e.trim()
      : e;
  },
  Hf = function (e) {
    return e;
  },
  fn = function (e, n) {
    for (var i in n) i in e || (e[i] = n[i]);
    return e;
  },
  Ug = function (e, n) {
    for (var i in n)
      i in e || i === "duration" || i === "ease" || (e[i] = n[i]);
  },
  Lr = function (e, n) {
    for (var i in n) e[i] = n[i];
    return e;
  },
  Vf = function t(e, n) {
    for (var i in n) e[i] = Kn(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i];
    return e;
  },
  Wl = function (e, n) {
    var i = {},
      r;
    for (r in e) r in n || (i[r] = e[r]);
    return i;
  },
  xa = function (e) {
    var n = e.parent || ye,
      i = e.keyframes ? Ug : fn;
    if (We(e.inherit))
      for (; n; ) i(e, n.vars.defaults), (n = n.parent || n._dp);
    return e;
  },
  kg = function (e, n) {
    for (var i = e.length, r = i === n.length; r && i-- && e[i] === n[i]; );
    return i < 0;
  },
  Gg = function (e, n, i, r, s) {
    i === void 0 && (i = "_first"), r === void 0 && (r = "_last");
    var o = e[r],
      a;
    if (s) for (a = n[s]; o && o[s] > a; ) o = o._prev;
    return (
      o ? ((n._next = o._next), (o._next = n)) : ((n._next = e[i]), (e[i] = n)),
      n._next ? (n._next._prev = n) : (e[r] = n),
      (n._prev = o),
      (n.parent = n._dp = e),
      n
    );
  },
  va = function (e, n, i, r) {
    i === void 0 && (i = "_first"), r === void 0 && (r = "_last");
    var s = n._prev,
      o = n._next;
    s ? (s._next = o) : e[i] === n && (e[i] = o),
      o ? (o._prev = s) : e[r] === n && (e[r] = s),
      (n._next = n._prev = n.parent = null);
  },
  bi = function (e, n) {
    e.parent && (!n || e.parent.autoRemoveChildren) && e.parent.remove(e),
      (e._act = 0);
  },
  Ji = function (e, n) {
    if (e && (!n || n._end > e._dur || n._start < 0))
      for (var i = e; i; ) (i._dirty = 1), (i = i.parent);
    return e;
  },
  Hg = function (e) {
    for (var n = e.parent; n && n.parent; )
      (n._dirty = 1), n.totalDuration(), (n = n.parent);
    return e;
  },
  Vg = function t(e) {
    return !e || (e._ts && t(e.parent));
  },
  Wf = function (e) {
    return e._repeat ? Pr(e._tTime, (e = e.duration() + e._rDelay)) * e : 0;
  },
  Pr = function (e, n) {
    return (e /= n) && ~~e === e ? ~~e - 1 : ~~e;
  },
  ba = function (e, n) {
    return (
      (e - n._start) * n._ts +
      (n._ts >= 0 ? 0 : n._dirty ? n.totalDuration() : n._tDur)
    );
  },
  jl = function (e) {
    return (e._end = Bt(
      e._start + (e._tDur / Math.abs(e._ts || e._rts || Ht) || 0)
    ));
  },
  jf = function (e, n) {
    var i = e._dp;
    return (
      i &&
        i.smoothChildTiming &&
        e._ts &&
        ((e._start = Bt(
          e._dp._time -
            (e._ts > 0
              ? n / e._ts
              : ((e._dirty ? e.totalDuration() : e._tDur) - n) / -e._ts)
        )),
        jl(e),
        i._dirty || Ji(i, e)),
      e
    );
  },
  ql = function (e, n) {
    var i;
    if (
      ((n._time || (n._initted && !n._dur)) &&
        ((i = ba(e.rawTime(), n)),
        (!n._dur || Js(0, n.totalDuration(), i) - n._tTime > Ht) &&
          n.render(i, !0)),
      Ji(e, n)._dp && e._initted && e._time >= e._dur && e._ts)
    ) {
      if (e._dur < e.duration())
        for (i = e; i._dp; )
          i.rawTime() >= 0 && i.totalTime(i._tTime), (i = i._dp);
      e._zTime = -Ht;
    }
  },
  ti = function (e, n, i, r) {
    return (
      n.parent && bi(n),
      (n._start = Bt(i + n._delay)),
      (n._end = Bt(
        n._start + (n.totalDuration() / Math.abs(n.timeScale()) || 0)
      )),
      Gg(e, n, "_first", "_last", e._sort ? "_start" : 0),
      (e._recent = n),
      r || ql(e, n),
      e
    );
  },
  qf = function (e, n) {
    return (
      ($e.ScrollTrigger || zl("scrollTrigger", n)) &&
      $e.ScrollTrigger.create(n, e)
    );
  },
  Xf = function (e, n, i, r) {
    if ((uy(e, n), !e._initted)) return 1;
    if (
      !i &&
      e._pt &&
      ((e._dur && e.vars.lazy !== !1) || (!e._dur && e.vars.lazy)) &&
      Bf !== dn.frame
    )
      return vi.push(e), (e._lazy = [n, r]), 1;
  },
  Wg = function (e, n, i, r) {
    var s = e.ratio,
      o =
        n < 0 ||
        (!n && s && !e._start && e._zTime > Ht && !e._dp._lock) ||
        ((e._ts < 0 || e._dp._ts < 0) &&
          e.data !== "isFromStart" &&
          e.data !== "isStart")
          ? 0
          : 1,
      a = e._rDelay,
      c = 0,
      l,
      u,
      h;
    if (
      (a &&
        e._repeat &&
        ((c = Js(0, e._tDur, n)),
        (u = Pr(c, a)),
        (h = Pr(e._tTime, a)),
        u !== h &&
          ((s = 1 - o), e.vars.repeatRefresh && e._initted && e.invalidate())),
      o !== s || r || e._zTime === Ht || (!n && e._zTime))
    ) {
      if (!e._initted && Xf(e, n, r, i)) return;
      for (
        h = e._zTime,
          e._zTime = n || (i ? Ht : 0),
          i || (i = n && !h),
          e.ratio = o,
          e._from && (o = 1 - o),
          e._time = 0,
          e._tTime = c,
          i || tn(e, "onStart"),
          l = e._pt;
        l;

      )
        l.r(o, l.d), (l = l._next);
      e._startAt && n < 0 && e._startAt.render(n, !0, !0),
        e._onUpdate && !i && tn(e, "onUpdate"),
        c && e._repeat && !i && e.parent && tn(e, "onRepeat"),
        (n >= e._tDur || n < 0) &&
          e.ratio === o &&
          (o && bi(e, 1),
          i ||
            (tn(e, o ? "onComplete" : "onReverseComplete", !0),
            e._prom && e._prom()));
    } else e._zTime || (e._zTime = n);
  },
  jg = function (e, n, i) {
    var r;
    if (i > n)
      for (r = e._first; r && r._start <= i; ) {
        if (!r._dur && r.data === "isPause" && r._start > n) return r;
        r = r._next;
      }
    else
      for (r = e._last; r && r._start >= i; ) {
        if (!r._dur && r.data === "isPause" && r._start < n) return r;
        r = r._prev;
      }
  },
  Cr = function (e, n, i, r) {
    var s = e._repeat,
      o = Bt(n) || 0,
      a = e._tTime / e._tDur;
    return (
      a && !r && (e._time *= o / e._dur),
      (e._dur = o),
      (e._tDur = s ? (s < 0 ? 1e10 : Bt(o * (s + 1) + e._rDelay * s)) : o),
      a && !r ? jf(e, (e._tTime = e._tDur * a)) : e.parent && jl(e),
      i || Ji(e.parent, e),
      e
    );
  },
  Yf = function (e) {
    return e instanceof je ? Ji(e) : Cr(e, e._dur);
  },
  qg = { _start: 0, endTime: Ys },
  Be = function t(e, n) {
    var i = e.labels,
      r = e._recent || qg,
      s = e.duration() >= Dn ? r.endTime(!1) : e._dur,
      o,
      a;
    return Oe(n) && (isNaN(n) || n in i)
      ? ((o = n.charAt(0)),
        o === "<" || o === ">"
          ? (o === "<" ? r._start : r.endTime(r._repeat >= 0)) +
            (parseFloat(n.substr(1)) || 0)
          : ((o = n.indexOf("=")),
            o < 0
              ? (n in i || (i[n] = s), i[n])
              : ((a = +(n.charAt(o - 1) + n.substr(o + 1))),
                o > 1 ? t(e, n.substr(0, o - 1)) + a : s + a)))
      : n == null
      ? s
      : +n;
  },
  wi = function (e, n) {
    return e || e === 0 ? n(e) : n;
  },
  Js = function (e, n, i) {
    return i < e ? e : i > n ? n : i;
  },
  Nn = function (e) {
    return (e = (e + "").substr((parseFloat(e) + "").length)) && isNaN(e)
      ? e
      : "";
  },
  Xg = function (e, n, i) {
    return wi(i, function (r) {
      return Js(e, n, r);
    });
  },
  Xl = [].slice,
  Zf = function (e, n) {
    return (
      e &&
      Kn(e) &&
      "length" in e &&
      ((!n && !e.length) || (e.length - 1 in e && Kn(e[0]))) &&
      !e.nodeType &&
      e !== In
    );
  },
  Yg = function (e, n, i) {
    return (
      i === void 0 && (i = []),
      e.forEach(function (r) {
        var s;
        return (Oe(r) && !n) || Zf(r, 1)
          ? (s = i).push.apply(s, Fn(r))
          : i.push(r);
      }) || i
    );
  },
  Fn = function (e, n) {
    return Oe(e) && !n && (Bl || !Dr())
      ? Xl.call(Of.querySelectorAll(e), 0)
      : hn(e)
      ? Yg(e, n)
      : Zf(e)
      ? Xl.call(e, 0)
      : e
      ? [e]
      : [];
  },
  Jf = function (e) {
    return e.sort(function () {
      return 0.5 - Math.random();
    });
  },
  $f = function (e) {
    if (Te(e)) return e;
    var n = Kn(e) ? e : { each: e },
      i = Ir(n.ease),
      r = n.from || 0,
      s = parseFloat(n.base) || 0,
      o = {},
      a = r > 0 && r < 1,
      c = isNaN(r) || a,
      l = n.axis,
      u = r,
      h = r;
    return (
      Oe(r)
        ? (u = h = { center: 0.5, edges: 0.5, end: 1 }[r] || 0)
        : !a && c && ((u = r[0]), (h = r[1])),
      function (d, f, p) {
        var _ = (p || n).length,
          y = o[_],
          m,
          g,
          b,
          x,
          v,
          w,
          M,
          C,
          A;
        if (!y) {
          if (((A = n.grid === "auto" ? 0 : (n.grid || [1, Dn])[1]), !A)) {
            for (
              M = -Dn;
              M < (M = p[A++].getBoundingClientRect().left) && A < _;

            );
            A--;
          }
          for (
            y = o[_] = [],
              m = c ? Math.min(A, _) * u - 0.5 : r % A,
              g = c ? (_ * h) / A - 0.5 : (r / A) | 0,
              M = 0,
              C = Dn,
              w = 0;
            w < _;
            w++
          )
            (b = (w % A) - m),
              (x = g - ((w / A) | 0)),
              (y[w] = v = l ? Math.abs(l === "y" ? x : b) : Tf(b * b + x * x)),
              v > M && (M = v),
              v < C && (C = v);
          r === "random" && Jf(y),
            (y.max = M - C),
            (y.min = C),
            (y.v = _ =
              (parseFloat(n.amount) ||
                parseFloat(n.each) *
                  (A > _
                    ? _ - 1
                    : l
                    ? l === "y"
                      ? _ / A
                      : A
                    : Math.max(A, _ / A)) ||
                0) * (r === "edges" ? -1 : 1)),
            (y.b = _ < 0 ? s - _ : s),
            (y.u = Nn(n.amount || n.each) || 0),
            (i = i && _ < 0 ? ad(i) : i);
        }
        return (
          (_ = (y[d] - y.min) / y.max || 0),
          Bt(y.b + (i ? i(_) : _) * y.v) + y.u
        );
      }
    );
  },
  Yl = function (e) {
    var n = e < 1 ? Math.pow(10, (e + "").length - 2) : 1;
    return function (i) {
      return (
        Math.floor(Math.round(parseFloat(i) / e) * e * n) / n +
        (bn(i) ? 0 : Nn(i))
      );
    };
  },
  Qf = function (e, n) {
    var i = hn(e),
      r,
      s;
    return (
      !i &&
        Kn(e) &&
        ((r = i = e.radius || Dn),
        e.values
          ? ((e = Fn(e.values)), (s = !bn(e[0])) && (r *= r))
          : (e = Yl(e.increment))),
      wi(
        n,
        i
          ? Te(e)
            ? function (o) {
                return (s = e(o)), Math.abs(s - o) <= r ? s : o;
              }
            : function (o) {
                for (
                  var a = parseFloat(s ? o.x : o),
                    c = parseFloat(s ? o.y : 0),
                    l = Dn,
                    u = 0,
                    h = e.length,
                    d,
                    f;
                  h--;

                )
                  s
                    ? ((d = e[h].x - a), (f = e[h].y - c), (d = d * d + f * f))
                    : (d = Math.abs(e[h] - a)),
                    d < l && ((l = d), (u = h));
                return (
                  (u = !r || l <= r ? e[u] : o),
                  s || u === o || bn(o) ? u : u + Nn(o)
                );
              }
          : Yl(e)
      )
    );
  },
  Kf = function (e, n, i, r) {
    return wi(hn(e) ? !n : i === !0 ? !!(i = 0) : !r, function () {
      return hn(e)
        ? e[~~(Math.random() * e.length)]
        : (i = i || 1e-5) &&
            (r = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) &&
            Math.floor(Math.round((e + Math.random() * (n - e)) / i) * i * r) /
              r;
    });
  },
  Zg = function () {
    for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++)
      n[i] = arguments[i];
    return function (r) {
      return n.reduce(function (s, o) {
        return o(s);
      }, r);
    };
  },
  Jg = function (e, n) {
    return function (i) {
      return e(parseFloat(i)) + (n || Nn(i));
    };
  },
  $g = function (e, n, i) {
    return ed(e, n, 0, 1, i);
  },
  td = function (e, n, i) {
    return wi(i, function (r) {
      return e[~~n(r)];
    });
  },
  Qg = function t(e, n, i) {
    var r = n - e;
    return hn(e)
      ? td(e, t(0, e.length), n)
      : wi(i, function (s) {
          return ((r + ((s - e) % r)) % r) + e;
        });
  },
  Kg = function t(e, n, i) {
    var r = n - e,
      s = r * 2;
    return hn(e)
      ? td(e, t(0, e.length - 1), n)
      : wi(i, function (o) {
          return (o = (s + ((o - e) % s)) % s || 0), e + (o > r ? s - o : o);
        });
  },
  wa = function (e) {
    for (var n = 0, i = "", r, s, o, a; ~(r = e.indexOf("random(", n)); )
      (o = e.indexOf(")", r)),
        (a = e.charAt(r + 7) === "["),
        (s = e.substr(r + 7, o - r - 7).match(a ? Rf : Nl)),
        (i +=
          e.substr(n, r - n) + Kf(a ? s : +s[0], a ? 0 : +s[1], +s[2] || 1e-5)),
        (n = o + 1);
    return i + e.substr(n, e.length - n);
  },
  ed = function (e, n, i, r, s) {
    var o = n - e,
      a = r - i;
    return wi(s, function (c) {
      return i + (((c - e) / o) * a || 0);
    });
  },
  ty = function t(e, n, i, r) {
    var s = isNaN(e + n)
      ? 0
      : function (f) {
          return (1 - f) * e + f * n;
        };
    if (!s) {
      var o = Oe(e),
        a = {},
        c,
        l,
        u,
        h,
        d;
      if ((i === !0 && (r = 1) && (i = null), o))
        (e = { p: e }), (n = { p: n });
      else if (hn(e) && !hn(n)) {
        for (u = [], h = e.length, d = h - 2, l = 1; l < h; l++)
          u.push(t(e[l - 1], e[l]));
        h--,
          (s = function (p) {
            p *= h;
            var _ = Math.min(d, ~~p);
            return u[_](p - _);
          }),
          (i = n);
      } else r || (e = Lr(hn(e) ? [] : {}, e));
      if (!u) {
        for (c in n) Ql.call(a, e, c, "get", n[c]);
        s = function (p) {
          return eu(p, a) || (o ? e.p : e);
        };
      }
    }
    return wi(i, s);
  },
  nd = function (e, n, i) {
    var r = e.labels,
      s = Dn,
      o,
      a,
      c;
    for (o in r)
      (a = r[o] - n),
        a < 0 == !!i && a && s > (a = Math.abs(a)) && ((c = o), (s = a));
    return c;
  },
  tn = function (e, n, i) {
    var r = e.vars,
      s = r[n],
      o,
      a;
    if (!!s)
      return (
        (o = r[n + "Params"]),
        (a = r.callbackScope || e),
        i && vi.length && _a(),
        o ? s.apply(a, o) : s.call(a)
      );
  },
  $s = function (e) {
    return bi(e), e.progress() < 1 && tn(e, "onInterrupt"), e;
  },
  Rr,
  ey = function (e) {
    e = (!e.name && e.default) || e;
    var n = e.name,
      i = Te(e),
      r =
        n && !i && e.init
          ? function () {
              this._props = [];
            }
          : e,
      s = { init: Ys, render: eu, add: Ql, kill: yy, modifier: gy, rawVars: 0 },
      o = { targetTest: 0, get: 0, getSetter: tu, aliases: {}, register: 0 };
    if ((Dr(), e !== r)) {
      if (Qe[n]) return;
      fn(r, fn(Wl(e, s), o)),
        Lr(r.prototype, Lr(s, Wl(e, o))),
        (Qe[(r.prop = n)] = r),
        e.targetTest && (ya.push(r), (Ul[n] = 1)),
        (n =
          (n === "css" ? "CSS" : n.charAt(0).toUpperCase() + n.substr(1)) +
          "Plugin");
    }
    Ff(n, r), e.register && e.register(Bn, r, qe);
  },
  te = 255,
  Qs = {
    aqua: [0, te, te],
    lime: [0, te, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, te],
    navy: [0, 0, 128],
    white: [te, te, te],
    olive: [128, 128, 0],
    yellow: [te, te, 0],
    orange: [te, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [te, 0, 0],
    pink: [te, 192, 203],
    cyan: [0, te, te],
    transparent: [te, te, te, 0],
  },
  Zl = function (e, n, i) {
    return (
      (e = e < 0 ? e + 1 : e > 1 ? e - 1 : e),
      ((e * 6 < 1
        ? n + (i - n) * e * 6
        : e < 0.5
        ? i
        : e * 3 < 2
        ? n + (i - n) * (2 / 3 - e) * 6
        : n) *
        te +
        0.5) |
        0
    );
  },
  id = function (e, n, i) {
    var r = e ? (bn(e) ? [e >> 16, (e >> 8) & te, e & te] : 0) : Qs.black,
      s,
      o,
      a,
      c,
      l,
      u,
      h,
      d,
      f,
      p;
    if (!r) {
      if ((e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), Qs[e]))
        r = Qs[e];
      else if (e.charAt(0) === "#")
        e.length === 4 &&
          ((s = e.charAt(1)),
          (o = e.charAt(2)),
          (a = e.charAt(3)),
          (e = "#" + s + s + o + o + a + a)),
          (e = parseInt(e.substr(1), 16)),
          (r = [e >> 16, (e >> 8) & te, e & te]);
      else if (e.substr(0, 3) === "hsl") {
        if (((r = p = e.match(Nl)), !n))
          (c = (+r[0] % 360) / 360),
            (l = +r[1] / 100),
            (u = +r[2] / 100),
            (o = u <= 0.5 ? u * (l + 1) : u + l - u * l),
            (s = u * 2 - o),
            r.length > 3 && (r[3] *= 1),
            (r[0] = Zl(c + 1 / 3, s, o)),
            (r[1] = Zl(c, s, o)),
            (r[2] = Zl(c - 1 / 3, s, o));
        else if (~e.indexOf("="))
          return (r = e.match(Pf)), i && r.length < 4 && (r[3] = 1), r;
      } else r = e.match(Nl) || Qs.transparent;
      r = r.map(Number);
    }
    return (
      n &&
        !p &&
        ((s = r[0] / te),
        (o = r[1] / te),
        (a = r[2] / te),
        (h = Math.max(s, o, a)),
        (d = Math.min(s, o, a)),
        (u = (h + d) / 2),
        h === d
          ? (c = l = 0)
          : ((f = h - d),
            (l = u > 0.5 ? f / (2 - h - d) : f / (h + d)),
            (c =
              h === s
                ? (o - a) / f + (o < a ? 6 : 0)
                : h === o
                ? (a - s) / f + 2
                : (s - o) / f + 4),
            (c *= 60)),
        (r[0] = ~~(c + 0.5)),
        (r[1] = ~~(l * 100 + 0.5)),
        (r[2] = ~~(u * 100 + 0.5))),
      i && r.length < 4 && (r[3] = 1),
      r
    );
  },
  rd = function (e) {
    var n = [],
      i = [],
      r = -1;
    return (
      e.split(Or).forEach(function (s) {
        var o = s.match(Ar) || [];
        n.push.apply(n, o), i.push((r += o.length + 1));
      }),
      (n.c = i),
      n
    );
  },
  sd = function (e, n, i) {
    var r = "",
      s = (e + r).match(Or),
      o = n ? "hsla(" : "rgba(",
      a = 0,
      c,
      l,
      u,
      h;
    if (!s) return e;
    if (
      ((s = s.map(function (d) {
        return (
          (d = id(d, n, 1)) &&
          o +
            (n ? d[0] + "," + d[1] + "%," + d[2] + "%," + d[3] : d.join(",")) +
            ")"
        );
      })),
      i && ((u = rd(e)), (c = i.c), c.join(r) !== u.c.join(r)))
    )
      for (l = e.replace(Or, "1").split(Ar), h = l.length - 1; a < h; a++)
        r +=
          l[a] +
          (~c.indexOf(a)
            ? s.shift() || o + "0,0,0,0)"
            : (u.length ? u : s.length ? s : i).shift());
    if (!l)
      for (l = e.split(Or), h = l.length - 1; a < h; a++) r += l[a] + s[a];
    return r + l[h];
  },
  Or = (function () {
    var t =
        "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b",
      e;
    for (e in Qs) t += "|" + e + "\\b";
    return new RegExp(t + ")", "gi");
  })(),
  ny = /hsl[a]?\(/,
  od = function (e) {
    var n = e.join(" "),
      i;
    if (((Or.lastIndex = 0), Or.test(n)))
      return (
        (i = ny.test(n)),
        (e[1] = sd(e[1], i)),
        (e[0] = sd(e[0], i, rd(e[1]))),
        !0
      );
  },
  Ma,
  dn = (function () {
    var t = Date.now,
      e = 500,
      n = 33,
      i = t(),
      r = i,
      s = 1e3 / 240,
      o = s,
      a = [],
      c,
      l,
      u,
      h,
      d,
      f,
      p = function _(y) {
        var m = t() - r,
          g = y === !0,
          b,
          x,
          v,
          w;
        if (
          (m > e && (i += m - n),
          (r += m),
          (v = r - i),
          (b = v - o),
          (b > 0 || g) &&
            ((w = ++h.frame),
            (d = v - h.time * 1e3),
            (h.time = v = v / 1e3),
            (o += b + (b >= s ? 4 : s - b)),
            (x = 1)),
          g || (c = l(_)),
          x)
        )
          for (f = 0; f < a.length; f++) a[f](v, d, w, y);
      };
    return (
      (h = {
        time: 0,
        frame: 0,
        tick: function () {
          p(!0);
        },
        deltaRatio: function (y) {
          return d / (1e3 / (y || 60));
        },
        wake: function () {
          Df &&
            (!Bl &&
              Ef() &&
              ((In = Bl = window),
              (Of = In.document || {}),
              ($e.gsap = Bn),
              (In.gsapVersions || (In.gsapVersions = [])).push(Bn.version),
              If(ga || In.GreenSockGlobals || (!In.gsap && In) || {}),
              (u = In.requestAnimationFrame)),
            c && h.sleep(),
            (l =
              u ||
              function (y) {
                return setTimeout(y, (o - h.time * 1e3 + 1) | 0);
              }),
            (Ma = 1),
            p(2));
        },
        sleep: function () {
          (u ? In.cancelAnimationFrame : clearTimeout)(c), (Ma = 0), (l = Ys);
        },
        lagSmoothing: function (y, m) {
          (e = y || 1 / Ht), (n = Math.min(m, e, 0));
        },
        fps: function (y) {
          (s = 1e3 / (y || 240)), (o = h.time * 1e3 + s);
        },
        add: function (y) {
          a.indexOf(y) < 0 && a.push(y), Dr();
        },
        remove: function (y) {
          var m;
          ~(m = a.indexOf(y)) && a.splice(m, 1) && f >= m && f--;
        },
        _listeners: a,
      }),
      h
    );
  })(),
  Dr = function () {
    return !Ma && dn.wake();
  },
  zt = {},
  iy = /^[\d.\-M][\d.\-,\s]/,
  ry = /["']/g,
  sy = function (e) {
    for (
      var n = {},
        i = e.substr(1, e.length - 3).split(":"),
        r = i[0],
        s = 1,
        o = i.length,
        a,
        c,
        l;
      s < o;
      s++
    )
      (c = i[s]),
        (a = s !== o - 1 ? c.lastIndexOf(",") : c.length),
        (l = c.substr(0, a)),
        (n[r] = isNaN(l) ? l.replace(ry, "").trim() : +l),
        (r = c.substr(a + 1).trim());
    return n;
  },
  oy = function (e) {
    var n = e.indexOf("(") + 1,
      i = e.indexOf(")"),
      r = e.indexOf("(", n);
    return e.substring(n, ~r && r < i ? e.indexOf(")", i + 1) : i);
  },
  ay = function (e) {
    var n = (e + "").split("("),
      i = zt[n[0]];
    return i && n.length > 1 && i.config
      ? i.config.apply(
          null,
          ~e.indexOf("{") ? [sy(n[1])] : oy(e).split(",").map(Gf)
        )
      : zt._CE && iy.test(e)
      ? zt._CE("", e)
      : i;
  },
  ad = function (e) {
    return function (n) {
      return 1 - e(1 - n);
    };
  },
  cd = function t(e, n) {
    for (var i = e._first, r; i; )
      i instanceof je
        ? t(i, n)
        : i.vars.yoyoEase &&
          (!i._yoyo || !i._repeat) &&
          i._yoyo !== n &&
          (i.timeline
            ? t(i.timeline, n)
            : ((r = i._ease),
              (i._ease = i._yEase),
              (i._yEase = r),
              (i._yoyo = n))),
        (i = i._next);
  },
  Ir = function (e, n) {
    return (e && (Te(e) ? e : zt[e] || ay(e))) || n;
  },
  $i = function (e, n, i, r) {
    i === void 0 &&
      (i = function (c) {
        return 1 - n(1 - c);
      }),
      r === void 0 &&
        (r = function (c) {
          return c < 0.5 ? n(c * 2) / 2 : 1 - n((1 - c) * 2) / 2;
        });
    var s = { easeIn: n, easeOut: i, easeInOut: r },
      o;
    return (
      Ke(e, function (a) {
        (zt[a] = $e[a] = s), (zt[(o = a.toLowerCase())] = i);
        for (var c in s)
          zt[
            o + (c === "easeIn" ? ".in" : c === "easeOut" ? ".out" : ".inOut")
          ] = zt[a + "." + c] = s[c];
      }),
      s
    );
  },
  ld = function (e) {
    return function (n) {
      return n < 0.5 ? (1 - e(1 - n * 2)) / 2 : 0.5 + e((n - 0.5) * 2) / 2;
    };
  },
  Jl = function t(e, n, i) {
    var r = n >= 1 ? n : 1,
      s = (i || (e ? 0.3 : 0.45)) / (n < 1 ? n : 1),
      o = (s / Dl) * (Math.asin(1 / r) || 0),
      a = function (u) {
        return u === 1 ? 1 : r * Math.pow(2, -10 * u) * Bg((u - o) * s) + 1;
      },
      c =
        e === "out"
          ? a
          : e === "in"
          ? function (l) {
              return 1 - a(1 - l);
            }
          : ld(a);
    return (
      (s = Dl / s),
      (c.config = function (l, u) {
        return t(e, l, u);
      }),
      c
    );
  },
  $l = function t(e, n) {
    n === void 0 && (n = 1.70158);
    var i = function (o) {
        return o ? --o * o * ((n + 1) * o + n) + 1 : 0;
      },
      r =
        e === "out"
          ? i
          : e === "in"
          ? function (s) {
              return 1 - i(1 - s);
            }
          : ld(i);
    return (
      (r.config = function (s) {
        return t(e, s);
      }),
      r
    );
  };
Ke("Linear,Quad,Cubic,Quart,Quint,Strong", function (t, e) {
  var n = e < 5 ? e + 1 : e;
  $i(
    t + ",Power" + (n - 1),
    e
      ? function (i) {
          return Math.pow(i, n);
        }
      : function (i) {
          return i;
        },
    function (i) {
      return 1 - Math.pow(1 - i, n);
    },
    function (i) {
      return i < 0.5
        ? Math.pow(i * 2, n) / 2
        : 1 - Math.pow((1 - i) * 2, n) / 2;
    }
  );
});
zt.Linear.easeNone = zt.none = zt.Linear.easeIn;
$i("Elastic", Jl("in"), Jl("out"), Jl());
(function (t, e) {
  var n = 1 / e,
    i = 2 * n,
    r = 2.5 * n,
    s = function (a) {
      return a < n
        ? t * a * a
        : a < i
        ? t * Math.pow(a - 1.5 / e, 2) + 0.75
        : a < r
        ? t * (a -= 2.25 / e) * a + 0.9375
        : t * Math.pow(a - 2.625 / e, 2) + 0.984375;
    };
  $i(
    "Bounce",
    function (o) {
      return 1 - s(1 - o);
    },
    s
  );
})(7.5625, 2.75);
$i("Expo", function (t) {
  return t ? Math.pow(2, 10 * (t - 1)) : 0;
});
$i("Circ", function (t) {
  return -(Tf(1 - t * t) - 1);
});
$i("Sine", function (t) {
  return t === 1 ? 1 : -Fg(t * Ig) + 1;
});
$i("Back", $l("in"), $l("out"), $l());
zt.SteppedEase =
  zt.steps =
  $e.SteppedEase =
    {
      config: function (e, n) {
        e === void 0 && (e = 1);
        var i = 1 / e,
          r = e + (n ? 0 : 1),
          s = n ? 1 : 0,
          o = 1 - Ht;
        return function (a) {
          return (((r * Js(0, o, a)) | 0) + s) * i;
        };
      },
    };
Er.ease = zt["quad.out"];
Ke(
  "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
  function (t) {
    return (Hl += t + "," + t + "Params,");
  }
);
var ud = function (e, n) {
    (this.id = Ng++),
      (e._gsap = this),
      (this.target = e),
      (this.harness = n),
      (this.get = n ? n.get : Uf),
      (this.set = n ? n.getSetter : tu);
  },
  Ks = (function () {
    function t(n, i) {
      var r = n.parent || ye;
      (this.vars = n),
        (this._delay = +n.delay || 0),
        (this._repeat = n.repeat || 0) &&
          ((this._rDelay = n.repeatDelay || 0),
          (this._yoyo = !!n.yoyo || !!n.yoyoEase)),
        (this._ts = 1),
        Cr(this, +n.duration, 1, 1),
        (this.data = n.data),
        Ma || dn.wake(),
        r && ti(r, this, i || i === 0 ? i : r._time, 1),
        n.reversed && this.reverse(),
        n.paused && this.paused(!0);
    }
    var e = t.prototype;
    return (
      (e.delay = function (i) {
        return i || i === 0
          ? (this.parent &&
              this.parent.smoothChildTiming &&
              this.startTime(this._start + i - this._delay),
            (this._delay = i),
            this)
          : this._delay;
      }),
      (e.duration = function (i) {
        return arguments.length
          ? this.totalDuration(
              this._repeat > 0 ? i + (i + this._rDelay) * this._repeat : i
            )
          : this.totalDuration() && this._dur;
      }),
      (e.totalDuration = function (i) {
        return arguments.length
          ? ((this._dirty = 0),
            Cr(
              this,
              this._repeat < 0
                ? i
                : (i - this._repeat * this._rDelay) / (this._repeat + 1)
            ))
          : this._tDur;
      }),
      (e.totalTime = function (i, r) {
        if ((Dr(), !arguments.length)) return this._tTime;
        var s = this._dp;
        if (s && s.smoothChildTiming && this._ts) {
          for (jf(this, i); s.parent; )
            s.parent._time !==
              s._start +
                (s._ts >= 0
                  ? s._tTime / s._ts
                  : (s.totalDuration() - s._tTime) / -s._ts) &&
              s.totalTime(s._tTime, !0),
              (s = s.parent);
          !this.parent &&
            this._dp.autoRemoveChildren &&
            ((this._ts > 0 && i < this._tDur) ||
              (this._ts < 0 && i > 0) ||
              (!this._tDur && !i)) &&
            ti(this._dp, this, this._start - this._delay);
        }
        return (
          (this._tTime !== i ||
            (!this._dur && !r) ||
            (this._initted && Math.abs(this._zTime) === Ht) ||
            (!i && !this._initted && (this.add || this._ptLookup))) &&
            (this._ts || (this._pTime = i), kf(this, i, r)),
          this
        );
      }),
      (e.time = function (i, r) {
        return arguments.length
          ? this.totalTime(
              Math.min(this.totalDuration(), i + Wf(this)) % this._dur ||
                (i ? this._dur : 0),
              r
            )
          : this._time;
      }),
      (e.totalProgress = function (i, r) {
        return arguments.length
          ? this.totalTime(this.totalDuration() * i, r)
          : this.totalDuration()
          ? Math.min(1, this._tTime / this._tDur)
          : this.ratio;
      }),
      (e.progress = function (i, r) {
        return arguments.length
          ? this.totalTime(
              this.duration() *
                (this._yoyo && !(this.iteration() & 1) ? 1 - i : i) +
                Wf(this),
              r
            )
          : this.duration()
          ? Math.min(1, this._time / this._dur)
          : this.ratio;
      }),
      (e.iteration = function (i, r) {
        var s = this.duration() + this._rDelay;
        return arguments.length
          ? this.totalTime(this._time + (i - 1) * s, r)
          : this._repeat
          ? Pr(this._tTime, s) + 1
          : 1;
      }),
      (e.timeScale = function (i) {
        if (!arguments.length) return this._rts === -Ht ? 0 : this._rts;
        if (this._rts === i) return this;
        var r =
          this.parent && this._ts ? ba(this.parent._time, this) : this._tTime;
        return (
          (this._rts = +i || 0),
          (this._ts = this._ps || i === -Ht ? 0 : this._rts),
          Hg(this.totalTime(Js(-this._delay, this._tDur, r), !0))
        );
      }),
      (e.paused = function (i) {
        return arguments.length
          ? (this._ps !== i &&
              ((this._ps = i),
              i
                ? ((this._pTime =
                    this._tTime || Math.max(-this._delay, this.rawTime())),
                  (this._ts = this._act = 0))
                : (Dr(),
                  (this._ts = this._rts),
                  this.totalTime(
                    this.parent && !this.parent.smoothChildTiming
                      ? this.rawTime()
                      : this._tTime || this._pTime,
                    this.progress() === 1 &&
                      (this._tTime -= Ht) &&
                      Math.abs(this._zTime) !== Ht
                  ))),
            this)
          : this._ps;
      }),
      (e.startTime = function (i) {
        if (arguments.length) {
          this._start = i;
          var r = this.parent || this._dp;
          return (
            r && (r._sort || !this.parent) && ti(r, this, i - this._delay), this
          );
        }
        return this._start;
      }),
      (e.endTime = function (i) {
        return (
          this._start +
          (We(i) ? this.totalDuration() : this.duration()) / Math.abs(this._ts)
        );
      }),
      (e.rawTime = function (i) {
        var r = this.parent || this._dp;
        return r
          ? i &&
            (!this._ts ||
              (this._repeat && this._time && this.totalProgress() < 1))
            ? this._tTime % (this._dur + this._rDelay)
            : this._ts
            ? ba(r.rawTime(i), this)
            : this._tTime
          : this._tTime;
      }),
      (e.globalTime = function (i) {
        for (var r = this, s = arguments.length ? i : r.rawTime(); r; )
          (s = r._start + s / (r._ts || 1)), (r = r._dp);
        return s;
      }),
      (e.repeat = function (i) {
        return arguments.length ? ((this._repeat = i), Yf(this)) : this._repeat;
      }),
      (e.repeatDelay = function (i) {
        return arguments.length ? ((this._rDelay = i), Yf(this)) : this._rDelay;
      }),
      (e.yoyo = function (i) {
        return arguments.length ? ((this._yoyo = i), this) : this._yoyo;
      }),
      (e.seek = function (i, r) {
        return this.totalTime(Be(this, i), We(r));
      }),
      (e.restart = function (i, r) {
        return this.play().totalTime(i ? -this._delay : 0, We(r));
      }),
      (e.play = function (i, r) {
        return i != null && this.seek(i, r), this.reversed(!1).paused(!1);
      }),
      (e.reverse = function (i, r) {
        return (
          i != null && this.seek(i || this.totalDuration(), r),
          this.reversed(!0).paused(!1)
        );
      }),
      (e.pause = function (i, r) {
        return i != null && this.seek(i, r), this.paused(!0);
      }),
      (e.resume = function () {
        return this.paused(!1);
      }),
      (e.reversed = function (i) {
        return arguments.length
          ? (!!i !== this.reversed() &&
              this.timeScale(-this._rts || (i ? -Ht : 0)),
            this)
          : this._rts < 0;
      }),
      (e.invalidate = function () {
        return (this._initted = 0), (this._zTime = -Ht), this;
      }),
      (e.isActive = function () {
        var i = this.parent || this._dp,
          r = this._start,
          s;
        return !!(
          !i ||
          (this._ts &&
            this._initted &&
            i.isActive() &&
            (s = i.rawTime(!0)) >= r &&
            s < this.endTime(!0) - Ht)
        );
      }),
      (e.eventCallback = function (i, r, s) {
        var o = this.vars;
        return arguments.length > 1
          ? (r
              ? ((o[i] = r),
                s && (o[i + "Params"] = s),
                i === "onUpdate" && (this._onUpdate = r))
              : delete o[i],
            this)
          : o[i];
      }),
      (e.then = function (i) {
        var r = this;
        return new Promise(function (s) {
          var o = Te(i) ? i : Hf,
            a = function () {
              var l = r.then;
              (r.then = null),
                Te(o) && (o = o(r)) && (o.then || o === r) && (r.then = l),
                s(o),
                (r.then = l);
            };
          (r._initted && r.totalProgress() === 1 && r._ts >= 0) ||
          (!r._tTime && r._ts < 0)
            ? a()
            : (r._prom = a);
        });
      }),
      (e.kill = function () {
        $s(this);
      }),
      t
    );
  })();
fn(Ks.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -Ht,
  _prom: 0,
  _ps: !1,
  _rts: 1,
});
var je = (function (t) {
  Sf(e, t);
  function e(i, r) {
    var s;
    return (
      i === void 0 && (i = {}),
      (s = t.call(this, i, r) || this),
      (s.labels = {}),
      (s.smoothChildTiming = !!i.smoothChildTiming),
      (s.autoRemoveChildren = !!i.autoRemoveChildren),
      (s._sort = We(i.sortChildren)),
      s.parent && ql(s.parent, Qn(s)),
      i.scrollTrigger && qf(Qn(s), i.scrollTrigger),
      s
    );
  }
  var n = e.prototype;
  return (
    (n.to = function (r, s, o) {
      return (
        new _e(r, Zs(arguments, 0, this), Be(this, bn(s) ? arguments[3] : o)),
        this
      );
    }),
    (n.from = function (r, s, o) {
      return (
        new _e(r, Zs(arguments, 1, this), Be(this, bn(s) ? arguments[3] : o)),
        this
      );
    }),
    (n.fromTo = function (r, s, o, a) {
      return (
        new _e(r, Zs(arguments, 2, this), Be(this, bn(s) ? arguments[4] : a)),
        this
      );
    }),
    (n.set = function (r, s, o) {
      return (
        (s.duration = 0),
        (s.parent = this),
        xa(s).repeatDelay || (s.repeat = 0),
        (s.immediateRender = !!s.immediateRender),
        new _e(r, s, Be(this, o), 1),
        this
      );
    }),
    (n.call = function (r, s, o) {
      return ti(this, _e.delayedCall(0, r, s), Be(this, o));
    }),
    (n.staggerTo = function (r, s, o, a, c, l, u) {
      return (
        (o.duration = s),
        (o.stagger = o.stagger || a),
        (o.onComplete = l),
        (o.onCompleteParams = u),
        (o.parent = this),
        new _e(r, o, Be(this, c)),
        this
      );
    }),
    (n.staggerFrom = function (r, s, o, a, c, l, u) {
      return (
        (o.runBackwards = 1),
        (xa(o).immediateRender = We(o.immediateRender)),
        this.staggerTo(r, s, o, a, c, l, u)
      );
    }),
    (n.staggerFromTo = function (r, s, o, a, c, l, u, h) {
      return (
        (a.startAt = o),
        (xa(a).immediateRender = We(a.immediateRender)),
        this.staggerTo(r, s, a, c, l, u, h)
      );
    }),
    (n.render = function (r, s, o) {
      var a = this._time,
        c = this._dirty ? this.totalDuration() : this._tDur,
        l = this._dur,
        u = this !== ye && r > c - Ht && r >= 0 ? c : r < Ht ? 0 : r,
        h = this._zTime < 0 != r < 0 && (this._initted || !l),
        d,
        f,
        p,
        _,
        y,
        m,
        g,
        b,
        x,
        v,
        w,
        M;
      if (u !== this._tTime || o || h) {
        if (
          (a !== this._time &&
            l &&
            ((u += this._time - a), (r += this._time - a)),
          (d = u),
          (x = this._start),
          (b = this._ts),
          (m = !b),
          h && (l || (a = this._zTime), (r || !s) && (this._zTime = r)),
          this._repeat &&
            ((w = this._yoyo),
            (y = l + this._rDelay),
            (d = Bt(u % y)),
            u === c
              ? ((_ = this._repeat), (d = l))
              : ((_ = ~~(u / y)),
                _ && _ === u / y && ((d = l), _--),
                d > l && (d = l)),
            (v = Pr(this._tTime, y)),
            !a && this._tTime && v !== _ && (v = _),
            w && _ & 1 && ((d = l - d), (M = 1)),
            _ !== v && !this._lock))
        ) {
          var C = w && v & 1,
            A = C === (w && _ & 1);
          if (
            (_ < v && (C = !C),
            (a = C ? 0 : l),
            (this._lock = 1),
            (this.render(a || (M ? 0 : Bt(_ * y)), s, !l)._lock = 0),
            !s && this.parent && tn(this, "onRepeat"),
            this.vars.repeatRefresh && !M && (this.invalidate()._lock = 1),
            a !== this._time || m !== !this._ts)
          )
            return this;
          if (
            ((l = this._dur),
            (c = this._tDur),
            A &&
              ((this._lock = 2),
              (a = C ? l : -1e-4),
              this.render(a, !0),
              this.vars.repeatRefresh && !M && this.invalidate()),
            (this._lock = 0),
            !this._ts && !m)
          )
            return this;
          cd(this, M);
        }
        if (
          (this._hasPause &&
            !this._forcing &&
            this._lock < 2 &&
            ((g = jg(this, Bt(a), Bt(d))), g && (u -= d - (d = g._start))),
          (this._tTime = u),
          (this._time = d),
          (this._act = !b),
          this._initted ||
            ((this._onUpdate = this.vars.onUpdate),
            (this._initted = 1),
            (this._zTime = r)),
          !a && d && !s && tn(this, "onStart"),
          d >= a && r >= 0)
        )
          for (f = this._first; f; ) {
            if (
              ((p = f._next), (f._act || d >= f._start) && f._ts && g !== f)
            ) {
              if (f.parent !== this) return this.render(r, s, o);
              if (
                (f.render(
                  f._ts > 0
                    ? (d - f._start) * f._ts
                    : (f._dirty ? f.totalDuration() : f._tDur) +
                        (d - f._start) * f._ts,
                  s,
                  o
                ),
                d !== this._time || (!this._ts && !m))
              ) {
                (g = 0), p && (u += this._zTime = -Ht);
                break;
              }
            }
            f = p;
          }
        else {
          f = this._last;
          for (var U = r < 0 ? r : d; f; ) {
            if (((p = f._prev), (f._act || U <= f._end) && f._ts && g !== f)) {
              if (f.parent !== this) return this.render(r, s, o);
              if (
                (f.render(
                  f._ts > 0
                    ? (U - f._start) * f._ts
                    : (f._dirty ? f.totalDuration() : f._tDur) +
                        (U - f._start) * f._ts,
                  s,
                  o
                ),
                d !== this._time || (!this._ts && !m))
              ) {
                (g = 0), p && (u += this._zTime = U ? -Ht : Ht);
                break;
              }
            }
            f = p;
          }
        }
        if (
          g &&
          !s &&
          (this.pause(),
          (g.render(d >= a ? 0 : -Ht)._zTime = d >= a ? 1 : -1),
          this._ts)
        )
          return (this._start = x), jl(this), this.render(r, s, o);
        this._onUpdate && !s && tn(this, "onUpdate", !0),
          ((u === c && c >= this.totalDuration()) || (!u && a)) &&
            (x === this._start || Math.abs(b) !== Math.abs(this._ts)) &&
            (this._lock ||
              ((r || !l) &&
                ((u === c && this._ts > 0) || (!u && this._ts < 0)) &&
                bi(this, 1),
              !s &&
                !(r < 0 && !a) &&
                (u || a) &&
                (tn(this, u === c ? "onComplete" : "onReverseComplete", !0),
                this._prom &&
                  !(u < c && this.timeScale() > 0) &&
                  this._prom())));
      }
      return this;
    }),
    (n.add = function (r, s) {
      var o = this;
      if ((bn(s) || (s = Be(this, s)), !(r instanceof Ks))) {
        if (hn(r))
          return (
            r.forEach(function (a) {
              return o.add(a, s);
            }),
            this
          );
        if (Oe(r)) return this.addLabel(r, s);
        if (Te(r)) r = _e.delayedCall(0, r);
        else return this;
      }
      return this !== r ? ti(this, r, s) : this;
    }),
    (n.getChildren = function (r, s, o, a) {
      r === void 0 && (r = !0),
        s === void 0 && (s = !0),
        o === void 0 && (o = !0),
        a === void 0 && (a = -Dn);
      for (var c = [], l = this._first; l; )
        l._start >= a &&
          (l instanceof _e
            ? s && c.push(l)
            : (o && c.push(l), r && c.push.apply(c, l.getChildren(!0, s, o)))),
          (l = l._next);
      return c;
    }),
    (n.getById = function (r) {
      for (var s = this.getChildren(1, 1, 1), o = s.length; o--; )
        if (s[o].vars.id === r) return s[o];
    }),
    (n.remove = function (r) {
      return Oe(r)
        ? this.removeLabel(r)
        : Te(r)
        ? this.killTweensOf(r)
        : (va(this, r),
          r === this._recent && (this._recent = this._last),
          Ji(this));
    }),
    (n.totalTime = function (r, s) {
      return arguments.length
        ? ((this._forcing = 1),
          !this._dp &&
            this._ts &&
            (this._start = Bt(
              dn.time -
                (this._ts > 0
                  ? r / this._ts
                  : (this.totalDuration() - r) / -this._ts)
            )),
          t.prototype.totalTime.call(this, r, s),
          (this._forcing = 0),
          this)
        : this._tTime;
    }),
    (n.addLabel = function (r, s) {
      return (this.labels[r] = Be(this, s)), this;
    }),
    (n.removeLabel = function (r) {
      return delete this.labels[r], this;
    }),
    (n.addPause = function (r, s, o) {
      var a = _e.delayedCall(0, s || Ys, o);
      return (
        (a.data = "isPause"), (this._hasPause = 1), ti(this, a, Be(this, r))
      );
    }),
    (n.removePause = function (r) {
      var s = this._first;
      for (r = Be(this, r); s; )
        s._start === r && s.data === "isPause" && bi(s), (s = s._next);
    }),
    (n.killTweensOf = function (r, s, o) {
      for (var a = this.getTweensOf(r, o), c = a.length; c--; )
        Mi !== a[c] && a[c].kill(r, s);
      return this;
    }),
    (n.getTweensOf = function (r, s) {
      for (var o = [], a = Fn(r), c = this._first, l = bn(s), u; c; )
        c instanceof _e
          ? zg(c._targets, a) &&
            (l
              ? (!Mi || (c._initted && c._ts)) &&
                c.globalTime(0) <= s &&
                c.globalTime(c.totalDuration()) > s
              : !s || c.isActive()) &&
            o.push(c)
          : (u = c.getTweensOf(a, s)).length && o.push.apply(o, u),
          (c = c._next);
      return o;
    }),
    (n.tweenTo = function (r, s) {
      s = s || {};
      var o = this,
        a = Be(o, r),
        c = s,
        l = c.startAt,
        u = c.onStart,
        h = c.onStartParams,
        d = _e.to(
          o,
          fn(s, {
            ease: "none",
            lazy: !1,
            time: a,
            overwrite: "auto",
            duration:
              s.duration ||
              Math.abs(
                (a - (l && "time" in l ? l.time : o._time)) / o.timeScale()
              ) ||
              Ht,
            onStart: function () {
              o.pause();
              var p = s.duration || Math.abs((a - o._time) / o.timeScale());
              d._dur !== p && Cr(d, p, 0, 1).render(d._time, !0, !0),
                u && u.apply(d, h || []);
            },
          })
        );
      return d;
    }),
    (n.tweenFromTo = function (r, s, o) {
      return this.tweenTo(s, fn({ startAt: { time: Be(this, r) } }, o));
    }),
    (n.recent = function () {
      return this._recent;
    }),
    (n.nextLabel = function (r) {
      return r === void 0 && (r = this._time), nd(this, Be(this, r));
    }),
    (n.previousLabel = function (r) {
      return r === void 0 && (r = this._time), nd(this, Be(this, r), 1);
    }),
    (n.currentLabel = function (r) {
      return arguments.length
        ? this.seek(r, !0)
        : this.previousLabel(this._time + Ht);
    }),
    (n.shiftChildren = function (r, s, o) {
      o === void 0 && (o = 0);
      for (var a = this._first, c = this.labels, l; a; )
        a._start >= o && ((a._start += r), (a._end += r)), (a = a._next);
      if (s) for (l in c) c[l] >= o && (c[l] += r);
      return Ji(this);
    }),
    (n.invalidate = function () {
      var r = this._first;
      for (this._lock = 0; r; ) r.invalidate(), (r = r._next);
      return t.prototype.invalidate.call(this);
    }),
    (n.clear = function (r) {
      r === void 0 && (r = !0);
      for (var s = this._first, o; s; ) (o = s._next), this.remove(s), (s = o);
      return (
        (this._time = this._tTime = this._pTime = 0),
        r && (this.labels = {}),
        Ji(this)
      );
    }),
    (n.totalDuration = function (r) {
      var s = 0,
        o = this,
        a = o._last,
        c = Dn,
        l,
        u,
        h;
      if (arguments.length)
        return o.timeScale(
          (o._repeat < 0 ? o.duration() : o.totalDuration()) /
            (o.reversed() ? -r : r)
        );
      if (o._dirty) {
        for (h = o.parent; a; )
          (l = a._prev),
            a._dirty && a.totalDuration(),
            (u = a._start),
            u > c && o._sort && a._ts && !o._lock
              ? ((o._lock = 1), (ti(o, a, u - a._delay, 1)._lock = 0))
              : (c = u),
            u < 0 &&
              a._ts &&
              ((s -= u),
              ((!h && !o._dp) || (h && h.smoothChildTiming)) &&
                ((o._start += u / o._ts), (o._time -= u), (o._tTime -= u)),
              o.shiftChildren(-u, !1, -1 / 0),
              (c = 0)),
            a._end > s && a._ts && (s = a._end),
            (a = l);
        Cr(o, o === ye && o._time > s ? o._time : s, 1, 1), (o._dirty = 0);
      }
      return o._tDur;
    }),
    (e.updateRoot = function (r) {
      if ((ye._ts && (kf(ye, ba(r, ye)), (Bf = dn.frame)), dn.frame >= zf)) {
        zf += un.autoSleep || 120;
        var s = ye._first;
        if ((!s || !s._ts) && un.autoSleep && dn._listeners.length < 2) {
          for (; s && !s._ts; ) s = s._next;
          s || dn.sleep();
        }
      }
    }),
    e
  );
})(Ks);
fn(je.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
var cy = function (e, n, i, r, s, o, a) {
    var c = new qe(this._pt, e, n, 0, 1, md, null, s),
      l = 0,
      u = 0,
      h,
      d,
      f,
      p,
      _,
      y,
      m,
      g;
    for (
      c.b = i,
        c.e = r,
        i += "",
        r += "",
        (m = ~r.indexOf("random(")) && (r = wa(r)),
        o && ((g = [i, r]), o(g, e, n), (i = g[0]), (r = g[1])),
        d = i.match(Fl) || [];
      (h = Fl.exec(r));

    )
      (p = h[0]),
        (_ = r.substring(l, h.index)),
        f ? (f = (f + 1) % 5) : _.substr(-5) === "rgba(" && (f = 1),
        p !== d[u++] &&
          ((y = parseFloat(d[u - 1]) || 0),
          (c._pt = {
            _next: c._pt,
            p: _ || u === 1 ? _ : ",",
            s: y,
            c:
              p.charAt(1) === "="
                ? parseFloat(p.substr(2)) * (p.charAt(0) === "-" ? -1 : 1)
                : parseFloat(p) - y,
            m: f && f < 4 ? Math.round : 0,
          }),
          (l = Fl.lastIndex));
    return (
      (c.c = l < r.length ? r.substring(l, r.length) : ""),
      (c.fp = a),
      (Cf.test(r) || m) && (c.e = 0),
      (this._pt = c),
      c
    );
  },
  Ql = function (e, n, i, r, s, o, a, c, l) {
    Te(r) && (r = r(s || 0, e, o));
    var u = e[n],
      h =
        i !== "get"
          ? i
          : Te(u)
          ? l
            ? e[
                n.indexOf("set") || !Te(e["get" + n.substr(3)])
                  ? n
                  : "get" + n.substr(3)
              ](l)
            : e[n]()
          : u,
      d = Te(u) ? (l ? dy : dd) : Kl,
      f;
    if (
      (Oe(r) &&
        (~r.indexOf("random(") && (r = wa(r)),
        r.charAt(1) === "=" &&
          (r =
            parseFloat(h) +
            parseFloat(r.substr(2)) * (r.charAt(0) === "-" ? -1 : 1) +
            (Nn(h) || 0))),
      h !== r)
    )
      return isNaN(h * r)
        ? (!u && !(n in e) && zl(n, r),
          cy.call(this, e, n, h, r, d, c || un.stringFilter, l))
        : ((f = new qe(
            this._pt,
            e,
            n,
            +h || 0,
            r - (h || 0),
            typeof u == "boolean" ? my : pd,
            0,
            d
          )),
          l && (f.fp = l),
          a && f.modifier(a, this, e),
          (this._pt = f));
  },
  ly = function (e, n, i, r, s) {
    if (
      (Te(e) && (e = to(e, s, n, i, r)),
      !Kn(e) || (e.style && e.nodeType) || hn(e) || Lf(e))
    )
      return Oe(e) ? to(e, s, n, i, r) : e;
    var o = {},
      a;
    for (a in e) o[a] = to(e[a], s, n, i, r);
    return o;
  },
  hd = function (e, n, i, r, s, o) {
    var a, c, l, u;
    if (
      Qe[e] &&
      (a = new Qe[e]()).init(
        s,
        a.rawVars ? n[e] : ly(n[e], r, s, o, i),
        i,
        r,
        o
      ) !== !1 &&
      ((i._pt = c = new qe(i._pt, s, e, 0, 1, a.render, a, 0, a.priority)),
      i !== Rr)
    )
      for (l = i._ptLookup[i._targets.indexOf(s)], u = a._props.length; u--; )
        l[a._props[u]] = c;
    return a;
  },
  Mi,
  uy = function t(e, n) {
    var i = e.vars,
      r = i.ease,
      s = i.startAt,
      o = i.immediateRender,
      a = i.lazy,
      c = i.onUpdate,
      l = i.onUpdateParams,
      u = i.callbackScope,
      h = i.runBackwards,
      d = i.yoyoEase,
      f = i.keyframes,
      p = i.autoRevert,
      _ = e._dur,
      y = e._startAt,
      m = e._targets,
      g = e.parent,
      b = g && g.data === "nested" ? g.parent._targets : m,
      x = e._overwrite === "auto",
      v = e.timeline,
      w,
      M,
      C,
      A,
      U,
      I,
      B,
      F,
      O,
      R,
      P,
      V,
      Y;
    if (
      (v && (!f || !r) && (r = "none"),
      (e._ease = Ir(r, Er.ease)),
      (e._yEase = d ? ad(Ir(d === !0 ? r : d, Er.ease)) : 0),
      d &&
        e._yoyo &&
        !e._repeat &&
        ((d = e._yEase), (e._yEase = e._ease), (e._ease = d)),
      !v)
    ) {
      if (
        ((F = m[0] ? Zi(m[0]).harness : 0),
        (V = F && i[F.prop]),
        (w = Wl(i, Ul)),
        y && y.render(-1, !0).kill(),
        s)
      ) {
        if (
          (bi(
            (e._startAt = _e.set(
              m,
              fn(
                {
                  data: "isStart",
                  overwrite: !1,
                  parent: g,
                  immediateRender: !0,
                  lazy: We(a),
                  startAt: null,
                  delay: 0,
                  onUpdate: c,
                  onUpdateParams: l,
                  callbackScope: u,
                  stagger: 0,
                },
                s
              )
            ))
          ),
          o)
        ) {
          if (n > 0) p || (e._startAt = 0);
          else if (_ && !(n < 0 && y)) {
            n && (e._zTime = n);
            return;
          }
        }
      } else if (h && _) {
        if (y) !p && (e._startAt = 0);
        else if (
          (n && (o = !1),
          (C = fn(
            {
              overwrite: !1,
              data: "isFromStart",
              lazy: o && We(a),
              immediateRender: o,
              stagger: 0,
              parent: g,
            },
            w
          )),
          V && (C[F.prop] = V),
          bi((e._startAt = _e.set(m, C))),
          !o)
        )
          t(e._startAt, Ht);
        else if (!n) return;
      }
      for (e._pt = 0, a = (_ && We(a)) || (a && !_), M = 0; M < m.length; M++) {
        if (
          ((U = m[M]),
          (B = U._gsap || Vl(m)[M]._gsap),
          (e._ptLookup[M] = R = {}),
          kl[B.id] && vi.length && _a(),
          (P = b === m ? M : b.indexOf(U)),
          F &&
            (O = new F()).init(U, V || w, e, P, b) !== !1 &&
            ((e._pt = A =
              new qe(e._pt, U, O.name, 0, 1, O.render, O, 0, O.priority)),
            O._props.forEach(function (K) {
              R[K] = A;
            }),
            O.priority && (I = 1)),
          !F || V)
        )
          for (C in w)
            Qe[C] && (O = hd(C, w, e, P, U, b))
              ? O.priority && (I = 1)
              : (R[C] = A =
                  Ql.call(e, U, C, "get", w[C], P, b, 0, i.stringFilter));
        e._op && e._op[M] && e.kill(U, e._op[M]),
          x &&
            e._pt &&
            ((Mi = e),
            ye.killTweensOf(U, R, e.globalTime(0)),
            (Y = !e.parent),
            (Mi = 0)),
          e._pt && a && (kl[B.id] = 1);
      }
      I && gd(e), e._onInit && e._onInit(e);
    }
    (e._from = !v && !!i.runBackwards),
      (e._onUpdate = c),
      (e._initted = (!e._op || e._pt) && !Y);
  },
  hy = function (e, n) {
    var i = e[0] ? Zi(e[0]).harness : 0,
      r = i && i.aliases,
      s,
      o,
      a,
      c;
    if (!r) return n;
    s = Lr({}, n);
    for (o in r)
      if (o in s) for (c = r[o].split(","), a = c.length; a--; ) s[c[a]] = s[o];
    return s;
  },
  to = function (e, n, i, r, s) {
    return Te(e)
      ? e.call(n, i, r, s)
      : Oe(e) && ~e.indexOf("random(")
      ? wa(e)
      : e;
  },
  fd = Hl + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
  fy = (fd + ",id,stagger,delay,duration,paused,scrollTrigger").split(","),
  _e = (function (t) {
    Sf(e, t);
    function e(i, r, s, o) {
      var a;
      typeof r == "number" && ((s.duration = r), (r = s), (s = null)),
        (a = t.call(this, o ? r : xa(r), s) || this);
      var c = a.vars,
        l = c.duration,
        u = c.delay,
        h = c.immediateRender,
        d = c.stagger,
        f = c.overwrite,
        p = c.keyframes,
        _ = c.defaults,
        y = c.scrollTrigger,
        m = c.yoyoEase,
        g = a.parent,
        b = (hn(i) || Lf(i) ? bn(i[0]) : "length" in r) ? [i] : Fn(i),
        x,
        v,
        w,
        M,
        C,
        A,
        U,
        I;
      if (
        ((a._targets = b.length
          ? Vl(b)
          : Nf(
              "GSAP target " + i + " not found. https://greensock.com",
              !un.nullTargetWarn
            ) || []),
        (a._ptLookup = []),
        (a._overwrite = f),
        p || d || Af(l) || Af(u))
      ) {
        if (
          ((r = a.vars),
          (x = a.timeline = new je({ data: "nested", defaults: _ || {} })),
          x.kill(),
          (x.parent = Qn(a)),
          p)
        )
          fn(x.vars.defaults, { ease: "none" }),
            p.forEach(function (B) {
              return x.to(b, B, ">");
            });
        else {
          if (((M = b.length), (U = d ? $f(d) : Ys), Kn(d)))
            for (C in d) ~fd.indexOf(C) && (I || (I = {}), (I[C] = d[C]));
          for (v = 0; v < M; v++) {
            w = {};
            for (C in r) fy.indexOf(C) < 0 && (w[C] = r[C]);
            (w.stagger = 0),
              m && (w.yoyoEase = m),
              I && Lr(w, I),
              (A = b[v]),
              (w.duration = +to(l, Qn(a), v, A, b)),
              (w.delay = (+to(u, Qn(a), v, A, b) || 0) - a._delay),
              !d &&
                M === 1 &&
                w.delay &&
                ((a._delay = u = w.delay), (a._start += u), (w.delay = 0)),
              x.to(A, w, U(v, A, b));
          }
          x.duration() ? (l = u = 0) : (a.timeline = 0);
        }
        l || a.duration((l = x.duration()));
      } else a.timeline = 0;
      return (
        f === !0 && ((Mi = Qn(a)), ye.killTweensOf(b), (Mi = 0)),
        g && ql(g, Qn(a)),
        (h ||
          (!l &&
            !p &&
            a._start === Bt(g._time) &&
            We(h) &&
            Vg(Qn(a)) &&
            g.data !== "nested")) &&
          ((a._tTime = -Ht), a.render(Math.max(0, -u))),
        y && qf(Qn(a), y),
        a
      );
    }
    var n = e.prototype;
    return (
      (n.render = function (r, s, o) {
        var a = this._time,
          c = this._tDur,
          l = this._dur,
          u = r > c - Ht && r >= 0 ? c : r < Ht ? 0 : r,
          h,
          d,
          f,
          p,
          _,
          y,
          m,
          g,
          b;
        if (!l) Wg(this, r, s, o);
        else if (
          u !== this._tTime ||
          !r ||
          o ||
          (this._startAt && this._zTime < 0 != r < 0)
        ) {
          if (((h = u), (g = this.timeline), this._repeat)) {
            if (
              ((p = l + this._rDelay),
              (h = Bt(u % p)),
              u === c
                ? ((f = this._repeat), (h = l))
                : ((f = ~~(u / p)),
                  f && f === u / p && ((h = l), f--),
                  h > l && (h = l)),
              (y = this._yoyo && f & 1),
              y && ((b = this._yEase), (h = l - h)),
              (_ = Pr(this._tTime, p)),
              h === a && !o && this._initted)
            )
              return this;
            f !== _ &&
              (g && this._yEase && cd(g, y),
              this.vars.repeatRefresh &&
                !y &&
                !this._lock &&
                ((this._lock = o = 1),
                (this.render(Bt(p * f), !0).invalidate()._lock = 0)));
          }
          if (!this._initted) {
            if (Xf(this, r < 0 ? r : h, o, s)) return (this._tTime = 0), this;
            if (l !== this._dur) return this.render(r, s, o);
          }
          for (
            this._tTime = u,
              this._time = h,
              !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
              this.ratio = m = (b || this._ease)(h / l),
              this._from && (this.ratio = m = 1 - m),
              h && !a && !s && tn(this, "onStart"),
              d = this._pt;
            d;

          )
            d.r(m, d.d), (d = d._next);
          (g && g.render(r < 0 ? r : !h && y ? -Ht : g._dur * m, s, o)) ||
            (this._startAt && (this._zTime = r)),
            this._onUpdate &&
              !s &&
              (r < 0 && this._startAt && this._startAt.render(r, !0, o),
              tn(this, "onUpdate")),
            this._repeat &&
              f !== _ &&
              this.vars.onRepeat &&
              !s &&
              this.parent &&
              tn(this, "onRepeat"),
            (u === this._tDur || !u) &&
              this._tTime === u &&
              (r < 0 &&
                this._startAt &&
                !this._onUpdate &&
                this._startAt.render(r, !0, !0),
              (r || !l) &&
                ((u === this._tDur && this._ts > 0) || (!u && this._ts < 0)) &&
                bi(this, 1),
              !s &&
                !(r < 0 && !a) &&
                (u || a) &&
                (tn(this, u === c ? "onComplete" : "onReverseComplete", !0),
                this._prom &&
                  !(u < c && this.timeScale() > 0) &&
                  this._prom()));
        }
        return this;
      }),
      (n.targets = function () {
        return this._targets;
      }),
      (n.invalidate = function () {
        return (
          (this._pt =
            this._op =
            this._startAt =
            this._onUpdate =
            this._act =
            this._lazy =
              0),
          (this._ptLookup = []),
          this.timeline && this.timeline.invalidate(),
          t.prototype.invalidate.call(this)
        );
      }),
      (n.kill = function (r, s) {
        if (
          (s === void 0 && (s = "all"),
          !r && (!s || s === "all") && ((this._lazy = 0), this.parent))
        )
          return $s(this);
        if (this.timeline) {
          var o = this.timeline.totalDuration();
          return (
            this.timeline.killTweensOf(r, s, Mi && Mi.vars.overwrite !== !0)
              ._first || $s(this),
            this.parent &&
              o !== this.timeline.totalDuration() &&
              Cr(this, (this._dur * this.timeline._tDur) / o, 0, 1),
            this
          );
        }
        var a = this._targets,
          c = r ? Fn(r) : a,
          l = this._ptLookup,
          u = this._pt,
          h,
          d,
          f,
          p,
          _,
          y,
          m;
        if ((!s || s === "all") && kg(a, c))
          return s === "all" && (this._pt = 0), $s(this);
        for (
          h = this._op = this._op || [],
            s !== "all" &&
              (Oe(s) &&
                ((_ = {}),
                Ke(s, function (g) {
                  return (_[g] = 1);
                }),
                (s = _)),
              (s = hy(a, s))),
            m = a.length;
          m--;

        )
          if (~c.indexOf(a[m])) {
            (d = l[m]),
              s === "all"
                ? ((h[m] = s), (p = d), (f = {}))
                : ((f = h[m] = h[m] || {}), (p = s));
            for (_ in p)
              (y = d && d[_]),
                y &&
                  ((!("kill" in y.d) || y.d.kill(_) === !0) &&
                    va(this, y, "_pt"),
                  delete d[_]),
                f !== "all" && (f[_] = 1);
          }
        return this._initted && !this._pt && u && $s(this), this;
      }),
      (e.to = function (r, s) {
        return new e(r, s, arguments[2]);
      }),
      (e.from = function (r, s) {
        return new e(r, Zs(arguments, 1));
      }),
      (e.delayedCall = function (r, s, o, a) {
        return new e(s, 0, {
          immediateRender: !1,
          lazy: !1,
          overwrite: !1,
          delay: r,
          onComplete: s,
          onReverseComplete: s,
          onCompleteParams: o,
          onReverseCompleteParams: o,
          callbackScope: a,
        });
      }),
      (e.fromTo = function (r, s, o) {
        return new e(r, Zs(arguments, 2));
      }),
      (e.set = function (r, s) {
        return (s.duration = 0), s.repeatDelay || (s.repeat = 0), new e(r, s);
      }),
      (e.killTweensOf = function (r, s, o) {
        return ye.killTweensOf(r, s, o);
      }),
      e
    );
  })(Ks);
fn(_e.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 });
Ke("staggerTo,staggerFrom,staggerFromTo", function (t) {
  _e[t] = function () {
    var e = new je(),
      n = Xl.call(arguments, 0);
    return n.splice(t === "staggerFromTo" ? 5 : 4, 0, 0), e[t].apply(e, n);
  };
});
var Kl = function (e, n, i) {
    return (e[n] = i);
  },
  dd = function (e, n, i) {
    return e[n](i);
  },
  dy = function (e, n, i, r) {
    return e[n](r.fp, i);
  },
  py = function (e, n, i) {
    return e.setAttribute(n, i);
  },
  tu = function (e, n) {
    return Te(e[n]) ? dd : Il(e[n]) && e.setAttribute ? py : Kl;
  },
  pd = function (e, n) {
    return n.set(n.t, n.p, Math.round((n.s + n.c * e) * 1e4) / 1e4, n);
  },
  my = function (e, n) {
    return n.set(n.t, n.p, !!(n.s + n.c * e), n);
  },
  md = function (e, n) {
    var i = n._pt,
      r = "";
    if (!e && n.b) r = n.b;
    else if (e === 1 && n.e) r = n.e;
    else {
      for (; i; )
        (r =
          i.p +
          (i.m ? i.m(i.s + i.c * e) : Math.round((i.s + i.c * e) * 1e4) / 1e4) +
          r),
          (i = i._next);
      r += n.c;
    }
    n.set(n.t, n.p, r, n);
  },
  eu = function (e, n) {
    for (var i = n._pt; i; ) i.r(e, i.d), (i = i._next);
  },
  gy = function (e, n, i, r) {
    for (var s = this._pt, o; s; )
      (o = s._next), s.p === r && s.modifier(e, n, i), (s = o);
  },
  yy = function (e) {
    for (var n = this._pt, i, r; n; )
      (r = n._next),
        (n.p === e && !n.op) || n.op === e
          ? va(this, n, "_pt")
          : n.dep || (i = 1),
        (n = r);
    return !i;
  },
  _y = function (e, n, i, r) {
    r.mSet(e, n, r.m.call(r.tween, i, r.mt), r);
  },
  gd = function (e) {
    for (var n = e._pt, i, r, s, o; n; ) {
      for (i = n._next, r = s; r && r.pr > n.pr; ) r = r._next;
      (n._prev = r ? r._prev : o) ? (n._prev._next = n) : (s = n),
        (n._next = r) ? (r._prev = n) : (o = n),
        (n = i);
    }
    e._pt = s;
  },
  qe = (function () {
    function t(n, i, r, s, o, a, c, l, u) {
      (this.t = i),
        (this.s = s),
        (this.c = o),
        (this.p = r),
        (this.r = a || pd),
        (this.d = c || this),
        (this.set = l || Kl),
        (this.pr = u || 0),
        (this._next = n),
        n && (n._prev = this);
    }
    var e = t.prototype;
    return (
      (e.modifier = function (i, r, s) {
        (this.mSet = this.mSet || this.set),
          (this.set = _y),
          (this.m = i),
          (this.mt = s),
          (this.tween = r);
      }),
      t
    );
  })();
Ke(
  Hl +
    "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
  function (t) {
    return (Ul[t] = 1);
  }
);
$e.TweenMax = $e.TweenLite = _e;
$e.TimelineLite = $e.TimelineMax = je;
ye = new je({
  sortChildren: !1,
  defaults: Er,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0,
});
un.stringFilter = od;
var Sa = {
  registerPlugin: function () {
    for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++)
      n[i] = arguments[i];
    n.forEach(function (r) {
      return ey(r);
    });
  },
  timeline: function (e) {
    return new je(e);
  },
  getTweensOf: function (e, n) {
    return ye.getTweensOf(e, n);
  },
  getProperty: function (e, n, i, r) {
    Oe(e) && (e = Fn(e)[0]);
    var s = Zi(e || {}).get,
      o = i ? Hf : Gf;
    return (
      i === "native" && (i = ""),
      e &&
        (n
          ? o(((Qe[n] && Qe[n].get) || s)(e, n, i, r))
          : function (a, c, l) {
              return o(((Qe[a] && Qe[a].get) || s)(e, a, c, l));
            })
    );
  },
  quickSetter: function (e, n, i) {
    if (((e = Fn(e)), e.length > 1)) {
      var r = e.map(function (u) {
          return Bn.quickSetter(u, n, i);
        }),
        s = r.length;
      return function (u) {
        for (var h = s; h--; ) r[h](u);
      };
    }
    e = e[0] || {};
    var o = Qe[n],
      a = Zi(e),
      c = (a.harness && (a.harness.aliases || {})[n]) || n,
      l = o
        ? function (u) {
            var h = new o();
            (Rr._pt = 0),
              h.init(e, i ? u + i : u, Rr, 0, [e]),
              h.render(1, h),
              Rr._pt && eu(1, Rr);
          }
        : a.set(e, c);
    return o
      ? l
      : function (u) {
          return l(e, c, i ? u + i : u, a, 1);
        };
  },
  isTweening: function (e) {
    return ye.getTweensOf(e, !0).length > 0;
  },
  defaults: function (e) {
    return e && e.ease && (e.ease = Ir(e.ease, Er.ease)), Vf(Er, e || {});
  },
  config: function (e) {
    return Vf(un, e || {});
  },
  registerEffect: function (e) {
    var n = e.name,
      i = e.effect,
      r = e.plugins,
      s = e.defaults,
      o = e.extendTimeline;
    (r || "").split(",").forEach(function (a) {
      return (
        a && !Qe[a] && !$e[a] && Nf(n + " effect requires " + a + " plugin.")
      );
    }),
      (Gl[n] = function (a, c, l) {
        return i(Fn(a), fn(c || {}, s), l);
      }),
      o &&
        (je.prototype[n] = function (a, c, l) {
          return this.add(Gl[n](a, Kn(c) ? c : (l = c) && {}, this), l);
        });
  },
  registerEase: function (e, n) {
    zt[e] = Ir(n);
  },
  parseEase: function (e, n) {
    return arguments.length ? Ir(e, n) : zt;
  },
  getById: function (e) {
    return ye.getById(e);
  },
  exportRoot: function (e, n) {
    e === void 0 && (e = {});
    var i = new je(e),
      r,
      s;
    for (
      i.smoothChildTiming = We(e.smoothChildTiming),
        ye.remove(i),
        i._dp = 0,
        i._time = i._tTime = ye._time,
        r = ye._first;
      r;

    )
      (s = r._next),
        (n ||
          !(
            !r._dur &&
            r instanceof _e &&
            r.vars.onComplete === r._targets[0]
          )) &&
          ti(i, r, r._start - r._delay),
        (r = s);
    return ti(ye, i, 0), i;
  },
  utils: {
    wrap: Qg,
    wrapYoyo: Kg,
    distribute: $f,
    random: Kf,
    snap: Qf,
    normalize: $g,
    getUnit: Nn,
    clamp: Xg,
    splitColor: id,
    toArray: Fn,
    mapRange: ed,
    pipe: Zg,
    unitize: Jg,
    interpolate: ty,
    shuffle: Jf,
  },
  install: If,
  effects: Gl,
  ticker: dn,
  updateRoot: je.updateRoot,
  plugins: Qe,
  globalTimeline: ye,
  core: {
    PropTween: qe,
    globals: Ff,
    Tween: _e,
    Timeline: je,
    Animation: Ks,
    getCache: Zi,
    _removeLinkedListItem: va,
  },
};
Ke("to,from,fromTo,delayedCall,set,killTweensOf", function (t) {
  return (Sa[t] = _e[t]);
});
dn.add(je.updateRoot);
Rr = Sa.to({}, { duration: 0 });
var xy = function (e, n) {
    for (var i = e._pt; i && i.p !== n && i.op !== n && i.fp !== n; )
      i = i._next;
    return i;
  },
  vy = function (e, n) {
    var i = e._targets,
      r,
      s,
      o;
    for (r in n)
      for (s = i.length; s--; )
        (o = e._ptLookup[s][r]),
          o &&
            (o = o.d) &&
            (o._pt && (o = xy(o, r)),
            o && o.modifier && o.modifier(n[r], e, i[s], r));
  },
  nu = function (e, n) {
    return {
      name: e,
      rawVars: 1,
      init: function (r, s, o) {
        o._onInit = function (a) {
          var c, l;
          if (
            (Oe(s) &&
              ((c = {}),
              Ke(s, function (u) {
                return (c[u] = 1);
              }),
              (s = c)),
            n)
          ) {
            c = {};
            for (l in s) c[l] = n(s[l]);
            s = c;
          }
          vy(a, s);
        };
      },
    };
  },
  Bn =
    Sa.registerPlugin(
      {
        name: "attr",
        init: function (e, n, i, r, s) {
          var o, a;
          for (o in n)
            (a = this.add(
              e,
              "setAttribute",
              (e.getAttribute(o) || 0) + "",
              n[o],
              r,
              s,
              0,
              0,
              o
            )),
              a && (a.op = o),
              this._props.push(o);
        },
      },
      {
        name: "endArray",
        init: function (e, n) {
          for (var i = n.length; i--; ) this.add(e, i, e[i] || 0, n[i]);
        },
      },
      nu("roundProps", Yl),
      nu("modifiers"),
      nu("snap", Qf)
    ) || Sa;
_e.version = je.version = Bn.version = "3.5.1";
Df = 1;
Ef() && Dr();
zt.Power0;
zt.Power1;
zt.Power2;
zt.Power3;
zt.Power4;
zt.Linear;
zt.Quad;
zt.Cubic;
zt.Quart;
zt.Quint;
zt.Strong;
zt.Elastic;
zt.Back;
zt.SteppedEase;
zt.Bounce;
zt.Sine;
zt.Expo;
zt.Circ;
/*!
 * CSSPlugin 3.5.1
 * https://greensock.com
 *
 * Copyright 2008-2020, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var yd,
  zn,
  Nr,
  iu,
  Qi,
  eo,
  _d,
  by = function () {
    return typeof window != "undefined";
  },
  Si = {},
  Ki = 180 / Math.PI,
  Fr = Math.PI / 180,
  Br = Math.atan2,
  xd = 1e8,
  vd = /([A-Z])/g,
  wy = /(?:left|right|width|margin|padding|x)/i,
  My = /[\s,\(]\S/,
  Ti = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity",
  },
  bd = function (e, n) {
    return n.set(n.t, n.p, Math.round((n.s + n.c * e) * 1e4) / 1e4 + n.u, n);
  },
  Sy = function (e, n) {
    return n.set(
      n.t,
      n.p,
      e === 1 ? n.e : Math.round((n.s + n.c * e) * 1e4) / 1e4 + n.u,
      n
    );
  },
  Ty = function (e, n) {
    return n.set(
      n.t,
      n.p,
      e ? Math.round((n.s + n.c * e) * 1e4) / 1e4 + n.u : n.b,
      n
    );
  },
  Ey = function (e, n) {
    var i = n.s + n.c * e;
    n.set(n.t, n.p, ~~(i + (i < 0 ? -0.5 : 0.5)) + n.u, n);
  },
  wd = function (e, n) {
    return n.set(n.t, n.p, e ? n.e : n.b, n);
  },
  Md = function (e, n) {
    return n.set(n.t, n.p, e !== 1 ? n.b : n.e, n);
  },
  Ay = function (e, n, i) {
    return (e.style[n] = i);
  },
  Ly = function (e, n, i) {
    return e.style.setProperty(n, i);
  },
  Py = function (e, n, i) {
    return (e._gsap[n] = i);
  },
  Cy = function (e, n, i) {
    return (e._gsap.scaleX = e._gsap.scaleY = i);
  },
  Ry = function (e, n, i, r, s) {
    var o = e._gsap;
    (o.scaleX = o.scaleY = i), o.renderTransform(s, o);
  },
  Oy = function (e, n, i, r, s) {
    var o = e._gsap;
    (o[n] = i), o.renderTransform(s, o);
  },
  en = "transform",
  Ei = en + "Origin",
  Sd,
  ru = function (e, n) {
    var i = zn.createElementNS
      ? zn.createElementNS(
          (n || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"),
          e
        )
      : zn.createElement(e);
    return i.style ? i : zn.createElement(e);
  },
  ei = function t(e, n, i) {
    var r = getComputedStyle(e);
    return (
      r[n] ||
      r.getPropertyValue(n.replace(vd, "-$1").toLowerCase()) ||
      r.getPropertyValue(n) ||
      (!i && t(e, zr(n) || n, 1)) ||
      ""
    );
  },
  Td = "O,Moz,ms,Ms,Webkit".split(","),
  zr = function (e, n, i) {
    var r = n || Qi,
      s = r.style,
      o = 5;
    if (e in s && !i) return e;
    for (
      e = e.charAt(0).toUpperCase() + e.substr(1);
      o-- && !(Td[o] + e in s);

    );
    return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? Td[o] : "") + e;
  },
  su = function () {
    by() &&
      window.document &&
      ((yd = window),
      (zn = yd.document),
      (Nr = zn.documentElement),
      (Qi = ru("div") || { style: {} }),
      (eo = ru("div")),
      (en = zr(en)),
      (Ei = en + "Origin"),
      (Qi.style.cssText =
        "border-width:0;line-height:0;position:absolute;padding:0"),
      (Sd = !!zr("perspective")),
      (iu = 1));
  },
  ou = function t(e) {
    var n = ru(
        "svg",
        (this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns")) ||
          "http://www.w3.org/2000/svg"
      ),
      i = this.parentNode,
      r = this.nextSibling,
      s = this.style.cssText,
      o;
    if (
      (Nr.appendChild(n),
      n.appendChild(this),
      (this.style.display = "block"),
      e)
    )
      try {
        (o = this.getBBox()),
          (this._gsapBBox = this.getBBox),
          (this.getBBox = t);
      } catch {}
    else this._gsapBBox && (o = this._gsapBBox());
    return (
      i && (r ? i.insertBefore(this, r) : i.appendChild(this)),
      Nr.removeChild(n),
      (this.style.cssText = s),
      o
    );
  },
  Ed = function (e, n) {
    for (var i = n.length; i--; )
      if (e.hasAttribute(n[i])) return e.getAttribute(n[i]);
  },
  Ad = function (e) {
    var n;
    try {
      n = e.getBBox();
    } catch {
      n = ou.call(e, !0);
    }
    return (
      (n && (n.width || n.height)) || e.getBBox === ou || (n = ou.call(e, !0)),
      n && !n.width && !n.x && !n.y
        ? {
            x: +Ed(e, ["x", "cx", "x1"]) || 0,
            y: +Ed(e, ["y", "cy", "y1"]) || 0,
            width: 0,
            height: 0,
          }
        : n
    );
  },
  Ld = function (e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && Ad(e));
  },
  Ta = function (e, n) {
    if (n) {
      var i = e.style;
      n in Si && n !== Ei && (n = en),
        i.removeProperty
          ? ((n.substr(0, 2) === "ms" || n.substr(0, 6) === "webkit") &&
              (n = "-" + n),
            i.removeProperty(n.replace(vd, "-$1").toLowerCase()))
          : i.removeAttribute(n);
    }
  },
  Ai = function (e, n, i, r, s, o) {
    var a = new qe(e._pt, n, i, 0, 1, o ? Md : wd);
    return (e._pt = a), (a.b = r), (a.e = s), e._props.push(i), a;
  },
  Pd = { deg: 1, rad: 1, turn: 1 },
  tr = function t(e, n, i, r) {
    var s = parseFloat(i) || 0,
      o = (i + "").trim().substr((s + "").length) || "px",
      a = Qi.style,
      c = wy.test(n),
      l = e.tagName.toLowerCase() === "svg",
      u = (l ? "client" : "offset") + (c ? "Width" : "Height"),
      h = 100,
      d = r === "px",
      f = r === "%",
      p,
      _,
      y,
      m;
    return r === o || !s || Pd[r] || Pd[o]
      ? s
      : (o !== "px" && !d && (s = t(e, n, i, "px")),
        (m = e.getCTM && Ld(e)),
        f && (Si[n] || ~n.indexOf("adius"))
          ? Bt((s / (m ? e.getBBox()[c ? "width" : "height"] : e[u])) * h)
          : ((a[c ? "width" : "height"] = h + (d ? o : r)),
            (_ =
              ~n.indexOf("adius") || (r === "em" && e.appendChild && !l)
                ? e
                : e.parentNode),
            m && (_ = (e.ownerSVGElement || {}).parentNode),
            (!_ || _ === zn || !_.appendChild) && (_ = zn.body),
            (y = _._gsap),
            y && f && y.width && c && y.time === dn.time
              ? Bt((s / y.width) * h)
              : ((f || o === "%") && (a.position = ei(e, "position")),
                _ === e && (a.position = "static"),
                _.appendChild(Qi),
                (p = Qi[u]),
                _.removeChild(Qi),
                (a.position = "absolute"),
                c && f && ((y = Zi(_)), (y.time = dn.time), (y.width = _[u])),
                Bt(d ? (p * s) / h : p && s ? (h / p) * s : 0))));
  },
  no = function (e, n, i, r) {
    var s;
    return (
      iu || su(),
      n in Ti &&
        n !== "transform" &&
        ((n = Ti[n]), ~n.indexOf(",") && (n = n.split(",")[0])),
      Si[n] && n !== "transform"
        ? ((s = Aa(e, r)),
          (s =
            n !== "transformOrigin"
              ? s[n]
              : La(ei(e, Ei)) + " " + s.zOrigin + "px"))
        : ((s = e.style[n]),
          (!s || s === "auto" || r || ~(s + "").indexOf("calc(")) &&
            (s =
              (Ea[n] && Ea[n](e, n, i)) ||
              ei(e, n) ||
              Uf(e, n) ||
              (n === "opacity" ? 1 : 0))),
      i && !~(s + "").indexOf(" ") ? tr(e, n, s, i) + i : s
    );
  },
  Dy = function (e, n, i, r) {
    if (!i || i === "none") {
      var s = zr(n, e, 1),
        o = s && ei(e, s, 1);
      o && o !== i
        ? ((n = s), (i = o))
        : n === "borderColor" && (i = ei(e, "borderTopColor"));
    }
    var a = new qe(this._pt, e.style, n, 0, 1, md),
      c = 0,
      l = 0,
      u,
      h,
      d,
      f,
      p,
      _,
      y,
      m,
      g,
      b,
      x,
      v,
      w;
    if (
      ((a.b = i),
      (a.e = r),
      (i += ""),
      (r += ""),
      r === "auto" && ((e.style[n] = r), (r = ei(e, n) || r), (e.style[n] = i)),
      (u = [i, r]),
      od(u),
      (i = u[0]),
      (r = u[1]),
      (d = i.match(Ar) || []),
      (w = r.match(Ar) || []),
      w.length)
    ) {
      for (; (h = Ar.exec(r)); )
        (y = h[0]),
          (g = r.substring(c, h.index)),
          p
            ? (p = (p + 1) % 5)
            : (g.substr(-5) === "rgba(" || g.substr(-5) === "hsla(") && (p = 1),
          y !== (_ = d[l++] || "") &&
            ((f = parseFloat(_) || 0),
            (x = _.substr((f + "").length)),
            (v = y.charAt(1) === "=" ? +(y.charAt(0) + "1") : 0),
            v && (y = y.substr(2)),
            (m = parseFloat(y)),
            (b = y.substr((m + "").length)),
            (c = Ar.lastIndex - b.length),
            b ||
              ((b = b || un.units[n] || x),
              c === r.length && ((r += b), (a.e += b))),
            x !== b && (f = tr(e, n, _, b) || 0),
            (a._pt = {
              _next: a._pt,
              p: g || l === 1 ? g : ",",
              s: f,
              c: v ? v * m : m - f,
              m: p && p < 4 ? Math.round : 0,
            }));
      a.c = c < r.length ? r.substring(c, r.length) : "";
    } else a.r = n === "display" && r === "none" ? Md : wd;
    return Cf.test(r) && (a.e = 0), (this._pt = a), a;
  },
  Cd = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" },
  Iy = function (e) {
    var n = e.split(" "),
      i = n[0],
      r = n[1] || "50%";
    return (
      (i === "top" || i === "bottom" || r === "left" || r === "right") &&
        ((e = i), (i = r), (r = e)),
      (n[0] = Cd[i] || i),
      (n[1] = Cd[r] || r),
      n.join(" ")
    );
  },
  Ny = function (e, n) {
    if (n.tween && n.tween._time === n.tween._dur) {
      var i = n.t,
        r = i.style,
        s = n.u,
        o = i._gsap,
        a,
        c,
        l;
      if (s === "all" || s === !0) (r.cssText = ""), (c = 1);
      else
        for (s = s.split(","), l = s.length; --l > -1; )
          (a = s[l]),
            Si[a] && ((c = 1), (a = a === "transformOrigin" ? Ei : en)),
            Ta(i, a);
      c &&
        (Ta(i, en),
        o &&
          (o.svg && i.removeAttribute("transform"), Aa(i, 1), (o.uncache = 1)));
    }
  },
  Ea = {
    clearProps: function (e, n, i, r, s) {
      if (s.data !== "isFromStart") {
        var o = (e._pt = new qe(e._pt, n, i, 0, 0, Ny));
        return (o.u = r), (o.pr = -10), (o.tween = s), e._props.push(i), 1;
      }
    },
  },
  io = [1, 0, 0, 1, 0, 0],
  Rd = {},
  Od = function (e) {
    return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e;
  },
  Dd = function (e) {
    var n = ei(e, en);
    return Od(n) ? io : n.substr(7).match(Pf).map(Bt);
  },
  au = function (e, n) {
    var i = e._gsap || Zi(e),
      r = e.style,
      s = Dd(e),
      o,
      a,
      c,
      l;
    return i.svg && e.getAttribute("transform")
      ? ((c = e.transform.baseVal.consolidate().matrix),
        (s = [c.a, c.b, c.c, c.d, c.e, c.f]),
        s.join(",") === "1,0,0,1,0,0" ? io : s)
      : (s === io &&
          !e.offsetParent &&
          e !== Nr &&
          !i.svg &&
          ((c = r.display),
          (r.display = "block"),
          (o = e.parentNode),
          (!o || !e.offsetParent) &&
            ((l = 1), (a = e.nextSibling), Nr.appendChild(e)),
          (s = Dd(e)),
          c ? (r.display = c) : Ta(e, "display"),
          l &&
            (a
              ? o.insertBefore(e, a)
              : o
              ? o.appendChild(e)
              : Nr.removeChild(e))),
        n && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s);
  },
  cu = function (e, n, i, r, s, o) {
    var a = e._gsap,
      c = s || au(e, !0),
      l = a.xOrigin || 0,
      u = a.yOrigin || 0,
      h = a.xOffset || 0,
      d = a.yOffset || 0,
      f = c[0],
      p = c[1],
      _ = c[2],
      y = c[3],
      m = c[4],
      g = c[5],
      b = n.split(" "),
      x = parseFloat(b[0]) || 0,
      v = parseFloat(b[1]) || 0,
      w,
      M,
      C,
      A;
    i
      ? c !== io &&
        (M = f * y - p * _) &&
        ((C = x * (y / M) + v * (-_ / M) + (_ * g - y * m) / M),
        (A = x * (-p / M) + v * (f / M) - (f * g - p * m) / M),
        (x = C),
        (v = A))
      : ((w = Ad(e)),
        (x = w.x + (~b[0].indexOf("%") ? (x / 100) * w.width : x)),
        (v = w.y + (~(b[1] || b[0]).indexOf("%") ? (v / 100) * w.height : v))),
      r || (r !== !1 && a.smooth)
        ? ((m = x - l),
          (g = v - u),
          (a.xOffset = h + (m * f + g * _) - m),
          (a.yOffset = d + (m * p + g * y) - g))
        : (a.xOffset = a.yOffset = 0),
      (a.xOrigin = x),
      (a.yOrigin = v),
      (a.smooth = !!r),
      (a.origin = n),
      (a.originIsAbsolute = !!i),
      (e.style[Ei] = "0px 0px"),
      o &&
        (Ai(o, a, "xOrigin", l, x),
        Ai(o, a, "yOrigin", u, v),
        Ai(o, a, "xOffset", h, a.xOffset),
        Ai(o, a, "yOffset", d, a.yOffset)),
      e.setAttribute("data-svg-origin", x + " " + v);
  },
  Aa = function (e, n) {
    var i = e._gsap || new ud(e);
    if ("x" in i && !n && !i.uncache) return i;
    var r = e.style,
      s = i.scaleX < 0,
      o = "px",
      a = "deg",
      c = ei(e, Ei) || "0",
      l,
      u,
      h,
      d,
      f,
      p,
      _,
      y,
      m,
      g,
      b,
      x,
      v,
      w,
      M,
      C,
      A,
      U,
      I,
      B,
      F,
      O,
      R,
      P,
      V,
      Y,
      K,
      it,
      et,
      Ct,
      mt,
      Nt;
    return (
      (l = u = h = p = _ = y = m = g = b = 0),
      (d = f = 1),
      (i.svg = !!(e.getCTM && Ld(e))),
      (w = au(e, i.svg)),
      i.svg &&
        ((P = !i.uncache && e.getAttribute("data-svg-origin")),
        cu(e, P || c, !!P || i.originIsAbsolute, i.smooth !== !1, w)),
      (x = i.xOrigin || 0),
      (v = i.yOrigin || 0),
      w !== io &&
        ((U = w[0]),
        (I = w[1]),
        (B = w[2]),
        (F = w[3]),
        (l = O = w[4]),
        (u = R = w[5]),
        w.length === 6
          ? ((d = Math.sqrt(U * U + I * I)),
            (f = Math.sqrt(F * F + B * B)),
            (p = U || I ? Br(I, U) * Ki : 0),
            (m = B || F ? Br(B, F) * Ki + p : 0),
            m && (f *= Math.cos(m * Fr)),
            i.svg && ((l -= x - (x * U + v * B)), (u -= v - (x * I + v * F))))
          : ((Nt = w[6]),
            (Ct = w[7]),
            (K = w[8]),
            (it = w[9]),
            (et = w[10]),
            (mt = w[11]),
            (l = w[12]),
            (u = w[13]),
            (h = w[14]),
            (M = Br(Nt, et)),
            (_ = M * Ki),
            M &&
              ((C = Math.cos(-M)),
              (A = Math.sin(-M)),
              (P = O * C + K * A),
              (V = R * C + it * A),
              (Y = Nt * C + et * A),
              (K = O * -A + K * C),
              (it = R * -A + it * C),
              (et = Nt * -A + et * C),
              (mt = Ct * -A + mt * C),
              (O = P),
              (R = V),
              (Nt = Y)),
            (M = Br(-B, et)),
            (y = M * Ki),
            M &&
              ((C = Math.cos(-M)),
              (A = Math.sin(-M)),
              (P = U * C - K * A),
              (V = I * C - it * A),
              (Y = B * C - et * A),
              (mt = F * A + mt * C),
              (U = P),
              (I = V),
              (B = Y)),
            (M = Br(I, U)),
            (p = M * Ki),
            M &&
              ((C = Math.cos(M)),
              (A = Math.sin(M)),
              (P = U * C + I * A),
              (V = O * C + R * A),
              (I = I * C - U * A),
              (R = R * C - O * A),
              (U = P),
              (O = V)),
            _ &&
              Math.abs(_) + Math.abs(p) > 359.9 &&
              ((_ = p = 0), (y = 180 - y)),
            (d = Bt(Math.sqrt(U * U + I * I + B * B))),
            (f = Bt(Math.sqrt(R * R + Nt * Nt))),
            (M = Br(O, R)),
            (m = Math.abs(M) > 2e-4 ? M * Ki : 0),
            (b = mt ? 1 / (mt < 0 ? -mt : mt) : 0)),
        i.svg &&
          ((P = e.getAttribute("transform")),
          (i.forceCSS = e.setAttribute("transform", "") || !Od(ei(e, en))),
          P && e.setAttribute("transform", P))),
      Math.abs(m) > 90 &&
        Math.abs(m) < 270 &&
        (s
          ? ((d *= -1), (m += p <= 0 ? 180 : -180), (p += p <= 0 ? 180 : -180))
          : ((f *= -1), (m += m <= 0 ? 180 : -180))),
      (i.x =
        ((i.xPercent =
          l && Math.round(e.offsetWidth / 2) === Math.round(-l) ? -50 : 0)
          ? 0
          : l) + o),
      (i.y =
        ((i.yPercent =
          u && Math.round(e.offsetHeight / 2) === Math.round(-u) ? -50 : 0)
          ? 0
          : u) + o),
      (i.z = h + o),
      (i.scaleX = Bt(d)),
      (i.scaleY = Bt(f)),
      (i.rotation = Bt(p) + a),
      (i.rotationX = Bt(_) + a),
      (i.rotationY = Bt(y) + a),
      (i.skewX = m + a),
      (i.skewY = g + a),
      (i.transformPerspective = b + o),
      (i.zOrigin = parseFloat(c.split(" ")[2]) || 0) && (r[Ei] = La(c)),
      (i.xOffset = i.yOffset = 0),
      (i.force3D = un.force3D),
      (i.renderTransform = i.svg ? By : Sd ? Id : Fy),
      (i.uncache = 0),
      i
    );
  },
  La = function (e) {
    return (e = e.split(" "))[0] + " " + e[1];
  },
  lu = function (e, n, i) {
    var r = Nn(n);
    return Bt(parseFloat(n) + parseFloat(tr(e, "x", i + "px", r))) + r;
  },
  Fy = function (e, n) {
    (n.z = "0px"),
      (n.rotationY = n.rotationX = "0deg"),
      (n.force3D = 0),
      Id(e, n);
  },
  er = "0deg",
  ro = "0px",
  nr = ") ",
  Id = function (e, n) {
    var i = n || this,
      r = i.xPercent,
      s = i.yPercent,
      o = i.x,
      a = i.y,
      c = i.z,
      l = i.rotation,
      u = i.rotationY,
      h = i.rotationX,
      d = i.skewX,
      f = i.skewY,
      p = i.scaleX,
      _ = i.scaleY,
      y = i.transformPerspective,
      m = i.force3D,
      g = i.target,
      b = i.zOrigin,
      x = "",
      v = (m === "auto" && e && e !== 1) || m === !0;
    if (b && (h !== er || u !== er)) {
      var w = parseFloat(u) * Fr,
        M = Math.sin(w),
        C = Math.cos(w),
        A;
      (w = parseFloat(h) * Fr),
        (A = Math.cos(w)),
        (o = lu(g, o, M * A * -b)),
        (a = lu(g, a, -Math.sin(w) * -b)),
        (c = lu(g, c, C * A * -b + b));
    }
    y !== ro && (x += "perspective(" + y + nr),
      (r || s) && (x += "translate(" + r + "%, " + s + "%) "),
      (v || o !== ro || a !== ro || c !== ro) &&
        (x +=
          c !== ro || v
            ? "translate3d(" + o + ", " + a + ", " + c + ") "
            : "translate(" + o + ", " + a + nr),
      l !== er && (x += "rotate(" + l + nr),
      u !== er && (x += "rotateY(" + u + nr),
      h !== er && (x += "rotateX(" + h + nr),
      (d !== er || f !== er) && (x += "skew(" + d + ", " + f + nr),
      (p !== 1 || _ !== 1) && (x += "scale(" + p + ", " + _ + nr),
      (g.style[en] = x || "translate(0, 0)");
  },
  By = function (e, n) {
    var i = n || this,
      r = i.xPercent,
      s = i.yPercent,
      o = i.x,
      a = i.y,
      c = i.rotation,
      l = i.skewX,
      u = i.skewY,
      h = i.scaleX,
      d = i.scaleY,
      f = i.target,
      p = i.xOrigin,
      _ = i.yOrigin,
      y = i.xOffset,
      m = i.yOffset,
      g = i.forceCSS,
      b = parseFloat(o),
      x = parseFloat(a),
      v,
      w,
      M,
      C,
      A;
    (c = parseFloat(c)),
      (l = parseFloat(l)),
      (u = parseFloat(u)),
      u && ((u = parseFloat(u)), (l += u), (c += u)),
      c || l
        ? ((c *= Fr),
          (l *= Fr),
          (v = Math.cos(c) * h),
          (w = Math.sin(c) * h),
          (M = Math.sin(c - l) * -d),
          (C = Math.cos(c - l) * d),
          l &&
            ((u *= Fr),
            (A = Math.tan(l - u)),
            (A = Math.sqrt(1 + A * A)),
            (M *= A),
            (C *= A),
            u &&
              ((A = Math.tan(u)),
              (A = Math.sqrt(1 + A * A)),
              (v *= A),
              (w *= A))),
          (v = Bt(v)),
          (w = Bt(w)),
          (M = Bt(M)),
          (C = Bt(C)))
        : ((v = h), (C = d), (w = M = 0)),
      ((b && !~(o + "").indexOf("px")) || (x && !~(a + "").indexOf("px"))) &&
        ((b = tr(f, "x", o, "px")), (x = tr(f, "y", a, "px"))),
      (p || _ || y || m) &&
        ((b = Bt(b + p - (p * v + _ * M) + y)),
        (x = Bt(x + _ - (p * w + _ * C) + m))),
      (r || s) &&
        ((A = f.getBBox()),
        (b = Bt(b + (r / 100) * A.width)),
        (x = Bt(x + (s / 100) * A.height))),
      (A =
        "matrix(" + v + "," + w + "," + M + "," + C + "," + b + "," + x + ")"),
      f.setAttribute("transform", A),
      g && (f.style[en] = A);
  },
  zy = function (e, n, i, r, s, o) {
    var a = 360,
      c = Oe(s),
      l = parseFloat(s) * (c && ~s.indexOf("rad") ? Ki : 1),
      u = o ? l * o : l - r,
      h = r + u + "deg",
      d,
      f;
    return (
      c &&
        ((d = s.split("_")[1]),
        d === "short" && ((u %= a), u !== u % (a / 2) && (u += u < 0 ? a : -a)),
        d === "cw" && u < 0
          ? (u = ((u + a * xd) % a) - ~~(u / a) * a)
          : d === "ccw" && u > 0 && (u = ((u - a * xd) % a) - ~~(u / a) * a)),
      (e._pt = f = new qe(e._pt, n, i, r, u, Sy)),
      (f.e = h),
      (f.u = "deg"),
      e._props.push(i),
      f
    );
  },
  Uy = function (e, n, i) {
    var r = eo.style,
      s = i._gsap,
      o = "perspective,force3D,transformOrigin,svgOrigin",
      a,
      c,
      l,
      u,
      h,
      d,
      f,
      p;
    (r.cssText =
      getComputedStyle(i).cssText + ";position:absolute;display:block;"),
      (r[en] = n),
      zn.body.appendChild(eo),
      (a = Aa(eo, 1));
    for (c in Si)
      (l = s[c]),
        (u = a[c]),
        l !== u &&
          o.indexOf(c) < 0 &&
          ((f = Nn(l)),
          (p = Nn(u)),
          (h = f !== p ? tr(i, c, l, p) : parseFloat(l)),
          (d = parseFloat(u)),
          (e._pt = new qe(e._pt, s, c, h, d - h, bd)),
          (e._pt.u = p || 0),
          e._props.push(c));
    zn.body.removeChild(eo);
  };
Ke("padding,margin,Width,Radius", function (t, e) {
  var n = "Top",
    i = "Right",
    r = "Bottom",
    s = "Left",
    o = (e < 3 ? [n, i, r, s] : [n + s, n + i, r + i, r + s]).map(function (a) {
      return e < 2 ? t + a : "border" + a + t;
    });
  Ea[e > 1 ? "border" + t : t] = function (a, c, l, u, h) {
    var d, f;
    if (arguments.length < 4)
      return (
        (d = o.map(function (p) {
          return no(a, p, l);
        })),
        (f = d.join(" ")),
        f.split(d[0]).length === 5 ? d[0] : f
      );
    (d = (u + "").split(" ")),
      (f = {}),
      o.forEach(function (p, _) {
        return (f[p] = d[_] = d[_] || d[((_ - 1) / 2) | 0]);
      }),
      a.init(c, f, h);
  };
});
var Nd = {
  name: "css",
  register: su,
  targetTest: function (e) {
    return e.style && e.nodeType;
  },
  init: function (e, n, i, r, s) {
    var o = this._props,
      a = e.style,
      c,
      l,
      u,
      h,
      d,
      f,
      p,
      _,
      y,
      m,
      g,
      b,
      x,
      v,
      w;
    iu || su();
    for (p in n)
      if (p !== "autoRound" && ((l = n[p]), !(Qe[p] && hd(p, n, i, r, e, s)))) {
        if (
          ((d = typeof l),
          (f = Ea[p]),
          d === "function" && ((l = l.call(i, r, e, s)), (d = typeof l)),
          d === "string" && ~l.indexOf("random(") && (l = wa(l)),
          f)
        )
          f(this, e, p, l, i) && (w = 1);
        else if (p.substr(0, 2) === "--")
          this.add(
            a,
            "setProperty",
            getComputedStyle(e).getPropertyValue(p) + "",
            l + "",
            r,
            s,
            0,
            0,
            p
          );
        else if (d !== "undefined") {
          if (
            ((c = no(e, p)),
            (h = parseFloat(c)),
            (m =
              d === "string" && l.charAt(1) === "=" ? +(l.charAt(0) + "1") : 0),
            m && (l = l.substr(2)),
            (u = parseFloat(l)),
            p in Ti &&
              (p === "autoAlpha" &&
                (h === 1 && no(e, "visibility") === "hidden" && u && (h = 0),
                Ai(
                  this,
                  a,
                  "visibility",
                  h ? "inherit" : "hidden",
                  u ? "inherit" : "hidden",
                  !u
                )),
              p !== "scale" &&
                p !== "transform" &&
                ((p = Ti[p]), ~p.indexOf(",") && (p = p.split(",")[0]))),
            (g = p in Si),
            g)
          ) {
            if (
              (b ||
                ((x = e._gsap),
                x.renderTransform || Aa(e),
                (v = n.smoothOrigin !== !1 && x.smooth),
                (b = this._pt =
                  new qe(this._pt, a, en, 0, 1, x.renderTransform, x, 0, -1)),
                (b.dep = 1)),
              p === "scale")
            )
              (this._pt = new qe(
                this._pt,
                x,
                "scaleY",
                x.scaleY,
                m ? m * u : u - x.scaleY
              )),
                o.push("scaleY", p),
                (p += "X");
            else if (p === "transformOrigin") {
              (l = Iy(l)),
                x.svg
                  ? cu(e, l, 0, v, 0, this)
                  : ((y = parseFloat(l.split(" ")[2]) || 0),
                    y !== x.zOrigin && Ai(this, x, "zOrigin", x.zOrigin, y),
                    Ai(this, a, p, La(c), La(l)));
              continue;
            } else if (p === "svgOrigin") {
              cu(e, l, 1, v, 0, this);
              continue;
            } else if (p in Rd) {
              zy(this, x, p, h, l, m);
              continue;
            } else if (p === "smoothOrigin") {
              Ai(this, x, "smooth", x.smooth, l);
              continue;
            } else if (p === "force3D") {
              x[p] = l;
              continue;
            } else if (p === "transform") {
              Uy(this, l, e);
              continue;
            }
          } else p in a || (p = zr(p) || p);
          if (g || ((u || u === 0) && (h || h === 0) && !My.test(l) && p in a))
            (_ = (c + "").substr((h + "").length)),
              u || (u = 0),
              (y = Nn(l) || (p in un.units ? un.units[p] : _)),
              _ !== y && (h = tr(e, p, c, y)),
              (this._pt = new qe(
                this._pt,
                g ? x : a,
                p,
                h,
                m ? m * u : u - h,
                y === "px" && n.autoRound !== !1 && !g ? Ey : bd
              )),
              (this._pt.u = y || 0),
              _ !== y && ((this._pt.b = c), (this._pt.r = Ty));
          else if (p in a) Dy.call(this, e, p, c, l);
          else if (p in e) this.add(e, p, e[p], l, r, s);
          else {
            zl(p, l);
            continue;
          }
          o.push(p);
        }
      }
    w && gd(this);
  },
  get: no,
  aliases: Ti,
  getSetter: function (e, n, i) {
    var r = Ti[n];
    return (
      r && r.indexOf(",") < 0 && (n = r),
      n in Si && n !== Ei && (e._gsap.x || no(e, "x"))
        ? i && _d === i
          ? n === "scale"
            ? Cy
            : Py
          : (_d = i || {}) && (n === "scale" ? Ry : Oy)
        : e.style && !Il(e.style[n])
        ? Ay
        : ~n.indexOf("-")
        ? Ly
        : tu(e, n)
    );
  },
  core: { _removeProperty: Ta, _getMatrix: au },
};
Bn.utils.checkPrefix = zr;
(function (t, e, n, i) {
  var r = Ke(t + "," + e + "," + n, function (s) {
    Si[s] = 1;
  });
  Ke(e, function (s) {
    (un.units[s] = "deg"), (Rd[s] = 1);
  }),
    (Ti[r[13]] = t + "," + e),
    Ke(i, function (s) {
      var o = s.split(":");
      Ti[o[1]] = r[o[0]];
    });
})(
  "x,y,z,scale,scaleX,scaleY,xPercent,yPercent",
  "rotation,rotationX,rotationY,skewX,skewY",
  "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
  "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"
);
Ke(
  "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
  function (t) {
    un.units[t] = "px";
  }
);
Bn.registerPlugin(Nd);
var ky = Bn.registerPlugin(Nd) || Bn;
ky.core.Tween;
function ze() {
  if (!(this instanceof ze)) return new ze();
  (this.size = 0),
    (this.uid = 0),
    (this.selectors = []),
    (this.selectorObjects = {}),
    (this.indexes = Object.create(this.indexes)),
    (this.activeIndexes = []);
}
var so = window.document.documentElement,
  Gy =
    so.matches ||
    so.webkitMatchesSelector ||
    so.mozMatchesSelector ||
    so.oMatchesSelector ||
    so.msMatchesSelector;
ze.prototype.matchesSelector = function (t, e) {
  return Gy.call(t, e);
};
ze.prototype.querySelectorAll = function (t, e) {
  return e.querySelectorAll(t);
};
ze.prototype.indexes = [];
var Hy = /^#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
ze.prototype.indexes.push({
  name: "ID",
  selector: function (e) {
    var n;
    if ((n = e.match(Hy))) return n[0].slice(1);
  },
  element: function (e) {
    if (e.id) return [e.id];
  },
});
var Vy = /^\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
ze.prototype.indexes.push({
  name: "CLASS",
  selector: function (e) {
    var n;
    if ((n = e.match(Vy))) return n[0].slice(1);
  },
  element: function (e) {
    var n = e.className;
    if (n) {
      if (typeof n == "string") return n.split(/\s/);
      if (typeof n == "object" && "baseVal" in n) return n.baseVal.split(/\s/);
    }
  },
});
var Wy = /^((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
ze.prototype.indexes.push({
  name: "TAG",
  selector: function (e) {
    var n;
    if ((n = e.match(Wy))) return n[0].toUpperCase();
  },
  element: function (e) {
    return [e.nodeName.toUpperCase()];
  },
});
ze.prototype.indexes.default = {
  name: "UNIVERSAL",
  selector: function () {
    return !0;
  },
  element: function () {
    return [!0];
  },
};
var uu;
typeof window.Map == "function"
  ? (uu = window.Map)
  : (uu = (function () {
      function t() {
        this.map = {};
      }
      return (
        (t.prototype.get = function (e) {
          return this.map[e + " "];
        }),
        (t.prototype.set = function (e, n) {
          this.map[e + " "] = n;
        }),
        t
      );
    })());
var Fd =
  /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g;
function Bd(t, e) {
  t = t.slice(0).concat(t.default);
  var n = t.length,
    i,
    r,
    s,
    o,
    a = e,
    c,
    l,
    u = [];
  do
    if ((Fd.exec(""), (s = Fd.exec(a)) && ((a = s[3]), s[2] || !a))) {
      for (i = 0; i < n; i++)
        if (((l = t[i]), (c = l.selector(s[1])))) {
          for (r = u.length, o = !1; r--; )
            if (u[r].index === l && u[r].key === c) {
              o = !0;
              break;
            }
          o || u.push({ index: l, key: c });
          break;
        }
    }
  while (s);
  return u;
}
function jy(t, e) {
  var n, i, r;
  for (n = 0, i = t.length; n < i; n++)
    if (((r = t[n]), e.isPrototypeOf(r))) return r;
}
ze.prototype.logDefaultIndexUsed = function () {};
ze.prototype.add = function (t, e) {
  var n,
    i,
    r,
    s,
    o,
    a,
    c,
    l,
    u = this.activeIndexes,
    h = this.selectors,
    d = this.selectorObjects;
  if (typeof t == "string") {
    for (
      n = { id: this.uid++, selector: t, data: e },
        d[n.id] = n,
        c = Bd(this.indexes, t),
        i = 0;
      i < c.length;
      i++
    )
      (l = c[i]),
        (s = l.key),
        (r = l.index),
        (o = jy(u, r)),
        o || ((o = Object.create(r)), (o.map = new uu()), u.push(o)),
        r === this.indexes.default && this.logDefaultIndexUsed(n),
        (a = o.map.get(s)),
        a || ((a = []), o.map.set(s, a)),
        a.push(n);
    this.size++, h.push(t);
  }
};
ze.prototype.remove = function (t, e) {
  if (typeof t == "string") {
    var n,
      i,
      r,
      s,
      o,
      a,
      c,
      l,
      u = this.activeIndexes,
      h = (this.selectors = []),
      d = this.selectorObjects,
      f = {},
      p = arguments.length === 1;
    for (n = Bd(this.indexes, t), r = 0; r < n.length; r++)
      for (i = n[r], s = u.length; s--; )
        if (((a = u[s]), i.index.isPrototypeOf(a))) {
          if (((c = a.map.get(i.key)), c))
            for (o = c.length; o--; )
              (l = c[o]),
                l.selector === t &&
                  (p || l.data === e) &&
                  (c.splice(o, 1), (f[l.id] = !0));
          break;
        }
    for (r in f) delete d[r], this.size--;
    for (r in d) h.push(d[r].selector);
  }
};
function zd(t, e) {
  return t.id - e.id;
}
ze.prototype.queryAll = function (t) {
  if (!this.selectors.length) return [];
  var e = {},
    n = [],
    i = this.querySelectorAll(this.selectors.join(", "), t),
    r,
    s,
    o,
    a,
    c,
    l,
    u,
    h;
  for (r = 0, o = i.length; r < o; r++)
    for (c = i[r], l = this.matches(c), s = 0, a = l.length; s < a; s++)
      (h = l[s]),
        e[h.id]
          ? (u = e[h.id])
          : ((u = {
              id: h.id,
              selector: h.selector,
              data: h.data,
              elements: [],
            }),
            (e[h.id] = u),
            n.push(u)),
        u.elements.push(c);
  return n.sort(zd);
};
ze.prototype.matches = function (t) {
  if (!t) return [];
  var e,
    n,
    i,
    r,
    s,
    o,
    a,
    c,
    l,
    u,
    h,
    d = this.activeIndexes,
    f = {},
    p = [];
  for (e = 0, r = d.length; e < r; e++)
    if (((a = d[e]), (c = a.element(t)), c)) {
      for (n = 0, s = c.length; n < s; n++)
        if ((l = a.map.get(c[n])))
          for (i = 0, o = l.length; i < o; i++)
            (u = l[i]),
              (h = u.id),
              !f[h] &&
                this.matchesSelector(t, u.selector) &&
                ((f[h] = !0), p.push(u));
    }
  return p.sort(zd);
};
const Ur = {},
  wn = {},
  Ud = ["mouseenter", "mouseleave"];
function kd(t) {
  wn[t] === void 0 && (wn[t] = []);
}
function qy(t, e) {
  if (wn[t]) for (let n = 0; n < wn[t].length; n++) wn[t][n](...e);
}
function Gd(t) {
  return typeof t == "string" ? document.querySelectorAll(t) : t;
}
function hu(t) {
  let e = Xy(Ur[t.type], t.target);
  if (e.length)
    for (let n = 0; n < e.length; n++)
      for (let i = 0; i < e[n].stack.length; i++)
        Ud.indexOf(t.type) !== -1
          ? (Hd(t, e[n].delegatedTarget),
            t.target === e[n].delegatedTarget && e[n].stack[i].data(t))
          : (Hd(t, e[n].delegatedTarget), e[n].stack[i].data(t));
}
function Xy(t, e) {
  const n = [];
  let i = e;
  do {
    if (i.nodeType !== 1) break;
    const r = t.matches(i);
    r.length && n.push({ delegatedTarget: i, stack: r });
  } while ((i = i.parentElement));
  return n;
}
function Hd(t, e) {
  Object.defineProperty(t, "currentTarget", {
    configurable: !0,
    enumerable: !0,
    value: e,
  });
}
function Vd(t) {
  return JSON.parse(JSON.stringify(t));
}
class _1 {
  bindAll(e, n) {
    n === void 0 && (n = Object.getOwnPropertyNames(Object.getPrototypeOf(e)));
    for (let i = 0; i < n.length; i++) e[n[i]] = e[n[i]].bind(e);
  }
  on(e, n, i, r) {
    if (typeof n == "function" && i === void 0) {
      kd(e), wn[e].push(n);
      return;
    }
    const s = e.split(" ");
    for (let o = 0; o < s.length; o++) {
      if ((n.nodeType && n.nodeType === 1) || n === window || n === document) {
        n.addEventListener(s[o], i, r);
        continue;
      }
      n = Gd(n);
      for (let a = 0; a < n.length; a++) n[a].addEventListener(s[o], i, r);
    }
  }
  delegate(e, n, i) {
    const r = e.split(" ");
    for (let s = 0; s < r.length; s++) {
      let o = Ur[r[s]];
      o === void 0 &&
        ((o = new ze()),
        (Ur[r[s]] = o),
        Ud.indexOf(r[s]) !== -1
          ? document.addEventListener(r[s], hu, !0)
          : document.addEventListener(r[s], hu)),
        o.add(n, i);
    }
  }
  off(e, n, i) {
    if (n === void 0) {
      wn[e] = [];
      return;
    }
    if (typeof n == "function") {
      kd(e);
      for (let s = 0; s < wn[e].length; s++)
        wn[e][s] === n && wn[e].splice(s, 1);
      return;
    }
    const r = e.split(" ");
    for (let s = 0; s < r.length; s++) {
      const o = Ur[r[s]];
      if (o !== void 0 && (o.remove(n, i), o.size === 0)) {
        delete Ur[r[s]], document.removeEventListener(r[s], hu);
        continue;
      }
      if (n.removeEventListener !== void 0) {
        n.removeEventListener(r[s], i);
        continue;
      }
      n = Gd(n);
      for (let a = 0; a < n.length; a++) n[a].removeEventListener(r[s], i);
    }
  }
  emit(e, ...n) {
    qy(e, n);
  }
  debugDelegated() {
    return Vd(Ur);
  }
  debugBus() {
    return Vd(wn);
  }
}
var oo =
  typeof globalThis != "undefined"
    ? globalThis
    : typeof window != "undefined"
    ? window
    : typeof global != "undefined"
    ? global
    : typeof self != "undefined"
    ? self
    : {};
/*!
 * dashify <https://github.com/jonschlinkert/dashify>
 *
 * Copyright (c) 2015 Jon Schlinkert.
 * Licensed under the MIT license.
 */ var Yy = function (e) {
    if (typeof e != "string") throw new TypeError("expected a string");
    return (
      (e = e.replace(/([a-z])([A-Z])/g, "$1-$2")),
      (e = e.replace(/[ \t\W]/g, "-")),
      (e = e.replace(/^-+|-+$/g, "")),
      e.toLowerCase()
    );
  },
  Zy = Yy,
  x1 = new fu();
function fu() {
  var t = navigator.userAgent.toLowerCase(),
    e = navigator.appVersion.toLowerCase(),
    n = /windows phone|iemobile|wpdesktop/.test(t),
    i = !n && /android.*mobile/.test(t),
    r = !n && !i && /android/i.test(t),
    s = i || r,
    o = !n && /ip(hone|od|ad)/i.test(t) && !window.MSStream,
    a = !n && /ipad/i.test(t) && o,
    c = r || a,
    l = i || (o && !a) || n,
    u = l || c,
    h = t.indexOf("firefox") > -1,
    d = !!t.match(/version\/[\d\.]+.*safari/),
    f = t.indexOf("opr") > -1,
    p = !window.ActiveXObject && "ActiveXObject" in window,
    _ = e.indexOf("msie") > -1 || p || e.indexOf("edge") > -1,
    y = t.indexOf("edge") > -1,
    m =
      window.chrome !== null &&
      window.chrome !== void 0 &&
      navigator.vendor.toLowerCase() == "google inc." &&
      !f &&
      !y;
  (this.infos = {
    isDroid: s,
    isDroidPhone: i,
    isDroidTablet: r,
    isWindowsPhone: n,
    isIos: o,
    isIpad: a,
    isDevice: u,
    isEdge: y,
    isIE: _,
    isIE11: p,
    isPhone: l,
    isTablet: c,
    isFirefox: h,
    isSafari: d,
    isOpera: f,
    isChrome: m,
    isDesktop: !l && !c,
  }),
    Object.keys(this.infos).forEach(function (g) {
      Object.defineProperty(this, g, {
        get: function () {
          return this.infos[g];
        },
      });
    }, this),
    Object.freeze(this);
}
fu.prototype.addClasses = function (t) {
  Object.keys(this.infos).forEach(function (e) {
    this.infos[e] && Jy(t, Zy(e));
  }, this);
};
fu.prototype.getInfos = function () {
  return $y(this.infos);
};
function Jy(t, e) {
  t.addClass
    ? t.addClass(e)
    : t.classList
    ? t.classList.add(e)
    : (t.className += " " + e);
}
function $y(t) {
  return JSON.parse(JSON.stringify(t));
}
var v1 = {
  isWebGLAvailable: function () {
    try {
      var t = document.createElement("canvas");
      return !!(
        window.WebGLRenderingContext &&
        (t.getContext("webgl") || t.getContext("experimental-webgl"))
      );
    } catch {
      return !1;
    }
  },
  isWebGL2Available: function () {
    try {
      var t = document.createElement("canvas");
      return !!(window.WebGL2RenderingContext && t.getContext("webgl2"));
    } catch {
      return !1;
    }
  },
  getWebGLErrorMessage: function () {
    return this.getErrorMessage(1);
  },
  getWebGL2ErrorMessage: function () {
    return this.getErrorMessage(2);
  },
  getErrorMessage: function (t) {
    var e = { 1: "WebGL", 2: "WebGL 2" },
      n = { 1: window.WebGLRenderingContext, 2: window.WebGL2RenderingContext },
      i =
        'Your $0 does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">$1</a>',
      r = document.createElement("div");
    return (
      (r.id = "webglmessage"),
      (r.style.fontFamily = "monospace"),
      (r.style.fontSize = "13px"),
      (r.style.fontWeight = "normal"),
      (r.style.textAlign = "center"),
      (r.style.background = "#fff"),
      (r.style.color = "#000"),
      (r.style.padding = "1.5em"),
      (r.style.width = "400px"),
      (r.style.margin = "5em auto 0"),
      n[t]
        ? (i = i.replace("$0", "graphics card"))
        : (i = i.replace("$0", "browser")),
      (i = i.replace("$1", e[t])),
      (r.innerHTML = i),
      r
    );
  },
};
/*!
 * ScrollTrigger 3.5.1
 * https://greensock.com
 *
 * @license Copyright 2008-2020, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var Ft,
  Pa,
  pe,
  Ue,
  ni,
  Se,
  Wd,
  du,
  pu,
  ao,
  Un,
  Ca,
  Ra,
  mu,
  nn,
  Oa,
  gu,
  ce,
  jd,
  qd,
  kr,
  Xd,
  yu,
  co = 1,
  Gr = [],
  Da = [],
  ir = Date.now,
  _u = ir(),
  kn = 0,
  Yd = 1,
  xu = function (e) {
    return e;
  },
  Zd = function () {
    return typeof window != "undefined";
  },
  Jd = function () {
    return Ft || (Zd() && (Ft = window.gsap) && Ft.registerPlugin && Ft);
  },
  Hr = function (e) {
    return !!~Wd.indexOf(e);
  },
  Vr = function (e, n) {
    return ~Gr.indexOf(e) && Gr[Gr.indexOf(e) + 1][n];
  },
  Ia = function (e, n) {
    var i = n.s,
      r = n.sc,
      s = Da.indexOf(e),
      o = r === ke.sc ? 1 : 2;
    return (
      !~s && (s = Da.push(e) - 1),
      Da[s + o] ||
        (Da[s + o] =
          Vr(e, i) ||
          (Hr(e)
            ? r
            : function (a) {
                return arguments.length ? (e[i] = a) : e[i];
              }))
    );
  },
  $d = function (e) {
    return (
      Vr(e, "getBoundingClientRect") ||
      (Hr(e)
        ? function () {
            return (Ja.width = pe.innerWidth), (Ja.height = pe.innerHeight), Ja;
          }
        : function () {
            return or(e);
          })
    );
  },
  Qy = function (e, n, i) {
    var r = i.d,
      s = i.d2,
      o = i.a;
    return (o = Vr(e, "getBoundingClientRect"))
      ? function () {
          return o()[r];
        }
      : function () {
          return (n ? pe["inner" + s] : e["client" + s]) || 0;
        };
  },
  Ky = function (e, n) {
    return !n || ~Gr.indexOf(e)
      ? $d(e)
      : function () {
          return Ja;
        };
  },
  vu = function (e, n) {
    var i = n.s,
      r = n.d2,
      s = n.d,
      o = n.a;
    return (i = "scroll" + r) && (o = Vr(e, i))
      ? o() - $d(e)()[s]
      : Hr(e)
      ? Math.max(ni[i], Se[i]) -
        (pe["inner" + r] || ni["client" + r] || Se["client" + r])
      : e[i] - e["offset" + r];
  },
  bu = function (e, n) {
    for (var i = 0; i < kr.length; i += 3)
      (!n || ~n.indexOf(kr[i + 1])) && e(kr[i], kr[i + 1], kr[i + 2]);
  },
  rr = function (e) {
    return typeof e == "string";
  },
  Li = function (e) {
    return typeof e == "function";
  },
  wu = function (e) {
    return typeof e == "number";
  },
  Mu = function (e) {
    return typeof e == "object";
  },
  Na = function (e) {
    return Li(e) && e();
  },
  Qd = function (e, n) {
    return function () {
      var i = Na(e),
        r = Na(n);
      return function () {
        Na(i), Na(r);
      };
    };
  },
  Fa = Math.abs,
  Ba = "scrollLeft",
  za = "scrollTop",
  Su = "left",
  Tu = "top",
  Ua = "right",
  ka = "bottom",
  Wr = "width",
  jr = "height",
  qr = "Right",
  Xr = "Left",
  Yr = "Top",
  Zr = "Bottom",
  xe = "padding",
  pn = "margin",
  sr = "Width",
  Ga = "Height",
  Xe = "px",
  Mn = {
    s: Ba,
    p: Su,
    p2: Xr,
    os: Ua,
    os2: qr,
    d: Wr,
    d2: sr,
    a: "x",
    sc: function (e) {
      return arguments.length
        ? pe.scrollTo(e, ke.sc())
        : pe.pageXOffset || Ue[Ba] || ni[Ba] || Se[Ba] || 0;
    },
  },
  ke = {
    s: za,
    p: Tu,
    p2: Yr,
    os: ka,
    os2: Zr,
    d: jr,
    d2: Ga,
    a: "y",
    op: Mn,
    sc: function (e) {
      return arguments.length
        ? pe.scrollTo(Mn.sc(), e)
        : pe.pageYOffset || Ue[za] || ni[za] || Se[za] || 0;
    },
  },
  ii = function (e) {
    return pe.getComputedStyle(e);
  },
  t_ = function (e) {
    return (e.style.position =
      ii(e).position === "absolute" ? "absolute" : "relative");
  },
  Kd = function (e, n) {
    for (var i in n) i in e || (e[i] = n[i]);
    return e;
  },
  or = function (e, n) {
    var i =
        n &&
        ii(e)[gu] !== "matrix(1, 0, 0, 1, 0, 0)" &&
        Ft.to(e, {
          x: 0,
          y: 0,
          xPercent: 0,
          yPercent: 0,
          rotation: 0,
          rotationX: 0,
          rotationY: 0,
          scale: 1,
          skewX: 0,
          skewY: 0,
        }).progress(1),
      r = e.getBoundingClientRect();
    return i && i.progress(0).kill(), r;
  },
  Eu = function (e, n) {
    var i = n.d2;
    return e["offset" + i] || e["client" + i] || 0;
  },
  e_ = function (e) {
    return function (n) {
      var i = [],
        r = e.labels,
        s = e.duration(),
        o;
      for (o in r) i.push(r[o] / s);
      return Ft.utils.snap(i, n);
    };
  },
  tp = function (e, n, i, r) {
    return i.split(",").forEach(function (s) {
      return e(n, s, r);
    });
  },
  Ye = function (e, n, i) {
    return e.addEventListener(n, i, { passive: !0 });
  },
  lo = function (e, n, i) {
    return e.removeEventListener(n, i);
  },
  ep = {
    startColor: "green",
    endColor: "red",
    indent: 0,
    fontSize: "16px",
    fontWeight: "normal",
  },
  Au = { toggleActions: "play", anticipatePin: 0 },
  np = { top: 0, left: 0, center: 0.5, bottom: 1, right: 1 },
  Ha = function (e, n) {
    if (rr(e)) {
      var i = e.indexOf("="),
        r = ~i ? +(e.charAt(i - 1) + 1) * parseFloat(e.substr(i + 1)) : 0;
      r && (e.indexOf("%") > i && (r *= n / 100), (e = e.substr(0, i - 1))),
        (e =
          r +
          (e in np
            ? np[e] * n
            : ~e.indexOf("%")
            ? (parseFloat(e) * n) / 100
            : parseFloat(e) || 0));
    }
    return e;
  },
  Va = function (e, n, i, r, s, o, a) {
    var c = s.startColor,
      l = s.endColor,
      u = s.fontSize,
      h = s.indent,
      d = s.fontWeight,
      f = Ue.createElement("div"),
      p = Hr(i) || Vr(i, "pinType") === "fixed",
      _ = e.indexOf("scroller") !== -1,
      y = p ? Se : i,
      m = e.indexOf("start") !== -1,
      g = m ? c : l,
      b =
        "border-color:" +
        g +
        ";font-size:" +
        u +
        ";color:" +
        g +
        ";font-weight:" +
        d +
        ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
    return (
      (b += "position:" + (_ && p ? "fixed;" : "absolute;")),
      (_ || !p) &&
        (b += (r === ke ? Ua : ka) + ":" + (o + parseFloat(h)) + "px;"),
      a &&
        (b +=
          "box-sizing:border-box;text-align:left;width:" +
          a.offsetWidth +
          "px;"),
      (f._isStart = m),
      f.setAttribute("class", "gsap-marker-" + e),
      (f.style.cssText = b),
      (f.innerText = n || n === 0 ? e + "-" + n : e),
      y.insertBefore(f, y.children[0]),
      (f._offset = f["offset" + r.op.d2]),
      Wa(f, 0, r, m),
      f
    );
  },
  Wa = function (e, n, i, r) {
    var s = { display: "block" },
      o = i[r ? "os2" : "p2"],
      a = i[r ? "p2" : "os2"];
    (e._isFlipped = r),
      (s[i.a + "Percent"] = r ? -100 : 0),
      (s[i.a] = r ? 1 : 0),
      (s["border" + o + sr] = 1),
      (s["border" + a + sr] = 0),
      (s[i.p] = n),
      Ft.set(e, s);
  },
  Zt = [],
  Lu = {},
  ip = function () {
    return ao || (ao = pu(Pu));
  },
  ja = function () {
    ao || ((ao = pu(Pu)), kn || $r("scrollStart"), (kn = ir()));
  },
  uo = function () {
    return !nn && du.restart(!0);
  },
  ho = {},
  n_ = [],
  le = [],
  Jr,
  rp,
  sp = function (e) {
    var n = Ft.ticker.frame,
      i = [],
      r = 0,
      s;
    if (rp !== n || co) {
      for (qa(); r < le.length; r += 4)
        (s = pe.matchMedia(le[r]).matches),
          s !== le[r + 3] &&
            ((le[r + 3] = s),
            s ? i.push(r) : qa(1, le[r]) || (Li(le[r + 2]) && le[r + 2]()));
      for (ap(), r = 0; r < i.length; r++)
        (s = i[r]), (Jr = le[s]), (le[s + 2] = le[s + 1](e));
      (Jr = 0), Qr(0, 1), (rp = n), $r("matchMedia");
    }
  },
  op = function t() {
    return lo(ue, "scrollEnd", t) || Qr(!0);
  },
  $r = function (e) {
    return (
      (ho[e] &&
        ho[e].map(function (n) {
          return n();
        })) ||
      n_
    );
  },
  ri = [],
  ap = function (e) {
    for (var n = 0; n < ri.length; n += 4)
      (!e || ri[n + 3] === e) &&
        ((ri[n].style.cssText = ri[n + 1]), (ri[n + 2].uncache = 1));
  },
  qa = function (e, n) {
    var i;
    for (ce = 0; ce < Zt.length; ce++)
      (i = Zt[ce]),
        (!n || i.media === n) &&
          (e
            ? i.kill(1)
            : (i.scroll.rec || (i.scroll.rec = i.scroll()), i.revert()));
    ap(n), n || $r("revert");
  },
  Qr = function (e, n) {
    if (kn && !e) {
      Ye(ue, "scrollEnd", op);
      return;
    }
    var i = $r("refreshInit");
    for (Xd && ue.sort(), n || qa(), ce = 0; ce < Zt.length; ce++)
      Zt[ce].refresh();
    for (
      i.forEach(function (r) {
        return r && r.render && r.render(-1);
      }),
        ce = Zt.length;
      ce--;

    )
      Zt[ce].scroll.rec = 0;
    du.pause(), $r("refresh");
  },
  cp = 0,
  Xa = 1,
  Pu = function () {
    var e = Zt.length,
      n = ir(),
      i = n - _u >= 50,
      r = e && Zt[0].scroll();
    if (
      ((Xa = cp > r ? -1 : 1),
      (cp = r),
      i &&
        (kn && !Oa && n - kn > 200 && ((kn = 0), $r("scrollEnd")),
        (Ra = _u),
        (_u = n)),
      Xa < 0)
    ) {
      for (ce = e; ce--; ) Zt[ce] && Zt[ce].update(0, i);
      Xa = 1;
    } else for (ce = 0; ce < e; ce++) Zt[ce] && Zt[ce].update(0, i);
    ao = 0;
  },
  Cu = [
    Su,
    Tu,
    ka,
    Ua,
    pn + Zr,
    pn + qr,
    pn + Yr,
    pn + Xr,
    "display",
    "flexShrink",
    "float",
  ],
  Ya = Cu.concat([
    Wr,
    jr,
    "boxSizing",
    "max" + sr,
    "max" + Ga,
    "position",
    pn,
    xe,
    xe + Yr,
    xe + qr,
    xe + Zr,
    xe + Xr,
  ]),
  i_ = function (e, n, i) {
    if ((Za(i), e.parentNode === n)) {
      var r = n.parentNode;
      r && (r.insertBefore(e, n), r.removeChild(n));
    }
  },
  Ru = function (e, n, i, r) {
    if (e.parentNode !== n) {
      for (var s = Cu.length, o = n.style, a = e.style, c; s--; )
        (c = Cu[s]), (o[c] = i[c]);
      (o.position = i.position === "absolute" ? "absolute" : "relative"),
        i.display === "inline" && (o.display = "inline-block"),
        (a[ka] = a[Ua] = "auto"),
        (o.overflow = "visible"),
        (o.boxSizing = "border-box"),
        (o[Wr] = Eu(e, Mn) + Xe),
        (o[jr] = Eu(e, ke) + Xe),
        (o[xe] = a[pn] = a[Tu] = a[Su] = "0"),
        Za(r),
        (a[Wr] = a["max" + sr] = i[Wr]),
        (a[jr] = a["max" + Ga] = i[jr]),
        (a[xe] = i[xe]),
        e.parentNode.insertBefore(n, e),
        n.appendChild(e);
    }
  },
  r_ = /([A-Z])/g,
  Za = function (e) {
    if (e)
      for (var n = e.t.style, i = e.length, r = 0, s, o; r < i; r += 2)
        (o = e[r + 1]),
          (s = e[r]),
          o
            ? (n[s] = o)
            : n[s] && n.removeProperty(s.replace(r_, "-$1").toLowerCase());
  },
  Ou = function (e) {
    for (var n = Ya.length, i = e.style, r = [], s = 0; s < n; s++)
      r.push(Ya[s], i[Ya[s]]);
    return (r.t = e), r;
  },
  s_ = function (e, n, i) {
    for (var r = [], s = e.length, o = i ? 8 : 0, a; o < s; o += 2)
      (a = e[o]), r.push(a, a in n ? n[a] : e[o + 1]);
    return (r.t = e.t), r;
  },
  Ja = { left: 0, top: 0 },
  lp = function (e, n, i, r, s, o, a, c, l, u, h, d) {
    if (
      (Li(e) && (e = e(c)),
      rr(e) &&
        e.substr(0, 3) === "max" &&
        (e = d + (e.charAt(4) === "=" ? Ha("0" + e.substr(3), i) : 0)),
      wu(e))
    )
      a && Wa(a, i, r, !0);
    else {
      Li(n) && (n = n(c));
      var f = Un(n)[0] || Se,
        p = or(f) || {},
        _ = e.split(" "),
        y,
        m,
        g;
      (!p || (!p.left && !p.top)) &&
        ii(f).display === "none" &&
        ((g = f.style.display),
        (f.style.display = "block"),
        (p = or(f)),
        g ? (f.style.display = g) : f.style.removeProperty("display")),
        (y = Ha(_[0], p[r.d])),
        (m = Ha(_[1] || "0", i)),
        (e = p[r.p] - l[r.p] - u + y + s - m),
        a && Wa(a, m, r, i - m < 20 || (a._isStart && m > 20)),
        (i -= i - m);
    }
    if (o) {
      var b = e + i,
        x = o._isStart;
      (d = "scroll" + r.d2),
        Wa(
          o,
          b,
          r,
          (x && b > 20) ||
            (!x && (h ? Math.max(Se[d], ni[d]) : o.parentNode[d]) <= b + 1)
        ),
        h &&
          ((l = or(a)),
          h && (o.style[r.op.p] = l[r.op.p] - r.op.m - o._offset + Xe));
    }
    return Math.round(e);
  },
  o_ = /(?:webkit|moz|length|cssText)/i,
  up = function (e, n, i, r) {
    if (e.parentNode !== n) {
      var s = e.style,
        o,
        a;
      if (n === Se) {
        (e._stOrig = s.cssText), (a = ii(e));
        for (o in a)
          !+o &&
            !o_.test(o) &&
            a[o] &&
            typeof s[o] == "string" &&
            o !== "0" &&
            (s[o] = a[o]);
        (s.top = i), (s.left = r);
      } else s.cssText = e._stOrig;
      (Ft.core.getCache(e).uncache = 1), n.appendChild(e);
    }
  },
  hp = function (e, n) {
    var i = Ia(e, n),
      r = "_scroll" + n.p2,
      s,
      o,
      a = function c(l, u, h, d, f) {
        var p = c.tween,
          _ = u.onComplete,
          y = {};
        return (
          p && p.kill(),
          (s = Math.round(h)),
          (u[r] = l),
          (u.modifiers = y),
          (y[r] = function (m) {
            return (
              (m = Math.round(i())),
              m !== s && m !== o
                ? (p.kill(), (c.tween = 0))
                : (m = h + d * p.ratio + f * p.ratio * p.ratio),
              (o = s),
              (s = Math.round(m))
            );
          }),
          (u.onComplete = function () {
            (c.tween = 0), _ && _.call(p);
          }),
          (p = c.tween = Ft.to(e, u)),
          p
        );
      };
    return (e[r] = i), a;
  };
Mn.op = ke;
var ue = (function () {
  function t(n, i) {
    Pa ||
      t.register(Ft) ||
      console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
      this.init(n, i);
  }
  var e = t.prototype;
  return (
    (e.init = function (i, r) {
      if (((this.progress = 0), this.vars && this.kill(1), !Yd)) {
        this.update = this.refresh = this.kill = xu;
        return;
      }
      i = Kd(rr(i) || wu(i) || i.nodeType ? { trigger: i } : i, Au);
      var s = i.horizontal ? Mn : ke,
        o = i,
        a = o.onUpdate,
        c = o.toggleClass,
        l = o.id,
        u = o.onToggle,
        h = o.onRefresh,
        d = o.scrub,
        f = o.trigger,
        p = o.pin,
        _ = o.pinSpacing,
        y = o.invalidateOnRefresh,
        m = o.anticipatePin,
        g = o.onScrubComplete,
        b = o.onSnapComplete,
        x = o.once,
        v = o.snap,
        w = o.pinReparent,
        M = !d && d !== 0,
        C = Un(i.scroller || pe)[0],
        A = Ft.core.getCache(C),
        U = Hr(C),
        I =
          "pinType" in i
            ? i.pinType === "fixed"
            : U || Vr(C, "pinType") === "fixed",
        B = [i.onEnter, i.onLeave, i.onEnterBack, i.onLeaveBack],
        F = M && i.toggleActions.split(" "),
        O = "markers" in i ? i.markers : Au.markers,
        R = U ? 0 : parseFloat(ii(C)["border" + s.p2 + sr]) || 0,
        P = this,
        V =
          i.onRefreshInit &&
          function () {
            return i.onRefreshInit(P);
          },
        Y = Qy(C, U, s),
        K = Ky(C, U),
        it,
        et,
        Ct,
        mt,
        Nt,
        Ot,
        G,
        kt,
        vt,
        St,
        yt,
        j,
        q,
        X,
        ht,
        ot,
        Tt,
        T,
        L,
        Z,
        W,
        D,
        J,
        Q,
        gt,
        $,
        at,
        Et,
        xt,
        ft,
        dt,
        Qt,
        ie,
        ji,
        qi,
        Xi,
        Yi;
      (P.media = Jr),
        (m *= 45),
        Zt.push(P),
        (P.scroller = C),
        (P.scroll = Ia(C, s)),
        (Nt = P.scroll()),
        (P.vars = i),
        (r = r || i.animation),
        "refreshPriority" in i && (Xd = 1),
        (A.tweenScroll = A.tweenScroll || { top: hp(C, ke), left: hp(C, Mn) }),
        (P.tweenTo = it = A.tweenScroll[s.p]),
        r &&
          ((r.vars.lazy = !1),
          r._initted ||
            (r.vars.immediateRender !== !1 &&
              i.immediateRender !== !1 &&
              r.render(0, !0, !0)),
          (P.animation = r.pause()),
          (r.scrollTrigger = P),
          (Qt = wu(d) && d),
          Qt &&
            (dt = Ft.to(r, {
              ease: "power3",
              duration: Qt,
              onComplete: function () {
                return g && g(P);
              },
            })),
          (xt = 0),
          l || (l = r.vars.id)),
        v &&
          (Mu(v) || (v = { snapTo: v }),
          Ft.set(U ? [Se, ni] : C, { scrollBehavior: "auto" }),
          (Ct = Li(v.snapTo)
            ? v.snapTo
            : v.snapTo === "labels"
            ? e_(r)
            : Ft.utils.snap(v.snapTo)),
          (ie = v.duration || { min: 0.1, max: 2 }),
          (ie = Mu(ie) ? Ca(ie.min, ie.max) : Ca(ie, ie)),
          (ji = Ft.delayedCall(v.delay || Qt / 2 || 0.1, function () {
            if (Math.abs(P.getVelocity()) < 10 && !Oa) {
              var oe = r && !M ? r.totalProgress() : P.progress,
                jt = ((oe - ft) / (ir() - Ra)) * 1e3 || 0,
                qt = (Fa(jt / 2) * jt) / 0.185,
                be = oe + qt,
                Dt = Ca(0, 1, Ct(be, P)),
                Ut = P.scroll(),
                Xt = Math.round(G + Dt * X),
                ln = it.tween;
              if (Ut <= kt && Ut >= G && Xt !== Ut) {
                if (ln && !ln._initted && ln.data <= Math.abs(Xt - Ut)) return;
                it(
                  Xt,
                  {
                    duration: ie(
                      Fa(
                        (Math.max(Fa(be - oe), Fa(Dt - oe)) * 0.185) /
                          jt /
                          0.05 || 0
                      )
                    ),
                    ease: v.ease || "power3",
                    data: Math.abs(Xt - Ut),
                    onComplete: function () {
                      (xt = ft = r && !M ? r.totalProgress() : P.progress),
                        b && b(P);
                    },
                  },
                  Ut,
                  qt * X,
                  Xt - Ut - qt * X
                );
              }
            } else P.isActive && ji.restart(!0);
          }).pause())),
        l && (Lu[l] = P),
        (f = P.trigger = Un(f || p)[0]),
        (p = p === !0 ? f : Un(p)[0]),
        rr(c) && (c = { targets: f, className: c }),
        p &&
          (_ === !1 ||
            _ === pn ||
            (_ = !_ && ii(p.parentNode).display === "flex" ? !1 : xe),
          (P.pin = p),
          i.force3D !== !1 && Ft.set(p, { force3D: !0 }),
          (et = Ft.core.getCache(p)),
          et.spacer
            ? (ht = et.pinState)
            : ((et.spacer = T = Ue.createElement("div")),
              T.setAttribute(
                "class",
                "pin-spacer" + (l ? " pin-spacer-" + l : "")
              ),
              (et.pinState = ht = Ou(p))),
          (P.spacer = T = et.spacer),
          (Et = ii(p)),
          (Q = Et[_ + s.os2]),
          (Z = Ft.getProperty(p)),
          (W = Ft.quickSetter(p, s.a, Xe)),
          Ru(p, T, Et),
          (Tt = Ou(p))),
        O &&
          ((q = Mu(O) ? Kd(O, ep) : ep),
          (yt = Va("scroller-start", l, C, s, q, 0)),
          (j = Va("scroller-end", l, C, s, q, 0, yt)),
          (L = yt["offset" + s.op.d2]),
          (vt = Va("start", l, C, s, q, L)),
          (St = Va("end", l, C, s, q, L)),
          I ||
            (t_(C),
            Ft.set([yt, j], { force3D: !0 }),
            ($ = Ft.quickSetter(yt, s.a, Xe)),
            (at = Ft.quickSetter(j, s.a, Xe)))),
        (P.revert = function (oe) {
          var jt = oe !== !1 || !P.enabled,
            qt = nn;
          jt !== mt &&
            (jt &&
              ((Xi = Math.max(P.scroll(), P.scroll.rec || 0)),
              (qi = P.progress),
              (Yi = r && r.progress())),
            vt &&
              [vt, St, yt, j].forEach(function (be) {
                return (be.style.display = jt ? "none" : "block");
              }),
            jt && (nn = 1),
            P.update(jt),
            (nn = qt),
            p &&
              (jt ? i_(p, T, ht) : (!w || !P.isActive) && Ru(p, T, ii(p), gt)),
            (mt = jt));
        }),
        (P.refresh = function (oe) {
          if (!(nn || !P.enabled)) {
            if (p && oe && kn) {
              Ye(t, "scrollEnd", op);
              return;
            }
            (nn = 1),
              dt && dt.kill(),
              y && r && r.progress(0).invalidate(),
              mt || P.revert();
            for (
              var jt = Y(),
                qt = K(),
                be = vu(C, s),
                Dt = 0,
                Ut = 0,
                Xt = i.end,
                ln = i.endTrigger || f,
                we =
                  i.start || (i.start === 0 ? 0 : p || !f ? "0 0" : "0 100%"),
                E = (f && Math.max(0, Zt.indexOf(P))) || 0,
                z = E,
                N,
                k,
                tt,
                At,
                pt,
                ut,
                Gt,
                Yt;
              z--;

            )
              (Gt = Zt[z].pin), Gt && (Gt === f || Gt === p) && Zt[z].revert();
            for (
              G =
                lp(we, f, jt, s, P.scroll(), vt, yt, P, qt, R, I, be) ||
                (p ? -0.001 : 0),
                Li(Xt) && (Xt = Xt(P)),
                rr(Xt) &&
                  !Xt.indexOf("+=") &&
                  (~Xt.indexOf(" ")
                    ? (Xt = (rr(we) ? we.split(" ")[0] : "") + Xt)
                    : ((Dt = Ha(Xt.substr(2), jt)),
                      (Xt = rr(we) ? we : G + Dt),
                      (ln = f))),
                kt =
                  Math.max(
                    G,
                    lp(
                      Xt || (ln ? "100% 0" : be),
                      ln,
                      jt,
                      s,
                      P.scroll() + Dt,
                      St,
                      j,
                      P,
                      qt,
                      R,
                      I,
                      be
                    )
                  ) || -0.001,
                X = kt - G || ((G -= 0.01) && 0.001),
                Dt = 0,
                z = E;
              z--;

            )
              (ut = Zt[z]),
                (Gt = ut.pin),
                Gt &&
                  ut.start - ut._pinPush < G &&
                  ((N = ut.end - ut.start),
                  Gt === f && (Dt += N),
                  Gt === p && (Ut += N));
            if (
              ((G += Dt),
              (kt += Dt),
              (P._pinPush = Ut),
              vt && Dt && ((N = {}), (N[s.a] = "+=" + Dt), Ft.set([vt, St], N)),
              p)
            )
              (N = ii(p)),
                (At = s === ke),
                (tt = P.scroll()),
                (D = parseFloat(Z(s.a)) + Ut),
                !be &&
                  kt > 1 &&
                  ((U ? Se : C).style["overflow-" + s.a] = "scroll"),
                Ru(p, T, N),
                (Tt = Ou(p)),
                (k = or(p, !0)),
                (Yt = I && Ia(C, At ? Mn : ke)()),
                _ &&
                  ((gt = [_ + s.os2, X + Ut + Xe]),
                  (gt.t = T),
                  (z = _ === xe ? Eu(p, s) + X + Ut : 0),
                  z && gt.push(s.d, z + Xe),
                  Za(gt),
                  I && P.scroll(Xi)),
                I &&
                  ((pt = {
                    top: k.top + (At ? tt - G : Yt) + Xe,
                    left: k.left + (At ? Yt : tt - G) + Xe,
                    boxSizing: "border-box",
                    position: "fixed",
                  }),
                  (pt[Wr] = pt["max" + sr] = Math.ceil(k.width) + Xe),
                  (pt[jr] = pt["max" + Ga] = Math.ceil(k.height) + Xe),
                  (pt[pn] =
                    pt[pn + Yr] =
                    pt[pn + qr] =
                    pt[pn + Zr] =
                    pt[pn + Xr] =
                      "0"),
                  (pt[xe] = N[xe]),
                  (pt[xe + Yr] = N[xe + Yr]),
                  (pt[xe + qr] = N[xe + qr]),
                  (pt[xe + Zr] = N[xe + Zr]),
                  (pt[xe + Xr] = N[xe + Xr]),
                  (ot = s_(ht, pt, w))),
                r
                  ? (r.progress(1, !0),
                    (J = Z(s.a) - D + X + Ut),
                    X !== J && ot.splice(ot.length - 2, 2),
                    r.progress(0, !0))
                  : (J = X);
            else if (f && P.scroll())
              for (k = f.parentNode; k && k !== Se; )
                k._pinOffset && ((G -= k._pinOffset), (kt -= k._pinOffset)),
                  (k = k.parentNode);
            for (z = 0; z < E; z++)
              (ut = Zt[z].pin),
                ut && (ut === f || ut === p) && Zt[z].revert(!1);
            (P.start = G),
              (P.end = kt),
              (Nt = Ot = P.scroll()),
              Nt < Xi && P.scroll(Xi),
              P.revert(!1),
              (nn = 0),
              Yi && M && r.progress(Yi, !0),
              qi !== P.progress &&
                (dt && r.totalProgress(qi, !0), (P.progress = qi), P.update()),
              p && _ && (T._pinOffset = Math.round(P.progress * J)),
              h && h(P);
          }
        }),
        (P.getVelocity = function () {
          return ((P.scroll() - Ot) / (ir() - Ra)) * 1e3 || 0;
        }),
        (P.update = function (oe, jt) {
          var qt = P.scroll(),
            be = oe ? 0 : (qt - G) / X,
            Dt = be < 0 ? 0 : be > 1 ? 1 : be || 0,
            Ut = P.progress,
            Xt,
            ln,
            we,
            E,
            z,
            N;
          if (
            (jt &&
              ((Ot = Nt),
              (Nt = qt),
              v && ((ft = xt), (xt = r && !M ? r.totalProgress() : Dt))),
            m &&
              !Dt &&
              p &&
              !nn &&
              !co &&
              kn &&
              G < qt + ((qt - Ot) / (ir() - Ra)) * m &&
              (Dt = 1e-4),
            Dt !== Ut && P.enabled)
          ) {
            if (
              ((Xt = P.isActive = !!Dt && Dt < 1),
              (ln = !!Ut && Ut < 1),
              (N = Xt !== ln),
              (z = N || !!Dt != !!Ut),
              (P.direction = Dt > Ut ? 1 : -1),
              (P.progress = Dt),
              M ||
                (dt && !nn && !co
                  ? ((dt.vars.totalProgress = Dt), dt.invalidate().restart())
                  : r && r.totalProgress(Dt, !!nn)),
              p)
            ) {
              if ((oe && _ && (T.style[_ + s.os2] = Q), !I)) W(D + J * Dt);
              else if (z) {
                if (
                  ((E = !oe && Dt > Ut && kt + 1 > qt && qt + 1 >= vu(C, s)), w)
                )
                  if (!oe && (Xt || E)) {
                    var k = or(p, !0),
                      tt = qt - G;
                    up(
                      p,
                      Se,
                      k.top + (s === ke ? tt : 0) + Xe,
                      k.left + (s === ke ? 0 : tt) + Xe
                    );
                  } else up(p, T);
                Za(Xt || E ? ot : Tt),
                  (J !== X && Dt < 1 && Xt) || W(D + (Dt === 1 && !E ? J : 0));
              }
            }
            v && !it.tween && !nn && !co && ji.restart(!0),
              c &&
                (N || (x && Dt && (Dt < 1 || !yu))) &&
                Un(c.targets).forEach(function (At) {
                  return At.classList[Xt || x ? "add" : "remove"](c.className);
                }),
              a && !M && !oe && a(P),
              z && !nn
                ? ((we = Dt && !Ut ? 0 : Dt === 1 ? 1 : Ut === 1 ? 2 : 3),
                  M &&
                    ((E = (!N && F[we + 1] !== "none" && F[we + 1]) || F[we]),
                    r &&
                      (E === "complete" || E === "reset" || E in r) &&
                      (E === "complete"
                        ? r.pause().totalProgress(1)
                        : E === "reset"
                        ? r.restart(!0).pause()
                        : r[E]()),
                    a && a(P)),
                  (N || !yu) &&
                    (u && N && u(P),
                    B[we] && B[we](P),
                    x && (Dt === 1 ? P.kill(!1, 1) : (B[we] = 0)),
                    N || ((we = Dt === 1 ? 1 : 3), B[we] && B[we](P))))
                : M && a && !nn && a(P);
          }
          at && ($(qt + (yt._isFlipped ? 1 : 0)), at(qt));
        }),
        (P.enable = function () {
          P.enabled ||
            ((P.enabled = !0),
            Ye(C, "resize", uo),
            Ye(C, "scroll", ja),
            V && Ye(t, "refreshInit", V),
            !r || !r.add
              ? P.refresh()
              : Ft.delayedCall(0.01, function () {
                  return G || kt || P.refresh();
                }) &&
                (X = 0.01) &&
                (G = kt = 0));
        }),
        (P.disable = function (oe, jt) {
          if (
            P.enabled &&
            (oe !== !1 && P.revert(),
            (P.enabled = P.isActive = !1),
            jt || (dt && dt.pause()),
            (Xi = 0),
            et && (et.uncache = 1),
            V && lo(t, "refreshInit", V),
            ji && (ji.pause(), it.tween && it.tween.kill() && (it.tween = 0)),
            !U)
          ) {
            for (var qt = Zt.length; qt--; )
              if (Zt[qt].scroller === C && Zt[qt] !== P) return;
            lo(C, "resize", uo), lo(C, "scroll", ja);
          }
        }),
        (P.kill = function (oe, jt) {
          P.disable(oe, jt), l && delete Lu[l];
          var qt = Zt.indexOf(P);
          Zt.splice(qt, 1),
            qt === ce && Xa > 0 && ce--,
            r && ((r.scrollTrigger = null), oe && r.render(-1), jt || r.kill()),
            vt &&
              [vt, St, yt, j].forEach(function (be) {
                return be.parentNode.removeChild(be);
              }),
            et && (et.uncache = 1);
        }),
        P.enable();
    }),
    (t.register = function (i) {
      if (
        !Pa &&
        ((Ft = i || Jd()),
        Zd() &&
          window.document &&
          ((pe = window),
          (Ue = document),
          (ni = Ue.documentElement),
          (Se = Ue.body)),
        Ft &&
          ((Un = Ft.utils.toArray),
          (Ca = Ft.utils.clamp),
          Ft.core.globals("ScrollTrigger", t),
          Se))
      ) {
        (pu =
          pe.requestAnimationFrame ||
          function (a) {
            return setTimeout(a, 16);
          }),
          Ye(pe, "mousewheel", ja),
          (Wd = [pe, Ue, ni, Se]),
          Ye(Ue, "scroll", ja);
        var r = Se.style,
          s = r.borderTop,
          o;
        (r.borderTop = "1px solid #000"),
          (o = or(Se)),
          (ke.m = Math.round(o.top + ke.sc()) || 0),
          (Mn.m = Math.round(o.left + Mn.sc()) || 0),
          s ? (r.borderTop = s) : r.removeProperty("border-top"),
          (mu = setInterval(ip, 200)),
          Ft.delayedCall(0.5, function () {
            return (co = 0);
          }),
          Ye(Ue, "touchcancel", xu),
          Ye(Se, "touchstart", xu),
          tp(Ye, Ue, "pointerdown,touchstart,mousedown", function () {
            return (Oa = 1);
          }),
          tp(Ye, Ue, "pointerup,touchend,mouseup", function () {
            return (Oa = 0);
          }),
          (gu = Ft.utils.checkPrefix("transform")),
          Ya.push(gu),
          (Pa = ir()),
          (du = Ft.delayedCall(0.2, Qr).pause()),
          (kr = [
            Ue,
            "visibilitychange",
            function () {
              var a = pe.innerWidth,
                c = pe.innerHeight;
              Ue.hidden ? ((jd = a), (qd = c)) : (jd !== a || qd !== c) && uo();
            },
            Ue,
            "DOMContentLoaded",
            Qr,
            pe,
            "load",
            function () {
              return kn || Qr();
            },
            pe,
            "resize",
            uo,
          ]),
          bu(Ye);
      }
      return Pa;
    }),
    (t.defaults = function (i) {
      for (var r in i) Au[r] = i[r];
    }),
    (t.kill = function () {
      (Yd = 0),
        Zt.slice(0).forEach(function (i) {
          return i.kill(1);
        });
    }),
    (t.config = function (i) {
      "limitCallbacks" in i && (yu = !!i.limitCallbacks);
      var r = i.syncInterval;
      (r && clearInterval(mu)) || ((mu = r) && setInterval(ip, r)),
        "autoRefreshEvents" in i &&
          (bu(lo) || bu(Ye, i.autoRefreshEvents || "none"));
    }),
    (t.scrollerProxy = function (i, r) {
      var s = Un(i)[0];
      Hr(s) ? Gr.unshift(pe, r, Se, r, ni, r) : Gr.unshift(s, r);
    }),
    (t.matchMedia = function (i) {
      var r, s, o, a, c;
      for (s in i)
        (o = le.indexOf(s)),
          (a = i[s]),
          (Jr = s),
          s === "all"
            ? a()
            : ((r = pe.matchMedia(s)),
              r &&
                (r.matches && (c = a()),
                ~o
                  ? ((le[o + 1] = Qd(le[o + 1], a)),
                    (le[o + 2] = Qd(le[o + 2], c)))
                  : ((o = le.length),
                    le.push(s, a, c),
                    r.addListener
                      ? r.addListener(sp)
                      : r.addEventListener("change", sp)),
                (le[o + 3] = r.matches))),
          (Jr = 0);
      return le;
    }),
    (t.clearMatchMedia = function (i) {
      i || (le.length = 0), (i = le.indexOf(i)), i >= 0 && le.splice(i, 4);
    }),
    t
  );
})();
ue.version = "3.5.1";
ue.saveStyles = function (t) {
  return t
    ? Un(t).forEach(function (e) {
        var n = ri.indexOf(e);
        n >= 0 && ri.splice(n, 4),
          ri.push(e, e.style.cssText, Ft.core.getCache(e), Jr);
      })
    : ri;
};
ue.revert = function (t, e) {
  return qa(!t, e);
};
ue.create = function (t, e) {
  return new ue(t, e);
};
ue.refresh = function (t) {
  return t ? uo() : Qr(!0);
};
ue.update = Pu;
ue.maxScroll = function (t, e) {
  return vu(t, e ? Mn : ke);
};
ue.getScrollFunc = function (t, e) {
  return Ia(Un(t)[0], e ? Mn : ke);
};
ue.getById = function (t) {
  return Lu[t];
};
ue.getAll = function () {
  return Zt.slice(0);
};
ue.isScrolling = function () {
  return !!kn;
};
ue.addEventListener = function (t, e) {
  var n = ho[t] || (ho[t] = []);
  ~n.indexOf(e) || n.push(e);
};
ue.removeEventListener = function (t, e) {
  var n = ho[t],
    i = n && n.indexOf(e);
  i >= 0 && n.splice(i, 1);
};
ue.batch = function (t, e) {
  var n = [],
    i = {},
    r = e.interval || 0.016,
    s = e.batchMax || 1e9,
    o = function (l, u) {
      var h = [],
        d = [],
        f = Ft.delayedCall(r, function () {
          u(h, d), (h = []), (d = []);
        }).pause();
      return function (p) {
        h.length || f.restart(!0),
          h.push(p.trigger),
          d.push(p),
          s <= h.length && f.progress(1);
      };
    },
    a;
  for (a in e)
    i[a] =
      a.substr(0, 2) === "on" && Li(e[a]) && a !== "onRefreshInit"
        ? o(a, e[a])
        : e[a];
  return (
    Li(s) &&
      ((s = s()),
      Ye(ue, "refresh", function () {
        return (s = e.batchMax());
      })),
    Un(t).forEach(function (c) {
      var l = {};
      for (a in i) l[a] = i[a];
      (l.trigger = c), n.push(ue.create(l));
    }),
    n
  );
};
ue.sort = function (t) {
  return Zt.sort(
    t ||
      function (e, n) {
        return (
          (e.vars.refreshPriority || 0) * -1e6 +
          e.start -
          (n.start + (n.vars.refreshPriority || 0) * -1e6)
        );
      }
  );
};
Jd() && Ft.registerPlugin(ue);
var a_ = "Expected a function",
  fp = 0 / 0,
  c_ = "[object Symbol]",
  l_ = /^\s+|\s+$/g,
  u_ = /^[-+]0x[0-9a-f]+$/i,
  h_ = /^0b[01]+$/i,
  f_ = /^0o[0-7]+$/i,
  d_ = parseInt,
  p_ = typeof oo == "object" && oo && oo.Object === Object && oo,
  m_ = typeof self == "object" && self && self.Object === Object && self,
  g_ = p_ || m_ || Function("return this")(),
  y_ = Object.prototype,
  __ = y_.toString,
  x_ = Math.max,
  v_ = Math.min,
  Du = function () {
    return g_.Date.now();
  };
function b_(t, e, n) {
  var i,
    r,
    s,
    o,
    a,
    c,
    l = 0,
    u = !1,
    h = !1,
    d = !0;
  if (typeof t != "function") throw new TypeError(a_);
  (e = dp(e) || 0),
    Iu(n) &&
      ((u = !!n.leading),
      (h = "maxWait" in n),
      (s = h ? x_(dp(n.maxWait) || 0, e) : s),
      (d = "trailing" in n ? !!n.trailing : d));
  function f(w) {
    var M = i,
      C = r;
    return (i = r = void 0), (l = w), (o = t.apply(C, M)), o;
  }
  function p(w) {
    return (l = w), (a = setTimeout(m, e)), u ? f(w) : o;
  }
  function _(w) {
    var M = w - c,
      C = w - l,
      A = e - M;
    return h ? v_(A, s - C) : A;
  }
  function y(w) {
    var M = w - c,
      C = w - l;
    return c === void 0 || M >= e || M < 0 || (h && C >= s);
  }
  function m() {
    var w = Du();
    if (y(w)) return g(w);
    a = setTimeout(m, _(w));
  }
  function g(w) {
    return (a = void 0), d && i ? f(w) : ((i = r = void 0), o);
  }
  function b() {
    a !== void 0 && clearTimeout(a), (l = 0), (i = c = r = a = void 0);
  }
  function x() {
    return a === void 0 ? o : g(Du());
  }
  function v() {
    var w = Du(),
      M = y(w);
    if (((i = arguments), (r = this), (c = w), M)) {
      if (a === void 0) return p(c);
      if (h) return (a = setTimeout(m, e)), f(c);
    }
    return a === void 0 && (a = setTimeout(m, e)), o;
  }
  return (v.cancel = b), (v.flush = x), v;
}
function Iu(t) {
  var e = typeof t;
  return !!t && (e == "object" || e == "function");
}
function w_(t) {
  return !!t && typeof t == "object";
}
function M_(t) {
  return typeof t == "symbol" || (w_(t) && __.call(t) == c_);
}
function dp(t) {
  if (typeof t == "number") return t;
  if (M_(t)) return fp;
  if (Iu(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = Iu(e) ? e + "" : e;
  }
  if (typeof t != "string") return t === 0 ? t : +t;
  t = t.replace(l_, "");
  var n = h_.test(t);
  return n || f_.test(t) ? d_(t.slice(2), n ? 2 : 8) : u_.test(t) ? fp : +t;
}
var b1 = b_,
  Nu = { exports: {} };
function Fu() {}
Fu.prototype = {
  on: function (t, e, n) {
    var i = this.e || (this.e = {});
    return (i[t] || (i[t] = [])).push({ fn: e, ctx: n }), this;
  },
  once: function (t, e, n) {
    var i = this;
    function r() {
      i.off(t, r), e.apply(n, arguments);
    }
    return (r._ = e), this.on(t, r, n);
  },
  emit: function (t) {
    var e = [].slice.call(arguments, 1),
      n = ((this.e || (this.e = {}))[t] || []).slice(),
      i = 0,
      r = n.length;
    for (i; i < r; i++) n[i].fn.apply(n[i].ctx, e);
    return this;
  },
  off: function (t, e) {
    var n = this.e || (this.e = {}),
      i = n[t],
      r = [];
    if (i && e)
      for (var s = 0, o = i.length; s < o; s++)
        i[s].fn !== e && i[s].fn._ !== e && r.push(i[s]);
    return r.length ? (n[t] = r) : delete n[t], this;
  },
};
Nu.exports = Fu;
Nu.exports.TinyEmitter = Fu;
var S_ = Nu.exports;
class $a {
  constructor(e) {
    (this.wrap = document.querySelector("[data-router-wrapper]")),
      (this.properties = e),
      (this.Transition = e.transition
        ? new e.transition.class(this.wrap, e.transition.name)
        : null);
  }
  setup() {
    this.onEnter && this.onEnter(),
      this.onEnterCompleted && this.onEnterCompleted();
  }
  add() {
    this.wrap.insertAdjacentHTML("beforeend", this.properties.view.outerHTML);
  }
  update() {
    document.title = this.properties.page.title;
  }
  show(e) {
    return new Promise(async (n) => {
      this.update(),
        this.onEnter && this.onEnter(),
        this.Transition && (await this.Transition.show(e)),
        this.onEnterCompleted && this.onEnterCompleted(),
        n();
    });
  }
  hide(e) {
    return new Promise(async (n) => {
      this.onLeave && this.onLeave(),
        this.Transition && (await this.Transition.hide(e)),
        this.onLeaveCompleted && this.onLeaveCompleted(),
        n();
    });
  }
}
const T_ = new window.DOMParser();
class pp {
  constructor(e, n) {
    (this.renderers = e), (this.transitions = n);
  }
  getOrigin(e) {
    const n = e.match(/(https?:\/\/[\w\-.]+)/);
    return n ? n[1].replace(/https?:\/\//, "") : null;
  }
  getPathname(e) {
    const n = e.match(/https?:\/\/.*?(\/[\w_\-./]+)/);
    return n ? n[1] : "/";
  }
  getAnchor(e) {
    const n = e.match(/(#.*)$/);
    return n ? n[1] : null;
  }
  getParams(e) {
    const n = e.match(/\?([\w_\-.=&]+)/);
    if (!n) return null;
    const i = n[1].split("&"),
      r = {};
    for (let s = 0; s < i.length; s++) {
      const o = i[s].split("="),
        { 0: a } = o,
        { 1: c } = o;
      r[a] = c;
    }
    return r;
  }
  getDOM(e) {
    return typeof e == "string" ? T_.parseFromString(e, "text/html") : e;
  }
  getView(e) {
    return e.querySelector("[data-router-view]");
  }
  getSlug(e) {
    return e.getAttribute("data-router-view");
  }
  getRenderer(e) {
    if (!this.renderers) return Promise.resolve($a);
    if (e in this.renderers) {
      const n = this.renderers[e];
      return typeof n == "function" && !$a.isPrototypeOf(n)
        ? Promise.resolve(n()).then(({ default: i }) => i)
        : typeof n.then == "function"
        ? Promise.resolve(n).then(({ default: i }) => i)
        : Promise.resolve(n);
    }
    return Promise.resolve($a);
  }
  getTransition(e) {
    return this.transitions
      ? e in this.transitions
        ? { class: this.transitions[e], name: e }
        : "default" in this.transitions
        ? { class: this.transitions.default, name: "default" }
        : null
      : null;
  }
  getProperties(e) {
    const n = this.getDOM(e),
      i = this.getView(n),
      r = this.getSlug(i),
      s = this.getRenderer(r, this.renderers),
      o = this.getTransition(r, this.transitions);
    return { page: n, view: i, slug: r, renderer: s, transition: o };
  }
  getLocation(e) {
    return {
      href: e,
      anchor: this.getAnchor(e),
      origin: this.getOrigin(e),
      params: this.getParams(e),
      pathname: this.getPathname(e),
    };
  }
}
class E_ extends S_ {
  constructor({ renderers: e, transitions: n } = {}) {
    super();
    (this.Helpers = new pp(e, n)),
      (this.Transitions = n),
      (this.Contextual = !1),
      (this.location = this.Helpers.getLocation(window.location.href)),
      (this.properties = this.Helpers.getProperties(document.cloneNode(!0))),
      (this.popping = !1),
      (this.running = !1),
      (this.trigger = null),
      (this.cache = new Map()),
      this.cache.set(this.location.href, this.properties),
      this.properties.renderer.then((i) => {
        (this.From = new i(this.properties)), this.From.setup();
      }),
      (this._navigate = this.navigate.bind(this)),
      window.addEventListener("popstate", this.popState.bind(this)),
      (this.links = document.querySelectorAll(
        "a:not([target]):not([data-router-disabled])"
      )),
      this.attach(this.links);
  }
  attach(e) {
    for (const n of e) n.addEventListener("click", this._navigate);
  }
  detach(e) {
    for (const n of e) n.removeEventListener("click", this._navigate);
  }
  navigate(e) {
    if (!(e.metaKey || e.ctrlKey)) {
      e.preventDefault();
      const n = e.currentTarget.hasAttribute("data-transition")
        ? e.currentTarget.dataset.transition
        : !1;
      this.redirect(e.currentTarget.href, n, e.currentTarget);
    }
  }
  redirect(e, n = !1, i = "script") {
    if (((this.trigger = i), !this.running && e !== this.location.href)) {
      const r = this.Helpers.getLocation(e);
      (this.Contextual = !1),
        n &&
          ((this.Contextual = this.Transitions.contextual[n].prototype),
          (this.Contextual.name = n)),
        r.origin !== this.location.origin ||
        (r.anchor && r.pathname === this.location.pathname)
          ? (window.location.href = e)
          : ((this.location = r), this.beforeFetch());
    }
  }
  popState() {
    (this.trigger = "popstate"), (this.Contextual = !1);
    const e = this.Helpers.getLocation(window.location.href);
    this.location.pathname !== e.pathname ||
    (!this.location.anchor && !e.anchor)
      ? ((this.popping = !0), (this.location = e), this.beforeFetch())
      : (this.location = e);
  }
  pushState() {
    this.popping ||
      window.history.pushState(this.location, "", this.location.href);
  }
  async fetch() {
    const e = await fetch(this.location.href, {
      mode: "same-origin",
      method: "GET",
      headers: { "X-Requested-With": "Highway" },
      credentials: "same-origin",
    });
    if (e.status >= 200 && e.status < 300) return e.text();
    window.location.href = this.location.href;
  }
  async beforeFetch() {
    this.pushState(),
      (this.running = !0),
      this.emit("NAVIGATE_OUT", {
        from: {
          page: this.From.properties.page,
          view: this.From.properties.view,
        },
        trigger: this.trigger,
        location: this.location,
      });
    const e = { trigger: this.trigger, contextual: this.Contextual };
    if (this.cache.has(this.location.href))
      await this.From.hide(e),
        (this.properties = this.cache.get(this.location.href));
    else {
      const n = await Promise.all([this.fetch(), this.From.hide(e)]);
      (this.properties = this.Helpers.getProperties(n[0])),
        this.cache.set(this.location.href, this.properties);
    }
    this.afterFetch();
  }
  async afterFetch() {
    const e = await this.properties.renderer;
    (this.To = new e(this.properties)),
      this.To.add(),
      this.emit("NAVIGATE_IN", {
        to: {
          page: this.To.properties.page,
          view: this.To.wrap.lastElementChild,
        },
        trigger: this.trigger,
        location: this.location,
      }),
      await this.To.show({
        trigger: this.trigger,
        contextual: this.Contextual,
      }),
      (this.popping = !1),
      (this.running = !1),
      this.detach(this.links),
      (this.links = document.querySelectorAll(
        "a:not([target]):not([data-router-disabled])"
      )),
      this.attach(this.links),
      this.emit("NAVIGATE_END", {
        to: {
          page: this.To.properties.page,
          view: this.To.wrap.lastElementChild,
        },
        from: {
          page: this.From.properties.page,
          view: this.From.properties.view,
        },
        trigger: this.trigger,
        location: this.location,
      }),
      (this.From = this.To),
      (this.trigger = null);
  }
}
class A_ {
  constructor(e, n) {
    (this.wrap = e), (this.name = n);
  }
  show({ trigger: e, contextual: n }) {
    const i = this.wrap.lastElementChild,
      r = this.wrap.firstElementChild;
    return new Promise((s) => {
      n
        ? (i.setAttribute("data-transition-in", n.name),
          i.removeAttribute("data-transition-out", n.name),
          n.in && n.in({ to: i, from: r, trigger: e, done: s }))
        : (i.setAttribute("data-transition-in", this.name),
          i.removeAttribute("data-transition-out", this.name),
          this.in && this.in({ to: i, from: r, trigger: e, done: s }));
    });
  }
  hide({ trigger: e, contextual: n }) {
    const i = this.wrap.firstElementChild;
    return new Promise((r) => {
      n
        ? (i.setAttribute("data-transition-out", n.name),
          i.removeAttribute("data-transition-in", n.name),
          n.out && n.out({ from: i, trigger: e, done: r }))
        : (i.setAttribute("data-transition-out", this.name),
          i.removeAttribute("data-transition-in", this.name),
          this.out && this.out({ from: i, trigger: e, done: r }));
    });
  }
}
console.log("Highway v2.2.0");
var w1 = { Core: E_, Helpers: pp, Renderer: $a, Transition: A_ },
  Bu = { exports: {} };
/*!
	autosize 4.0.2
	license: MIT
	http://www.jacklmoore.com/autosize
*/ (function (t, e) {
  (function (n, i) {
    i(t, e);
  })(oo, function (n, i) {
    var r =
        typeof Map == "function"
          ? new Map()
          : (function () {
              var u = [],
                h = [];
              return {
                has: function (f) {
                  return u.indexOf(f) > -1;
                },
                get: function (f) {
                  return h[u.indexOf(f)];
                },
                set: function (f, p) {
                  u.indexOf(f) === -1 && (u.push(f), h.push(p));
                },
                delete: function (f) {
                  var p = u.indexOf(f);
                  p > -1 && (u.splice(p, 1), h.splice(p, 1));
                },
              };
            })(),
      s = function (h) {
        return new Event(h, { bubbles: !0 });
      };
    try {
      new Event("test");
    } catch {
      s = function (d) {
        var f = document.createEvent("Event");
        return f.initEvent(d, !0, !1), f;
      };
    }
    function o(u) {
      if (!u || !u.nodeName || u.nodeName !== "TEXTAREA" || r.has(u)) return;
      var h = null,
        d = null,
        f = null;
      function p() {
        var v = window.getComputedStyle(u, null);
        v.resize === "vertical"
          ? (u.style.resize = "none")
          : v.resize === "both" && (u.style.resize = "horizontal"),
          v.boxSizing === "content-box"
            ? (h = -(parseFloat(v.paddingTop) + parseFloat(v.paddingBottom)))
            : (h =
                parseFloat(v.borderTopWidth) + parseFloat(v.borderBottomWidth)),
          isNaN(h) && (h = 0),
          g();
      }
      function _(v) {
        {
          var w = u.style.width;
          (u.style.width = "0px"), u.offsetWidth, (u.style.width = w);
        }
        u.style.overflowY = v;
      }
      function y(v) {
        for (var w = []; v && v.parentNode && v.parentNode instanceof Element; )
          v.parentNode.scrollTop &&
            w.push({ node: v.parentNode, scrollTop: v.parentNode.scrollTop }),
            (v = v.parentNode);
        return w;
      }
      function m() {
        if (u.scrollHeight !== 0) {
          var v = y(u),
            w = document.documentElement && document.documentElement.scrollTop;
          (u.style.height = ""),
            (u.style.height = u.scrollHeight + h + "px"),
            (d = u.clientWidth),
            v.forEach(function (M) {
              M.node.scrollTop = M.scrollTop;
            }),
            w && (document.documentElement.scrollTop = w);
        }
      }
      function g() {
        m();
        var v = Math.round(parseFloat(u.style.height)),
          w = window.getComputedStyle(u, null),
          M =
            w.boxSizing === "content-box"
              ? Math.round(parseFloat(w.height))
              : u.offsetHeight;
        if (
          (M < v
            ? w.overflowY === "hidden" &&
              (_("scroll"),
              m(),
              (M =
                w.boxSizing === "content-box"
                  ? Math.round(
                      parseFloat(window.getComputedStyle(u, null).height)
                    )
                  : u.offsetHeight))
            : w.overflowY !== "hidden" &&
              (_("hidden"),
              m(),
              (M =
                w.boxSizing === "content-box"
                  ? Math.round(
                      parseFloat(window.getComputedStyle(u, null).height)
                    )
                  : u.offsetHeight)),
          f !== M)
        ) {
          f = M;
          var C = s("autosize:resized");
          try {
            u.dispatchEvent(C);
          } catch {}
        }
      }
      var b = function () {
          u.clientWidth !== d && g();
        },
        x = function (v) {
          window.removeEventListener("resize", b, !1),
            u.removeEventListener("input", g, !1),
            u.removeEventListener("keyup", g, !1),
            u.removeEventListener("autosize:destroy", x, !1),
            u.removeEventListener("autosize:update", g, !1),
            Object.keys(v).forEach(function (w) {
              u.style[w] = v[w];
            }),
            r.delete(u);
        }.bind(u, {
          height: u.style.height,
          resize: u.style.resize,
          overflowY: u.style.overflowY,
          overflowX: u.style.overflowX,
          wordWrap: u.style.wordWrap,
        });
      u.addEventListener("autosize:destroy", x, !1),
        "onpropertychange" in u &&
          "oninput" in u &&
          u.addEventListener("keyup", g, !1),
        window.addEventListener("resize", b, !1),
        u.addEventListener("input", g, !1),
        u.addEventListener("autosize:update", g, !1),
        (u.style.overflowX = "hidden"),
        (u.style.wordWrap = "break-word"),
        r.set(u, { destroy: x, update: g }),
        p();
    }
    function a(u) {
      var h = r.get(u);
      h && h.destroy();
    }
    function c(u) {
      var h = r.get(u);
      h && h.update();
    }
    var l = null;
    typeof window == "undefined" || typeof window.getComputedStyle != "function"
      ? ((l = function (h) {
          return h;
        }),
        (l.destroy = function (u) {
          return u;
        }),
        (l.update = function (u) {
          return u;
        }))
      : ((l = function (h, d) {
          return (
            h &&
              Array.prototype.forEach.call(h.length ? h : [h], function (f) {
                return o(f);
              }),
            h
          );
        }),
        (l.destroy = function (u) {
          return u && Array.prototype.forEach.call(u.length ? u : [u], a), u;
        }),
        (l.update = function (u) {
          return u && Array.prototype.forEach.call(u.length ? u : [u], c), u;
        })),
      (i.default = l),
      (n.exports = i.default);
  });
})(Bu, Bu.exports);
var M1 = Bu.exports,
  Qa =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (Qa =
          Object.assign ||
          function (t) {
            for (var e, n = 1, i = arguments.length; n < i; n++) {
              e = arguments[n];
              for (var r in e)
                Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
            }
            return t;
          }),
        Qa.apply(this, arguments)
      );
    },
  zu = function () {
    return (
      typeof window != "undefined" &&
      !!window.document &&
      !!window.document.createElement
    );
  },
  L_ = (function () {
    function t() {
      var e = this;
      (this.handleWheel = function (n) {
        n.preventDefault();
      }),
        (this.handleScroll = function () {
          window.scrollTo.apply(window, e.lockToScrollPos);
        }),
        (this.handleKeydown = function (n) {
          var i = e.options.keyboardKeys;
          ["INPUT", "TEXTAREA"].includes(n.target.tagName) &&
            (i = i.filter(function (r) {
              return !e.options.authorizedInInputs.includes(r);
            })),
            i.includes(n.keyCode) && n.preventDefault();
        }),
        (this.element = null),
        (this.lockToScrollPos = [0, 0]),
        (this.options = {
          authorizedInInputs: [32, 37, 38, 39, 40],
          disableKeys: !0,
          disableScroll: !0,
          disableWheel: !0,
          keyboardKeys: [32, 33, 34, 35, 36, 37, 38, 39, 40],
        }),
        zu() && (this.element = document.scrollingElement);
    }
    return (
      (t.prototype.on = function (e, n) {
        var i, r, s, o;
        if (!!zu()) {
          (this.element = e || this.element),
            (this.options = Qa(Qa({}, this.options), n));
          var a = this.options,
            c = a.disableKeys,
            l = a.disableScroll,
            u = a.disableWheel;
          u &&
            (document.addEventListener("wheel", this.handleWheel, {
              passive: !1,
            }),
            document.addEventListener("touchmove", this.handleWheel, {
              passive: !1,
            })),
            l &&
              ((this.lockToScrollPos = [
                (r =
                  (i = this.element) === null || i === void 0
                    ? void 0
                    : i.scrollLeft) !== null && r !== void 0
                  ? r
                  : 0,
                (o =
                  (s = this.element) === null || s === void 0
                    ? void 0
                    : s.scrollTop) !== null && o !== void 0
                  ? o
                  : 0,
              ]),
              document.addEventListener("scroll", this.handleScroll, {
                passive: !1,
              })),
            c &&
              document.addEventListener("keydown", this.handleKeydown, {
                passive: !1,
              });
        }
      }),
      (t.prototype.off = function () {
        !zu() ||
          (document.removeEventListener("wheel", this.handleWheel),
          document.removeEventListener("touchmove", this.handleWheel),
          document.removeEventListener("scroll", this.handleScroll),
          document.removeEventListener("keydown", this.handleKeydown));
      }),
      t
    );
  })(),
  S1 = new L_();
Number.EPSILON === void 0 && (Number.EPSILON = Math.pow(2, -52));
Number.isInteger === void 0 &&
  (Number.isInteger = function (t) {
    return typeof t == "number" && isFinite(t) && Math.floor(t) === t;
  });
Math.sign === void 0 &&
  (Math.sign = function (t) {
    return t < 0 ? -1 : t > 0 ? 1 : +t;
  });
"name" in Function.prototype ||
  Object.defineProperty(Function.prototype, "name", {
    get: function () {
      return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
    },
  });
Object.assign === void 0 &&
  (Object.assign = function (t) {
    if (t == null)
      throw new TypeError("Cannot convert undefined or null to object");
    const e = Object(t);
    for (let n = 1; n < arguments.length; n++) {
      const i = arguments[n];
      if (i != null)
        for (const r in i)
          Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r]);
    }
    return e;
  });
const P_ = "118",
  C_ = 0,
  mp = 1,
  R_ = 2,
  gp = 1,
  O_ = 2,
  fo = 3,
  po = 0,
  Ee = 1,
  Ka = 2,
  yp = 1,
  mo = 0,
  go = 1,
  _p = 2,
  xp = 3,
  vp = 4,
  D_ = 5,
  Kr = 100,
  I_ = 101,
  N_ = 102,
  bp = 103,
  wp = 104,
  F_ = 200,
  B_ = 201,
  z_ = 202,
  U_ = 203,
  Mp = 204,
  Sp = 205,
  k_ = 206,
  G_ = 207,
  H_ = 208,
  V_ = 209,
  W_ = 210,
  j_ = 0,
  q_ = 1,
  X_ = 2,
  Uu = 3,
  Y_ = 4,
  Z_ = 5,
  J_ = 6,
  $_ = 7,
  tc = 0,
  Q_ = 1,
  K_ = 2,
  yo = 0,
  t0 = 1,
  e0 = 2,
  n0 = 3,
  i0 = 4,
  r0 = 5,
  ku = 300,
  Gu = 301,
  Hu = 302,
  Tp = 303,
  Vu = 304,
  ec = 306,
  Wu = 307,
  nc = 1e3,
  Ze = 1001,
  ic = 1002,
  De = 1003,
  ju = 1004,
  qu = 1005,
  Ie = 1006,
  Ep = 1007,
  rc = 1008,
  Xu = 1009,
  s0 = 1010,
  o0 = 1011,
  sc = 1012,
  a0 = 1013,
  oc = 1014,
  Pi = 1015,
  ac = 1016,
  c0 = 1017,
  l0 = 1018,
  u0 = 1019,
  _o = 1020,
  h0 = 1021,
  ar = 1022,
  Gn = 1023,
  f0 = 1024,
  d0 = 1025,
  ts = 1026,
  xo = 1027,
  p0 = 1028,
  m0 = 1029,
  g0 = 1030,
  y0 = 1031,
  _0 = 1032,
  x0 = 1033,
  Ap = 33776,
  Lp = 33777,
  Pp = 33778,
  Cp = 33779,
  Rp = 35840,
  Op = 35841,
  Dp = 35842,
  Ip = 35843,
  v0 = 36196,
  Np = 37492,
  Fp = 37496,
  b0 = 37808,
  w0 = 37809,
  M0 = 37810,
  S0 = 37811,
  T0 = 37812,
  E0 = 37813,
  A0 = 37814,
  L0 = 37815,
  P0 = 37816,
  C0 = 37817,
  R0 = 37818,
  O0 = 37819,
  D0 = 37820,
  I0 = 37821,
  N0 = 36492,
  F0 = 37840,
  B0 = 37841,
  z0 = 37842,
  U0 = 37843,
  k0 = 37844,
  G0 = 37845,
  H0 = 37846,
  V0 = 37847,
  W0 = 37848,
  j0 = 37849,
  q0 = 37850,
  X0 = 37851,
  Y0 = 37852,
  Z0 = 37853,
  J0 = 2200,
  $0 = 2201,
  Q0 = 2202,
  cc = 2300,
  lc = 2301,
  Yu = 2302,
  es = 2400,
  ns = 2401,
  uc = 2402,
  Zu = 2500,
  Bp = 2501,
  K0 = 0,
  vo = 3e3,
  zp = 3001,
  tx = 3007,
  ex = 3002,
  nx = 3003,
  ix = 3004,
  rx = 3005,
  sx = 3006,
  ox = 3200,
  ax = 3201,
  is = 0,
  cx = 1,
  Ju = 7680,
  lx = 519,
  hc = 35044,
  bo = 35048;
function si() {}
Object.assign(si.prototype, {
  addEventListener: function (t, e) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[t] === void 0 && (n[t] = []), n[t].indexOf(e) === -1 && n[t].push(e);
  },
  hasEventListener: function (t, e) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[t] !== void 0 && n[t].indexOf(e) !== -1;
  },
  removeEventListener: function (t, e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[t];
    if (i !== void 0) {
      const r = i.indexOf(e);
      r !== -1 && i.splice(r, 1);
    }
  },
  dispatchEvent: function (t) {
    if (this._listeners === void 0) return;
    const n = this._listeners[t.type];
    if (n !== void 0) {
      t.target = this;
      const i = n.slice(0);
      for (let r = 0, s = i.length; r < s; r++) i[r].call(this, t);
    }
  },
});
const Ce = [];
for (let t = 0; t < 256; t++) Ce[t] = (t < 16 ? "0" : "") + t.toString(16);
const Pt = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function () {
    const t = (Math.random() * 4294967295) | 0,
      e = (Math.random() * 4294967295) | 0,
      n = (Math.random() * 4294967295) | 0,
      i = (Math.random() * 4294967295) | 0;
    return (
      Ce[t & 255] +
      Ce[(t >> 8) & 255] +
      Ce[(t >> 16) & 255] +
      Ce[(t >> 24) & 255] +
      "-" +
      Ce[e & 255] +
      Ce[(e >> 8) & 255] +
      "-" +
      Ce[((e >> 16) & 15) | 64] +
      Ce[(e >> 24) & 255] +
      "-" +
      Ce[(n & 63) | 128] +
      Ce[(n >> 8) & 255] +
      "-" +
      Ce[(n >> 16) & 255] +
      Ce[(n >> 24) & 255] +
      Ce[i & 255] +
      Ce[(i >> 8) & 255] +
      Ce[(i >> 16) & 255] +
      Ce[(i >> 24) & 255]
    ).toUpperCase();
  },
  clamp: function (t, e, n) {
    return Math.max(e, Math.min(n, t));
  },
  euclideanModulo: function (t, e) {
    return ((t % e) + e) % e;
  },
  mapLinear: function (t, e, n, i, r) {
    return i + ((t - e) * (r - i)) / (n - e);
  },
  lerp: function (t, e, n) {
    return (1 - n) * t + n * e;
  },
  smoothstep: function (t, e, n) {
    return t <= e
      ? 0
      : t >= n
      ? 1
      : ((t = (t - e) / (n - e)), t * t * (3 - 2 * t));
  },
  smootherstep: function (t, e, n) {
    return t <= e
      ? 0
      : t >= n
      ? 1
      : ((t = (t - e) / (n - e)), t * t * t * (t * (t * 6 - 15) + 10));
  },
  randInt: function (t, e) {
    return t + Math.floor(Math.random() * (e - t + 1));
  },
  randFloat: function (t, e) {
    return t + Math.random() * (e - t);
  },
  randFloatSpread: function (t) {
    return t * (0.5 - Math.random());
  },
  degToRad: function (t) {
    return t * Pt.DEG2RAD;
  },
  radToDeg: function (t) {
    return t * Pt.RAD2DEG;
  },
  isPowerOfTwo: function (t) {
    return (t & (t - 1)) == 0 && t !== 0;
  },
  ceilPowerOfTwo: function (t) {
    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
  },
  floorPowerOfTwo: function (t) {
    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
  },
  setQuaternionFromProperEuler: function (t, e, n, i, r) {
    const s = Math.cos,
      o = Math.sin,
      a = s(n / 2),
      c = o(n / 2),
      l = s((e + i) / 2),
      u = o((e + i) / 2),
      h = s((e - i) / 2),
      d = o((e - i) / 2),
      f = s((i - e) / 2),
      p = o((i - e) / 2);
    switch (r) {
      case "XYX":
        t.set(a * u, c * h, c * d, a * l);
        break;
      case "YZY":
        t.set(c * d, a * u, c * h, a * l);
        break;
      case "ZXZ":
        t.set(c * h, c * d, a * u, a * l);
        break;
      case "XZX":
        t.set(a * u, c * p, c * f, a * l);
        break;
      case "YXY":
        t.set(c * f, a * u, c * p, a * l);
        break;
      case "ZYZ":
        t.set(c * p, c * f, a * u, a * l);
        break;
      default:
        console.warn(
          "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
            r
        );
    }
  },
};
function H(t = 0, e = 0) {
  (this.x = t), (this.y = e);
}
Object.defineProperties(H.prototype, {
  width: {
    get: function () {
      return this.x;
    },
    set: function (t) {
      this.x = t;
    },
  },
  height: {
    get: function () {
      return this.y;
    },
    set: function (t) {
      this.y = t;
    },
  },
});
Object.assign(H.prototype, {
  isVector2: !0,
  set: function (t, e) {
    return (this.x = t), (this.y = e), this;
  },
  setScalar: function (t) {
    return (this.x = t), (this.y = t), this;
  },
  setX: function (t) {
    return (this.x = t), this;
  },
  setY: function (t) {
    return (this.y = t), this;
  },
  setComponent: function (t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  },
  getComponent: function (t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + t);
    }
  },
  clone: function () {
    return new this.constructor(this.x, this.y);
  },
  copy: function (t) {
    return (this.x = t.x), (this.y = t.y), this;
  },
  add: function (t, e) {
    return e !== void 0
      ? (console.warn(
          "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
        ),
        this.addVectors(t, e))
      : ((this.x += t.x), (this.y += t.y), this);
  },
  addScalar: function (t) {
    return (this.x += t), (this.y += t), this;
  },
  addVectors: function (t, e) {
    return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
  },
  addScaledVector: function (t, e) {
    return (this.x += t.x * e), (this.y += t.y * e), this;
  },
  sub: function (t, e) {
    return e !== void 0
      ? (console.warn(
          "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
        ),
        this.subVectors(t, e))
      : ((this.x -= t.x), (this.y -= t.y), this);
  },
  subScalar: function (t) {
    return (this.x -= t), (this.y -= t), this;
  },
  subVectors: function (t, e) {
    return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
  },
  multiply: function (t) {
    return (this.x *= t.x), (this.y *= t.y), this;
  },
  multiplyScalar: function (t) {
    return (this.x *= t), (this.y *= t), this;
  },
  divide: function (t) {
    return (this.x /= t.x), (this.y /= t.y), this;
  },
  divideScalar: function (t) {
    return this.multiplyScalar(1 / t);
  },
  applyMatrix3: function (t) {
    const e = this.x,
      n = this.y,
      i = t.elements;
    return (
      (this.x = i[0] * e + i[3] * n + i[6]),
      (this.y = i[1] * e + i[4] * n + i[7]),
      this
    );
  },
  min: function (t) {
    return (
      (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this
    );
  },
  max: function (t) {
    return (
      (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this
    );
  },
  clamp: function (t, e) {
    return (
      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
      this
    );
  },
  clampScalar: function (t, e) {
    return (
      (this.x = Math.max(t, Math.min(e, this.x))),
      (this.y = Math.max(t, Math.min(e, this.y))),
      this
    );
  },
  clampLength: function (t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(t, Math.min(e, n))
    );
  },
  floor: function () {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  },
  ceil: function () {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  },
  round: function () {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  },
  roundToZero: function () {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      this
    );
  },
  negate: function () {
    return (this.x = -this.x), (this.y = -this.y), this;
  },
  dot: function (t) {
    return this.x * t.x + this.y * t.y;
  },
  cross: function (t) {
    return this.x * t.y - this.y * t.x;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  manhattanLength: function () {
    return Math.abs(this.x) + Math.abs(this.y);
  },
  normalize: function () {
    return this.divideScalar(this.length() || 1);
  },
  angle: function () {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  },
  distanceTo: function (t) {
    return Math.sqrt(this.distanceToSquared(t));
  },
  distanceToSquared: function (t) {
    const e = this.x - t.x,
      n = this.y - t.y;
    return e * e + n * n;
  },
  manhattanDistanceTo: function (t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
  },
  setLength: function (t) {
    return this.normalize().multiplyScalar(t);
  },
  lerp: function (t, e) {
    return (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this;
  },
  lerpVectors: function (t, e, n) {
    return (
      (this.x = t.x + (e.x - t.x) * n), (this.y = t.y + (e.y - t.y) * n), this
    );
  },
  equals: function (t) {
    return t.x === this.x && t.y === this.y;
  },
  fromArray: function (t, e) {
    return e === void 0 && (e = 0), (this.x = t[e]), (this.y = t[e + 1]), this;
  },
  toArray: function (t, e) {
    return (
      t === void 0 && (t = []),
      e === void 0 && (e = 0),
      (t[e] = this.x),
      (t[e + 1] = this.y),
      t
    );
  },
  fromBufferAttribute: function (t, e, n) {
    return (
      n !== void 0 &&
        console.warn(
          "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
        ),
      (this.x = t.getX(e)),
      (this.y = t.getY(e)),
      this
    );
  },
  rotateAround: function (t, e) {
    const n = Math.cos(e),
      i = Math.sin(e),
      r = this.x - t.x,
      s = this.y - t.y;
    return (this.x = r * n - s * i + t.x), (this.y = r * i + s * n + t.y), this;
  },
  random: function () {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  },
});
function Ge() {
  (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
    arguments.length > 0 &&
      console.error(
        "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
      );
}
Object.assign(Ge.prototype, {
  isMatrix3: !0,
  set: function (t, e, n, i, r, s, o, a, c) {
    const l = this.elements;
    return (
      (l[0] = t),
      (l[1] = i),
      (l[2] = o),
      (l[3] = e),
      (l[4] = r),
      (l[5] = a),
      (l[6] = n),
      (l[7] = s),
      (l[8] = c),
      this
    );
  },
  identity: function () {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  },
  clone: function () {
    return new this.constructor().fromArray(this.elements);
  },
  copy: function (t) {
    const e = this.elements,
      n = t.elements;
    return (
      (e[0] = n[0]),
      (e[1] = n[1]),
      (e[2] = n[2]),
      (e[3] = n[3]),
      (e[4] = n[4]),
      (e[5] = n[5]),
      (e[6] = n[6]),
      (e[7] = n[7]),
      (e[8] = n[8]),
      this
    );
  },
  extractBasis: function (t, e, n) {
    return (
      t.setFromMatrix3Column(this, 0),
      e.setFromMatrix3Column(this, 1),
      n.setFromMatrix3Column(this, 2),
      this
    );
  },
  setFromMatrix4: function (t) {
    const e = t.elements;
    return (
      this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
    );
  },
  multiply: function (t) {
    return this.multiplyMatrices(this, t);
  },
  premultiply: function (t) {
    return this.multiplyMatrices(t, this);
  },
  multiplyMatrices: function (t, e) {
    const n = t.elements,
      i = e.elements,
      r = this.elements,
      s = n[0],
      o = n[3],
      a = n[6],
      c = n[1],
      l = n[4],
      u = n[7],
      h = n[2],
      d = n[5],
      f = n[8],
      p = i[0],
      _ = i[3],
      y = i[6],
      m = i[1],
      g = i[4],
      b = i[7],
      x = i[2],
      v = i[5],
      w = i[8];
    return (
      (r[0] = s * p + o * m + a * x),
      (r[3] = s * _ + o * g + a * v),
      (r[6] = s * y + o * b + a * w),
      (r[1] = c * p + l * m + u * x),
      (r[4] = c * _ + l * g + u * v),
      (r[7] = c * y + l * b + u * w),
      (r[2] = h * p + d * m + f * x),
      (r[5] = h * _ + d * g + f * v),
      (r[8] = h * y + d * b + f * w),
      this
    );
  },
  multiplyScalar: function (t) {
    const e = this.elements;
    return (
      (e[0] *= t),
      (e[3] *= t),
      (e[6] *= t),
      (e[1] *= t),
      (e[4] *= t),
      (e[7] *= t),
      (e[2] *= t),
      (e[5] *= t),
      (e[8] *= t),
      this
    );
  },
  determinant: function () {
    const t = this.elements,
      e = t[0],
      n = t[1],
      i = t[2],
      r = t[3],
      s = t[4],
      o = t[5],
      a = t[6],
      c = t[7],
      l = t[8];
    return (
      e * s * l - e * o * c - n * r * l + n * o * a + i * r * c - i * s * a
    );
  },
  getInverse: function (t, e) {
    e !== void 0 &&
      console.warn(
        "THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate."
      );
    const n = t.elements,
      i = this.elements,
      r = n[0],
      s = n[1],
      o = n[2],
      a = n[3],
      c = n[4],
      l = n[5],
      u = n[6],
      h = n[7],
      d = n[8],
      f = d * c - l * h,
      p = l * u - d * a,
      _ = h * a - c * u,
      y = r * f + s * p + o * _;
    if (y === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const m = 1 / y;
    return (
      (i[0] = f * m),
      (i[1] = (o * h - d * s) * m),
      (i[2] = (l * s - o * c) * m),
      (i[3] = p * m),
      (i[4] = (d * r - o * u) * m),
      (i[5] = (o * a - l * r) * m),
      (i[6] = _ * m),
      (i[7] = (s * u - h * r) * m),
      (i[8] = (c * r - s * a) * m),
      this
    );
  },
  transpose: function () {
    let t;
    const e = this.elements;
    return (
      (t = e[1]),
      (e[1] = e[3]),
      (e[3] = t),
      (t = e[2]),
      (e[2] = e[6]),
      (e[6] = t),
      (t = e[5]),
      (e[5] = e[7]),
      (e[7] = t),
      this
    );
  },
  getNormalMatrix: function (t) {
    return this.setFromMatrix4(t).getInverse(this).transpose();
  },
  transposeIntoArray: function (t) {
    const e = this.elements;
    return (
      (t[0] = e[0]),
      (t[1] = e[3]),
      (t[2] = e[6]),
      (t[3] = e[1]),
      (t[4] = e[4]),
      (t[5] = e[7]),
      (t[6] = e[2]),
      (t[7] = e[5]),
      (t[8] = e[8]),
      this
    );
  },
  setUvTransform: function (t, e, n, i, r, s, o) {
    const a = Math.cos(r),
      c = Math.sin(r);
    this.set(
      n * a,
      n * c,
      -n * (a * s + c * o) + s + t,
      -i * c,
      i * a,
      -i * (-c * s + a * o) + o + e,
      0,
      0,
      1
    );
  },
  scale: function (t, e) {
    const n = this.elements;
    return (
      (n[0] *= t),
      (n[3] *= t),
      (n[6] *= t),
      (n[1] *= e),
      (n[4] *= e),
      (n[7] *= e),
      this
    );
  },
  rotate: function (t) {
    const e = Math.cos(t),
      n = Math.sin(t),
      i = this.elements,
      r = i[0],
      s = i[3],
      o = i[6],
      a = i[1],
      c = i[4],
      l = i[7];
    return (
      (i[0] = e * r + n * a),
      (i[3] = e * s + n * c),
      (i[6] = e * o + n * l),
      (i[1] = -n * r + e * a),
      (i[4] = -n * s + e * c),
      (i[7] = -n * o + e * l),
      this
    );
  },
  translate: function (t, e) {
    const n = this.elements;
    return (
      (n[0] += t * n[2]),
      (n[3] += t * n[5]),
      (n[6] += t * n[8]),
      (n[1] += e * n[2]),
      (n[4] += e * n[5]),
      (n[7] += e * n[8]),
      this
    );
  },
  equals: function (t) {
    const e = this.elements,
      n = t.elements;
    for (let i = 0; i < 9; i++) if (e[i] !== n[i]) return !1;
    return !0;
  },
  fromArray: function (t, e) {
    e === void 0 && (e = 0);
    for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
    return this;
  },
  toArray: function (t, e) {
    t === void 0 && (t = []), e === void 0 && (e = 0);
    const n = this.elements;
    return (
      (t[e] = n[0]),
      (t[e + 1] = n[1]),
      (t[e + 2] = n[2]),
      (t[e + 3] = n[3]),
      (t[e + 4] = n[4]),
      (t[e + 5] = n[5]),
      (t[e + 6] = n[6]),
      (t[e + 7] = n[7]),
      (t[e + 8] = n[8]),
      t
    );
  },
});
let rs;
const cr = {
  getDataURL: function (t) {
    if (/^data:/i.test(t.src) || typeof HTMLCanvasElement == "undefined")
      return t.src;
    let e;
    if (t instanceof HTMLCanvasElement) e = t;
    else {
      rs === void 0 &&
        (rs = document.createElementNS(
          "http://www.w3.org/1999/xhtml",
          "canvas"
        )),
        (rs.width = t.width),
        (rs.height = t.height);
      const n = rs.getContext("2d");
      t instanceof ImageData
        ? n.putImageData(t, 0, 0)
        : n.drawImage(t, 0, 0, t.width, t.height),
        (e = rs);
    }
    return e.width > 2048 || e.height > 2048
      ? e.toDataURL("image/jpeg", 0.6)
      : e.toDataURL("image/png");
  },
};
let ux = 0;
function Jt(t, e, n, i, r, s, o, a, c, l) {
  Object.defineProperty(this, "id", { value: ux++ }),
    (this.uuid = Pt.generateUUID()),
    (this.name = ""),
    (this.image = t !== void 0 ? t : Jt.DEFAULT_IMAGE),
    (this.mipmaps = []),
    (this.mapping = e !== void 0 ? e : Jt.DEFAULT_MAPPING),
    (this.wrapS = n !== void 0 ? n : Ze),
    (this.wrapT = i !== void 0 ? i : Ze),
    (this.magFilter = r !== void 0 ? r : Ie),
    (this.minFilter = s !== void 0 ? s : rc),
    (this.anisotropy = c !== void 0 ? c : 1),
    (this.format = o !== void 0 ? o : Gn),
    (this.internalFormat = null),
    (this.type = a !== void 0 ? a : Xu),
    (this.offset = new H(0, 0)),
    (this.repeat = new H(1, 1)),
    (this.center = new H(0, 0)),
    (this.rotation = 0),
    (this.matrixAutoUpdate = !0),
    (this.matrix = new Ge()),
    (this.generateMipmaps = !0),
    (this.premultiplyAlpha = !1),
    (this.flipY = !0),
    (this.unpackAlignment = 4),
    (this.encoding = l !== void 0 ? l : vo),
    (this.version = 0),
    (this.onUpdate = null);
}
Jt.DEFAULT_IMAGE = void 0;
Jt.DEFAULT_MAPPING = ku;
Jt.prototype = Object.assign(Object.create(si.prototype), {
  constructor: Jt,
  isTexture: !0,
  updateMatrix: function () {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return (
      (this.name = t.name),
      (this.image = t.image),
      (this.mipmaps = t.mipmaps.slice(0)),
      (this.mapping = t.mapping),
      (this.wrapS = t.wrapS),
      (this.wrapT = t.wrapT),
      (this.magFilter = t.magFilter),
      (this.minFilter = t.minFilter),
      (this.anisotropy = t.anisotropy),
      (this.format = t.format),
      (this.internalFormat = t.internalFormat),
      (this.type = t.type),
      this.offset.copy(t.offset),
      this.repeat.copy(t.repeat),
      this.center.copy(t.center),
      (this.rotation = t.rotation),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      this.matrix.copy(t.matrix),
      (this.generateMipmaps = t.generateMipmaps),
      (this.premultiplyAlpha = t.premultiplyAlpha),
      (this.flipY = t.flipY),
      (this.unpackAlignment = t.unpackAlignment),
      (this.encoding = t.encoding),
      this
    );
  },
  toJSON: function (t) {
    const e = t === void 0 || typeof t == "string";
    if (!e && t.textures[this.uuid] !== void 0) return t.textures[this.uuid];
    const n = {
      metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    if (this.image !== void 0) {
      const i = this.image;
      if (
        (i.uuid === void 0 && (i.uuid = Pt.generateUUID()),
        !e && t.images[i.uuid] === void 0)
      ) {
        let r;
        if (Array.isArray(i)) {
          r = [];
          for (let s = 0, o = i.length; s < o; s++) r.push(cr.getDataURL(i[s]));
        } else r = cr.getDataURL(i);
        t.images[i.uuid] = { uuid: i.uuid, url: r };
      }
      n.image = i.uuid;
    }
    return e || (t.textures[this.uuid] = n), n;
  },
  dispose: function () {
    this.dispatchEvent({ type: "dispose" });
  },
  transformUv: function (t) {
    if (this.mapping !== ku) return t;
    if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
      switch (this.wrapS) {
        case nc:
          t.x = t.x - Math.floor(t.x);
          break;
        case Ze:
          t.x = t.x < 0 ? 0 : 1;
          break;
        case ic:
          Math.abs(Math.floor(t.x) % 2) === 1
            ? (t.x = Math.ceil(t.x) - t.x)
            : (t.x = t.x - Math.floor(t.x));
          break;
      }
    if (t.y < 0 || t.y > 1)
      switch (this.wrapT) {
        case nc:
          t.y = t.y - Math.floor(t.y);
          break;
        case Ze:
          t.y = t.y < 0 ? 0 : 1;
          break;
        case ic:
          Math.abs(Math.floor(t.y) % 2) === 1
            ? (t.y = Math.ceil(t.y) - t.y)
            : (t.y = t.y - Math.floor(t.y));
          break;
      }
    return this.flipY && (t.y = 1 - t.y), t;
  },
});
Object.defineProperty(Jt.prototype, "needsUpdate", {
  set: function (t) {
    t === !0 && this.version++;
  },
});
function Vt(t = 0, e = 0, n = 0, i = 1) {
  (this.x = t), (this.y = e), (this.z = n), (this.w = i);
}
Object.defineProperties(Vt.prototype, {
  width: {
    get: function () {
      return this.z;
    },
    set: function (t) {
      this.z = t;
    },
  },
  height: {
    get: function () {
      return this.w;
    },
    set: function (t) {
      this.w = t;
    },
  },
});
Object.assign(Vt.prototype, {
  isVector4: !0,
  set: function (t, e, n, i) {
    return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
  },
  setScalar: function (t) {
    return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
  },
  setX: function (t) {
    return (this.x = t), this;
  },
  setY: function (t) {
    return (this.y = t), this;
  },
  setZ: function (t) {
    return (this.z = t), this;
  },
  setW: function (t) {
    return (this.w = t), this;
  },
  setComponent: function (t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      case 3:
        this.w = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  },
  getComponent: function (t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + t);
    }
  },
  clone: function () {
    return new this.constructor(this.x, this.y, this.z, this.w);
  },
  copy: function (t) {
    return (
      (this.x = t.x),
      (this.y = t.y),
      (this.z = t.z),
      (this.w = t.w !== void 0 ? t.w : 1),
      this
    );
  },
  add: function (t, e) {
    return e !== void 0
      ? (console.warn(
          "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
        ),
        this.addVectors(t, e))
      : ((this.x += t.x),
        (this.y += t.y),
        (this.z += t.z),
        (this.w += t.w),
        this);
  },
  addScalar: function (t) {
    return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this;
  },
  addVectors: function (t, e) {
    return (
      (this.x = t.x + e.x),
      (this.y = t.y + e.y),
      (this.z = t.z + e.z),
      (this.w = t.w + e.w),
      this
    );
  },
  addScaledVector: function (t, e) {
    return (
      (this.x += t.x * e),
      (this.y += t.y * e),
      (this.z += t.z * e),
      (this.w += t.w * e),
      this
    );
  },
  sub: function (t, e) {
    return e !== void 0
      ? (console.warn(
          "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
        ),
        this.subVectors(t, e))
      : ((this.x -= t.x),
        (this.y -= t.y),
        (this.z -= t.z),
        (this.w -= t.w),
        this);
  },
  subScalar: function (t) {
    return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this;
  },
  subVectors: function (t, e) {
    return (
      (this.x = t.x - e.x),
      (this.y = t.y - e.y),
      (this.z = t.z - e.z),
      (this.w = t.w - e.w),
      this
    );
  },
  multiplyScalar: function (t) {
    return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this;
  },
  applyMatrix4: function (t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      r = this.w,
      s = t.elements;
    return (
      (this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r),
      (this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r),
      (this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r),
      (this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r),
      this
    );
  },
  divideScalar: function (t) {
    return this.multiplyScalar(1 / t);
  },
  setAxisAngleFromQuaternion: function (t) {
    this.w = 2 * Math.acos(t.w);
    const e = Math.sqrt(1 - t.w * t.w);
    return (
      e < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
      this
    );
  },
  setAxisAngleFromRotationMatrix: function (t) {
    let e, n, i, r;
    const s = 0.01,
      o = 0.1,
      a = t.elements,
      c = a[0],
      l = a[4],
      u = a[8],
      h = a[1],
      d = a[5],
      f = a[9],
      p = a[2],
      _ = a[6],
      y = a[10];
    if (Math.abs(l - h) < s && Math.abs(u - p) < s && Math.abs(f - _) < s) {
      if (
        Math.abs(l + h) < o &&
        Math.abs(u + p) < o &&
        Math.abs(f + _) < o &&
        Math.abs(c + d + y - 3) < o
      )
        return this.set(1, 0, 0, 0), this;
      e = Math.PI;
      const g = (c + 1) / 2,
        b = (d + 1) / 2,
        x = (y + 1) / 2,
        v = (l + h) / 4,
        w = (u + p) / 4,
        M = (f + _) / 4;
      return (
        g > b && g > x
          ? g < s
            ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
            : ((n = Math.sqrt(g)), (i = v / n), (r = w / n))
          : b > x
          ? b < s
            ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
            : ((i = Math.sqrt(b)), (n = v / i), (r = M / i))
          : x < s
          ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
          : ((r = Math.sqrt(x)), (n = w / r), (i = M / r)),
        this.set(n, i, r, e),
        this
      );
    }
    let m = Math.sqrt(
      (_ - f) * (_ - f) + (u - p) * (u - p) + (h - l) * (h - l)
    );
    return (
      Math.abs(m) < 0.001 && (m = 1),
      (this.x = (_ - f) / m),
      (this.y = (u - p) / m),
      (this.z = (h - l) / m),
      (this.w = Math.acos((c + d + y - 1) / 2)),
      this
    );
  },
  min: function (t) {
    return (
      (this.x = Math.min(this.x, t.x)),
      (this.y = Math.min(this.y, t.y)),
      (this.z = Math.min(this.z, t.z)),
      (this.w = Math.min(this.w, t.w)),
      this
    );
  },
  max: function (t) {
    return (
      (this.x = Math.max(this.x, t.x)),
      (this.y = Math.max(this.y, t.y)),
      (this.z = Math.max(this.z, t.z)),
      (this.w = Math.max(this.w, t.w)),
      this
    );
  },
  clamp: function (t, e) {
    return (
      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
      (this.z = Math.max(t.z, Math.min(e.z, this.z))),
      (this.w = Math.max(t.w, Math.min(e.w, this.w))),
      this
    );
  },
  clampScalar: function (t, e) {
    return (
      (this.x = Math.max(t, Math.min(e, this.x))),
      (this.y = Math.max(t, Math.min(e, this.y))),
      (this.z = Math.max(t, Math.min(e, this.z))),
      (this.w = Math.max(t, Math.min(e, this.w))),
      this
    );
  },
  clampLength: function (t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(t, Math.min(e, n))
    );
  },
  floor: function () {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  },
  ceil: function () {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  },
  round: function () {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  },
  roundToZero: function () {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
      this
    );
  },
  negate: function () {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  },
  dot: function (t) {
    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
  },
  lengthSq: function () {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  },
  length: function () {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  },
  manhattanLength: function () {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  },
  normalize: function () {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function (t) {
    return this.normalize().multiplyScalar(t);
  },
  lerp: function (t, e) {
    return (
      (this.x += (t.x - this.x) * e),
      (this.y += (t.y - this.y) * e),
      (this.z += (t.z - this.z) * e),
      (this.w += (t.w - this.w) * e),
      this
    );
  },
  lerpVectors: function (t, e, n) {
    return (
      (this.x = t.x + (e.x - t.x) * n),
      (this.y = t.y + (e.y - t.y) * n),
      (this.z = t.z + (e.z - t.z) * n),
      (this.w = t.w + (e.w - t.w) * n),
      this
    );
  },
  equals: function (t) {
    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
  },
  fromArray: function (t, e) {
    return (
      e === void 0 && (e = 0),
      (this.x = t[e]),
      (this.y = t[e + 1]),
      (this.z = t[e + 2]),
      (this.w = t[e + 3]),
      this
    );
  },
  toArray: function (t, e) {
    return (
      t === void 0 && (t = []),
      e === void 0 && (e = 0),
      (t[e] = this.x),
      (t[e + 1] = this.y),
      (t[e + 2] = this.z),
      (t[e + 3] = this.w),
      t
    );
  },
  fromBufferAttribute: function (t, e, n) {
    return (
      n !== void 0 &&
        console.warn(
          "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
        ),
      (this.x = t.getX(e)),
      (this.y = t.getY(e)),
      (this.z = t.getZ(e)),
      (this.w = t.getW(e)),
      this
    );
  },
  random: function () {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  },
});
function Sn(t, e, n) {
  (this.width = t),
    (this.height = e),
    (this.scissor = new Vt(0, 0, t, e)),
    (this.scissorTest = !1),
    (this.viewport = new Vt(0, 0, t, e)),
    (n = n || {}),
    (this.texture = new Jt(
      void 0,
      n.mapping,
      n.wrapS,
      n.wrapT,
      n.magFilter,
      n.minFilter,
      n.format,
      n.type,
      n.anisotropy,
      n.encoding
    )),
    (this.texture.image = {}),
    (this.texture.image.width = t),
    (this.texture.image.height = e),
    (this.texture.generateMipmaps =
      n.generateMipmaps !== void 0 ? n.generateMipmaps : !1),
    (this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : Ie),
    (this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0),
    (this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : !0),
    (this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null);
}
Sn.prototype = Object.assign(Object.create(si.prototype), {
  constructor: Sn,
  isWebGLRenderTarget: !0,
  setSize: function (t, e) {
    (this.width !== t || this.height !== e) &&
      ((this.width = t),
      (this.height = e),
      (this.texture.image.width = t),
      (this.texture.image.height = e),
      this.dispose()),
      this.viewport.set(0, 0, t, e),
      this.scissor.set(0, 0, t, e);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return (
      (this.width = t.width),
      (this.height = t.height),
      this.viewport.copy(t.viewport),
      (this.texture = t.texture.clone()),
      (this.depthBuffer = t.depthBuffer),
      (this.stencilBuffer = t.stencilBuffer),
      (this.depthTexture = t.depthTexture),
      this
    );
  },
  dispose: function () {
    this.dispatchEvent({ type: "dispose" });
  },
});
function Up(t, e, n) {
  Sn.call(this, t, e, n), (this.samples = 4);
}
Up.prototype = Object.assign(Object.create(Sn.prototype), {
  constructor: Up,
  isWebGLMultisampleRenderTarget: !0,
  copy: function (t) {
    return Sn.prototype.copy.call(this, t), (this.samples = t.samples), this;
  },
});
function Ae(t = 0, e = 0, n = 0, i = 1) {
  (this._x = t), (this._y = e), (this._z = n), (this._w = i);
}
Object.assign(Ae, {
  slerp: function (t, e, n, i) {
    return n.copy(t).slerp(e, i);
  },
  slerpFlat: function (t, e, n, i, r, s, o) {
    let a = n[i + 0],
      c = n[i + 1],
      l = n[i + 2],
      u = n[i + 3];
    const h = r[s + 0],
      d = r[s + 1],
      f = r[s + 2],
      p = r[s + 3];
    if (u !== p || a !== h || c !== d || l !== f) {
      let _ = 1 - o,
        y = a * h + c * d + l * f + u * p,
        m = y >= 0 ? 1 : -1,
        g = 1 - y * y;
      if (g > Number.EPSILON) {
        const x = Math.sqrt(g),
          v = Math.atan2(x, y * m);
        (_ = Math.sin(_ * v) / x), (o = Math.sin(o * v) / x);
      }
      const b = o * m;
      if (
        ((a = a * _ + h * b),
        (c = c * _ + d * b),
        (l = l * _ + f * b),
        (u = u * _ + p * b),
        _ === 1 - o)
      ) {
        const x = 1 / Math.sqrt(a * a + c * c + l * l + u * u);
        (a *= x), (c *= x), (l *= x), (u *= x);
      }
    }
    (t[e] = a), (t[e + 1] = c), (t[e + 2] = l), (t[e + 3] = u);
  },
  multiplyQuaternionsFlat: function (t, e, n, i, r, s) {
    const o = n[i],
      a = n[i + 1],
      c = n[i + 2],
      l = n[i + 3],
      u = r[s],
      h = r[s + 1],
      d = r[s + 2],
      f = r[s + 3];
    return (
      (t[e] = o * f + l * u + a * d - c * h),
      (t[e + 1] = a * f + l * h + c * u - o * d),
      (t[e + 2] = c * f + l * d + o * h - a * u),
      (t[e + 3] = l * f - o * u - a * h - c * d),
      t
    );
  },
});
Object.defineProperties(Ae.prototype, {
  x: {
    get: function () {
      return this._x;
    },
    set: function (t) {
      (this._x = t), this._onChangeCallback();
    },
  },
  y: {
    get: function () {
      return this._y;
    },
    set: function (t) {
      (this._y = t), this._onChangeCallback();
    },
  },
  z: {
    get: function () {
      return this._z;
    },
    set: function (t) {
      (this._z = t), this._onChangeCallback();
    },
  },
  w: {
    get: function () {
      return this._w;
    },
    set: function (t) {
      (this._w = t), this._onChangeCallback();
    },
  },
});
Object.assign(Ae.prototype, {
  isQuaternion: !0,
  set: function (t, e, n, i) {
    return (
      (this._x = t),
      (this._y = e),
      (this._z = n),
      (this._w = i),
      this._onChangeCallback(),
      this
    );
  },
  clone: function () {
    return new this.constructor(this._x, this._y, this._z, this._w);
  },
  copy: function (t) {
    return (
      (this._x = t.x),
      (this._y = t.y),
      (this._z = t.z),
      (this._w = t.w),
      this._onChangeCallback(),
      this
    );
  },
  setFromEuler: function (t, e) {
    if (!(t && t.isEuler))
      throw new Error(
        "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
      );
    const n = t._x,
      i = t._y,
      r = t._z,
      s = t.order,
      o = Math.cos,
      a = Math.sin,
      c = o(n / 2),
      l = o(i / 2),
      u = o(r / 2),
      h = a(n / 2),
      d = a(i / 2),
      f = a(r / 2);
    switch (s) {
      case "XYZ":
        (this._x = h * l * u + c * d * f),
          (this._y = c * d * u - h * l * f),
          (this._z = c * l * f + h * d * u),
          (this._w = c * l * u - h * d * f);
        break;
      case "YXZ":
        (this._x = h * l * u + c * d * f),
          (this._y = c * d * u - h * l * f),
          (this._z = c * l * f - h * d * u),
          (this._w = c * l * u + h * d * f);
        break;
      case "ZXY":
        (this._x = h * l * u - c * d * f),
          (this._y = c * d * u + h * l * f),
          (this._z = c * l * f + h * d * u),
          (this._w = c * l * u - h * d * f);
        break;
      case "ZYX":
        (this._x = h * l * u - c * d * f),
          (this._y = c * d * u + h * l * f),
          (this._z = c * l * f - h * d * u),
          (this._w = c * l * u + h * d * f);
        break;
      case "YZX":
        (this._x = h * l * u + c * d * f),
          (this._y = c * d * u + h * l * f),
          (this._z = c * l * f - h * d * u),
          (this._w = c * l * u - h * d * f);
        break;
      case "XZY":
        (this._x = h * l * u - c * d * f),
          (this._y = c * d * u - h * l * f),
          (this._z = c * l * f + h * d * u),
          (this._w = c * l * u + h * d * f);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s
        );
    }
    return e !== !1 && this._onChangeCallback(), this;
  },
  setFromAxisAngle: function (t, e) {
    const n = e / 2,
      i = Math.sin(n);
    return (
      (this._x = t.x * i),
      (this._y = t.y * i),
      (this._z = t.z * i),
      (this._w = Math.cos(n)),
      this._onChangeCallback(),
      this
    );
  },
  setFromRotationMatrix: function (t) {
    const e = t.elements,
      n = e[0],
      i = e[4],
      r = e[8],
      s = e[1],
      o = e[5],
      a = e[9],
      c = e[2],
      l = e[6],
      u = e[10],
      h = n + o + u;
    if (h > 0) {
      const d = 0.5 / Math.sqrt(h + 1);
      (this._w = 0.25 / d),
        (this._x = (l - a) * d),
        (this._y = (r - c) * d),
        (this._z = (s - i) * d);
    } else if (n > o && n > u) {
      const d = 2 * Math.sqrt(1 + n - o - u);
      (this._w = (l - a) / d),
        (this._x = 0.25 * d),
        (this._y = (i + s) / d),
        (this._z = (r + c) / d);
    } else if (o > u) {
      const d = 2 * Math.sqrt(1 + o - n - u);
      (this._w = (r - c) / d),
        (this._x = (i + s) / d),
        (this._y = 0.25 * d),
        (this._z = (a + l) / d);
    } else {
      const d = 2 * Math.sqrt(1 + u - n - o);
      (this._w = (s - i) / d),
        (this._x = (r + c) / d),
        (this._y = (a + l) / d),
        (this._z = 0.25 * d);
    }
    return this._onChangeCallback(), this;
  },
  setFromUnitVectors: function (t, e) {
    const n = 1e-6;
    let i = t.dot(e) + 1;
    return (
      i < n
        ? ((i = 0),
          Math.abs(t.x) > Math.abs(t.z)
            ? ((this._x = -t.y), (this._y = t.x), (this._z = 0), (this._w = i))
            : ((this._x = 0), (this._y = -t.z), (this._z = t.y), (this._w = i)))
        : ((this._x = t.y * e.z - t.z * e.y),
          (this._y = t.z * e.x - t.x * e.z),
          (this._z = t.x * e.y - t.y * e.x),
          (this._w = i)),
      this.normalize()
    );
  },
  angleTo: function (t) {
    return 2 * Math.acos(Math.abs(Pt.clamp(this.dot(t), -1, 1)));
  },
  rotateTowards: function (t, e) {
    const n = this.angleTo(t);
    if (n === 0) return this;
    const i = Math.min(1, e / n);
    return this.slerp(t, i), this;
  },
  inverse: function () {
    return this.conjugate();
  },
  conjugate: function () {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  },
  dot: function (t) {
    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
  },
  lengthSq: function () {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  },
  length: function () {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  },
  normalize: function () {
    let t = this.length();
    return (
      t === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((t = 1 / t),
          (this._x = this._x * t),
          (this._y = this._y * t),
          (this._z = this._z * t),
          (this._w = this._w * t)),
      this._onChangeCallback(),
      this
    );
  },
  multiply: function (t, e) {
    return e !== void 0
      ? (console.warn(
          "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
        ),
        this.multiplyQuaternions(t, e))
      : this.multiplyQuaternions(this, t);
  },
  premultiply: function (t) {
    return this.multiplyQuaternions(t, this);
  },
  multiplyQuaternions: function (t, e) {
    const n = t._x,
      i = t._y,
      r = t._z,
      s = t._w,
      o = e._x,
      a = e._y,
      c = e._z,
      l = e._w;
    return (
      (this._x = n * l + s * o + i * c - r * a),
      (this._y = i * l + s * a + r * o - n * c),
      (this._z = r * l + s * c + n * a - i * o),
      (this._w = s * l - n * o - i * a - r * c),
      this._onChangeCallback(),
      this
    );
  },
  slerp: function (t, e) {
    if (e === 0) return this;
    if (e === 1) return this.copy(t);
    const n = this._x,
      i = this._y,
      r = this._z,
      s = this._w;
    let o = s * t._w + n * t._x + i * t._y + r * t._z;
    if (
      (o < 0
        ? ((this._w = -t._w),
          (this._x = -t._x),
          (this._y = -t._y),
          (this._z = -t._z),
          (o = -o))
        : this.copy(t),
      o >= 1)
    )
      return (this._w = s), (this._x = n), (this._y = i), (this._z = r), this;
    const a = 1 - o * o;
    if (a <= Number.EPSILON) {
      const d = 1 - e;
      return (
        (this._w = d * s + e * this._w),
        (this._x = d * n + e * this._x),
        (this._y = d * i + e * this._y),
        (this._z = d * r + e * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      );
    }
    const c = Math.sqrt(a),
      l = Math.atan2(c, o),
      u = Math.sin((1 - e) * l) / c,
      h = Math.sin(e * l) / c;
    return (
      (this._w = s * u + this._w * h),
      (this._x = n * u + this._x * h),
      (this._y = i * u + this._y * h),
      (this._z = r * u + this._z * h),
      this._onChangeCallback(),
      this
    );
  },
  equals: function (t) {
    return (
      t._x === this._x &&
      t._y === this._y &&
      t._z === this._z &&
      t._w === this._w
    );
  },
  fromArray: function (t, e) {
    return (
      e === void 0 && (e = 0),
      (this._x = t[e]),
      (this._y = t[e + 1]),
      (this._z = t[e + 2]),
      (this._w = t[e + 3]),
      this._onChangeCallback(),
      this
    );
  },
  toArray: function (t, e) {
    return (
      t === void 0 && (t = []),
      e === void 0 && (e = 0),
      (t[e] = this._x),
      (t[e + 1] = this._y),
      (t[e + 2] = this._z),
      (t[e + 3] = this._w),
      t
    );
  },
  fromBufferAttribute: function (t, e) {
    return (
      (this._x = t.getX(e)),
      (this._y = t.getY(e)),
      (this._z = t.getZ(e)),
      (this._w = t.getW(e)),
      this
    );
  },
  _onChange: function (t) {
    return (this._onChangeCallback = t), this;
  },
  _onChangeCallback: function () {},
});
const $u = new S(),
  kp = new Ae();
function S(t = 0, e = 0, n = 0) {
  (this.x = t), (this.y = e), (this.z = n);
}
Object.assign(S.prototype, {
  isVector3: !0,
  set: function (t, e, n) {
    return (this.x = t), (this.y = e), (this.z = n), this;
  },
  setScalar: function (t) {
    return (this.x = t), (this.y = t), (this.z = t), this;
  },
  setX: function (t) {
    return (this.x = t), this;
  },
  setY: function (t) {
    return (this.y = t), this;
  },
  setZ: function (t) {
    return (this.z = t), this;
  },
  setComponent: function (t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  },
  getComponent: function (t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + t);
    }
  },
  clone: function () {
    return new this.constructor(this.x, this.y, this.z);
  },
  copy: function (t) {
    return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
  },
  add: function (t, e) {
    return e !== void 0
      ? (console.warn(
          "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
        ),
        this.addVectors(t, e))
      : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
  },
  addScalar: function (t) {
    return (this.x += t), (this.y += t), (this.z += t), this;
  },
  addVectors: function (t, e) {
    return (
      (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this
    );
  },
  addScaledVector: function (t, e) {
    return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this;
  },
  sub: function (t, e) {
    return e !== void 0
      ? (console.warn(
          "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
        ),
        this.subVectors(t, e))
      : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
  },
  subScalar: function (t) {
    return (this.x -= t), (this.y -= t), (this.z -= t), this;
  },
  subVectors: function (t, e) {
    return (
      (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this
    );
  },
  multiply: function (t, e) {
    return e !== void 0
      ? (console.warn(
          "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
        ),
        this.multiplyVectors(t, e))
      : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
  },
  multiplyScalar: function (t) {
    return (this.x *= t), (this.y *= t), (this.z *= t), this;
  },
  multiplyVectors: function (t, e) {
    return (
      (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this
    );
  },
  applyEuler: function (t) {
    return (
      (t && t.isEuler) ||
        console.error(
          "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
        ),
      this.applyQuaternion(kp.setFromEuler(t))
    );
  },
  applyAxisAngle: function (t, e) {
    return this.applyQuaternion(kp.setFromAxisAngle(t, e));
  },
  applyMatrix3: function (t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      r = t.elements;
    return (
      (this.x = r[0] * e + r[3] * n + r[6] * i),
      (this.y = r[1] * e + r[4] * n + r[7] * i),
      (this.z = r[2] * e + r[5] * n + r[8] * i),
      this
    );
  },
  applyNormalMatrix: function (t) {
    return this.applyMatrix3(t).normalize();
  },
  applyMatrix4: function (t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      r = t.elements,
      s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
    return (
      (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s),
      (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s),
      (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s),
      this
    );
  },
  applyQuaternion: function (t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      r = t.x,
      s = t.y,
      o = t.z,
      a = t.w,
      c = a * e + s * i - o * n,
      l = a * n + o * e - r * i,
      u = a * i + r * n - s * e,
      h = -r * e - s * n - o * i;
    return (
      (this.x = c * a + h * -r + l * -o - u * -s),
      (this.y = l * a + h * -s + u * -r - c * -o),
      (this.z = u * a + h * -o + c * -s - l * -r),
      this
    );
  },
  project: function (t) {
    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
      t.projectionMatrix
    );
  },
  unproject: function (t) {
    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
      t.matrixWorld
    );
  },
  transformDirection: function (t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      r = t.elements;
    return (
      (this.x = r[0] * e + r[4] * n + r[8] * i),
      (this.y = r[1] * e + r[5] * n + r[9] * i),
      (this.z = r[2] * e + r[6] * n + r[10] * i),
      this.normalize()
    );
  },
  divide: function (t) {
    return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
  },
  divideScalar: function (t) {
    return this.multiplyScalar(1 / t);
  },
  min: function (t) {
    return (
      (this.x = Math.min(this.x, t.x)),
      (this.y = Math.min(this.y, t.y)),
      (this.z = Math.min(this.z, t.z)),
      this
    );
  },
  max: function (t) {
    return (
      (this.x = Math.max(this.x, t.x)),
      (this.y = Math.max(this.y, t.y)),
      (this.z = Math.max(this.z, t.z)),
      this
    );
  },
  clamp: function (t, e) {
    return (
      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
      (this.z = Math.max(t.z, Math.min(e.z, this.z))),
      this
    );
  },
  clampScalar: function (t, e) {
    return (
      (this.x = Math.max(t, Math.min(e, this.x))),
      (this.y = Math.max(t, Math.min(e, this.y))),
      (this.z = Math.max(t, Math.min(e, this.z))),
      this
    );
  },
  clampLength: function (t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(t, Math.min(e, n))
    );
  },
  floor: function () {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  },
  ceil: function () {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  },
  round: function () {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  },
  roundToZero: function () {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      this
    );
  },
  negate: function () {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  },
  dot: function (t) {
    return this.x * t.x + this.y * t.y + this.z * t.z;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  },
  manhattanLength: function () {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  },
  normalize: function () {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function (t) {
    return this.normalize().multiplyScalar(t);
  },
  lerp: function (t, e) {
    return (
      (this.x += (t.x - this.x) * e),
      (this.y += (t.y - this.y) * e),
      (this.z += (t.z - this.z) * e),
      this
    );
  },
  lerpVectors: function (t, e, n) {
    return (
      (this.x = t.x + (e.x - t.x) * n),
      (this.y = t.y + (e.y - t.y) * n),
      (this.z = t.z + (e.z - t.z) * n),
      this
    );
  },
  cross: function (t, e) {
    return e !== void 0
      ? (console.warn(
          "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
        ),
        this.crossVectors(t, e))
      : this.crossVectors(this, t);
  },
  crossVectors: function (t, e) {
    const n = t.x,
      i = t.y,
      r = t.z,
      s = e.x,
      o = e.y,
      a = e.z;
    return (
      (this.x = i * a - r * o),
      (this.y = r * s - n * a),
      (this.z = n * o - i * s),
      this
    );
  },
  projectOnVector: function (t) {
    const e = t.lengthSq();
    if (e === 0) return this.set(0, 0, 0);
    const n = t.dot(this) / e;
    return this.copy(t).multiplyScalar(n);
  },
  projectOnPlane: function (t) {
    return $u.copy(this).projectOnVector(t), this.sub($u);
  },
  reflect: function (t) {
    return this.sub($u.copy(t).multiplyScalar(2 * this.dot(t)));
  },
  angleTo: function (t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0) return Math.PI / 2;
    const n = this.dot(t) / e;
    return Math.acos(Pt.clamp(n, -1, 1));
  },
  distanceTo: function (t) {
    return Math.sqrt(this.distanceToSquared(t));
  },
  distanceToSquared: function (t) {
    const e = this.x - t.x,
      n = this.y - t.y,
      i = this.z - t.z;
    return e * e + n * n + i * i;
  },
  manhattanDistanceTo: function (t) {
    return (
      Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
    );
  },
  setFromSpherical: function (t) {
    return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
  },
  setFromSphericalCoords: function (t, e, n) {
    const i = Math.sin(e) * t;
    return (
      (this.x = i * Math.sin(n)),
      (this.y = Math.cos(e) * t),
      (this.z = i * Math.cos(n)),
      this
    );
  },
  setFromCylindrical: function (t) {
    return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
  },
  setFromCylindricalCoords: function (t, e, n) {
    return (
      (this.x = t * Math.sin(e)), (this.y = n), (this.z = t * Math.cos(e)), this
    );
  },
  setFromMatrixPosition: function (t) {
    const e = t.elements;
    return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
  },
  setFromMatrixScale: function (t) {
    const e = this.setFromMatrixColumn(t, 0).length(),
      n = this.setFromMatrixColumn(t, 1).length(),
      i = this.setFromMatrixColumn(t, 2).length();
    return (this.x = e), (this.y = n), (this.z = i), this;
  },
  setFromMatrixColumn: function (t, e) {
    return this.fromArray(t.elements, e * 4);
  },
  setFromMatrix3Column: function (t, e) {
    return this.fromArray(t.elements, e * 3);
  },
  equals: function (t) {
    return t.x === this.x && t.y === this.y && t.z === this.z;
  },
  fromArray: function (t, e) {
    return (
      e === void 0 && (e = 0),
      (this.x = t[e]),
      (this.y = t[e + 1]),
      (this.z = t[e + 2]),
      this
    );
  },
  toArray: function (t, e) {
    return (
      t === void 0 && (t = []),
      e === void 0 && (e = 0),
      (t[e] = this.x),
      (t[e + 1] = this.y),
      (t[e + 2] = this.z),
      t
    );
  },
  fromBufferAttribute: function (t, e, n) {
    return (
      n !== void 0 &&
        console.warn(
          "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
        ),
      (this.x = t.getX(e)),
      (this.y = t.getY(e)),
      (this.z = t.getZ(e)),
      this
    );
  },
  random: function () {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  },
});
const ss = new S(),
  Tn = new Rt(),
  hx = new S(0, 0, 0),
  fx = new S(1, 1, 1),
  Ci = new S(),
  fc = new S(),
  rn = new S();
function Rt() {
  (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
    arguments.length > 0 &&
      console.error(
        "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
      );
}
Object.assign(Rt.prototype, {
  isMatrix4: !0,
  set: function (t, e, n, i, r, s, o, a, c, l, u, h, d, f, p, _) {
    const y = this.elements;
    return (
      (y[0] = t),
      (y[4] = e),
      (y[8] = n),
      (y[12] = i),
      (y[1] = r),
      (y[5] = s),
      (y[9] = o),
      (y[13] = a),
      (y[2] = c),
      (y[6] = l),
      (y[10] = u),
      (y[14] = h),
      (y[3] = d),
      (y[7] = f),
      (y[11] = p),
      (y[15] = _),
      this
    );
  },
  identity: function () {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  },
  clone: function () {
    return new Rt().fromArray(this.elements);
  },
  copy: function (t) {
    const e = this.elements,
      n = t.elements;
    return (
      (e[0] = n[0]),
      (e[1] = n[1]),
      (e[2] = n[2]),
      (e[3] = n[3]),
      (e[4] = n[4]),
      (e[5] = n[5]),
      (e[6] = n[6]),
      (e[7] = n[7]),
      (e[8] = n[8]),
      (e[9] = n[9]),
      (e[10] = n[10]),
      (e[11] = n[11]),
      (e[12] = n[12]),
      (e[13] = n[13]),
      (e[14] = n[14]),
      (e[15] = n[15]),
      this
    );
  },
  copyPosition: function (t) {
    const e = this.elements,
      n = t.elements;
    return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
  },
  extractBasis: function (t, e, n) {
    return (
      t.setFromMatrixColumn(this, 0),
      e.setFromMatrixColumn(this, 1),
      n.setFromMatrixColumn(this, 2),
      this
    );
  },
  makeBasis: function (t, e, n) {
    return (
      this.set(
        t.x,
        e.x,
        n.x,
        0,
        t.y,
        e.y,
        n.y,
        0,
        t.z,
        e.z,
        n.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  },
  extractRotation: function (t) {
    const e = this.elements,
      n = t.elements,
      i = 1 / ss.setFromMatrixColumn(t, 0).length(),
      r = 1 / ss.setFromMatrixColumn(t, 1).length(),
      s = 1 / ss.setFromMatrixColumn(t, 2).length();
    return (
      (e[0] = n[0] * i),
      (e[1] = n[1] * i),
      (e[2] = n[2] * i),
      (e[3] = 0),
      (e[4] = n[4] * r),
      (e[5] = n[5] * r),
      (e[6] = n[6] * r),
      (e[7] = 0),
      (e[8] = n[8] * s),
      (e[9] = n[9] * s),
      (e[10] = n[10] * s),
      (e[11] = 0),
      (e[12] = 0),
      (e[13] = 0),
      (e[14] = 0),
      (e[15] = 1),
      this
    );
  },
  makeRotationFromEuler: function (t) {
    (t && t.isEuler) ||
      console.error(
        "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
      );
    const e = this.elements,
      n = t.x,
      i = t.y,
      r = t.z,
      s = Math.cos(n),
      o = Math.sin(n),
      a = Math.cos(i),
      c = Math.sin(i),
      l = Math.cos(r),
      u = Math.sin(r);
    if (t.order === "XYZ") {
      const h = s * l,
        d = s * u,
        f = o * l,
        p = o * u;
      (e[0] = a * l),
        (e[4] = -a * u),
        (e[8] = c),
        (e[1] = d + f * c),
        (e[5] = h - p * c),
        (e[9] = -o * a),
        (e[2] = p - h * c),
        (e[6] = f + d * c),
        (e[10] = s * a);
    } else if (t.order === "YXZ") {
      const h = a * l,
        d = a * u,
        f = c * l,
        p = c * u;
      (e[0] = h + p * o),
        (e[4] = f * o - d),
        (e[8] = s * c),
        (e[1] = s * u),
        (e[5] = s * l),
        (e[9] = -o),
        (e[2] = d * o - f),
        (e[6] = p + h * o),
        (e[10] = s * a);
    } else if (t.order === "ZXY") {
      const h = a * l,
        d = a * u,
        f = c * l,
        p = c * u;
      (e[0] = h - p * o),
        (e[4] = -s * u),
        (e[8] = f + d * o),
        (e[1] = d + f * o),
        (e[5] = s * l),
        (e[9] = p - h * o),
        (e[2] = -s * c),
        (e[6] = o),
        (e[10] = s * a);
    } else if (t.order === "ZYX") {
      const h = s * l,
        d = s * u,
        f = o * l,
        p = o * u;
      (e[0] = a * l),
        (e[4] = f * c - d),
        (e[8] = h * c + p),
        (e[1] = a * u),
        (e[5] = p * c + h),
        (e[9] = d * c - f),
        (e[2] = -c),
        (e[6] = o * a),
        (e[10] = s * a);
    } else if (t.order === "YZX") {
      const h = s * a,
        d = s * c,
        f = o * a,
        p = o * c;
      (e[0] = a * l),
        (e[4] = p - h * u),
        (e[8] = f * u + d),
        (e[1] = u),
        (e[5] = s * l),
        (e[9] = -o * l),
        (e[2] = -c * l),
        (e[6] = d * u + f),
        (e[10] = h - p * u);
    } else if (t.order === "XZY") {
      const h = s * a,
        d = s * c,
        f = o * a,
        p = o * c;
      (e[0] = a * l),
        (e[4] = -u),
        (e[8] = c * l),
        (e[1] = h * u + p),
        (e[5] = s * l),
        (e[9] = d * u - f),
        (e[2] = f * u - d),
        (e[6] = o * l),
        (e[10] = p * u + h);
    }
    return (
      (e[3] = 0),
      (e[7] = 0),
      (e[11] = 0),
      (e[12] = 0),
      (e[13] = 0),
      (e[14] = 0),
      (e[15] = 1),
      this
    );
  },
  makeRotationFromQuaternion: function (t) {
    return this.compose(hx, t, fx);
  },
  lookAt: function (t, e, n) {
    const i = this.elements;
    return (
      rn.subVectors(t, e),
      rn.lengthSq() === 0 && (rn.z = 1),
      rn.normalize(),
      Ci.crossVectors(n, rn),
      Ci.lengthSq() === 0 &&
        (Math.abs(n.z) === 1 ? (rn.x += 1e-4) : (rn.z += 1e-4),
        rn.normalize(),
        Ci.crossVectors(n, rn)),
      Ci.normalize(),
      fc.crossVectors(rn, Ci),
      (i[0] = Ci.x),
      (i[4] = fc.x),
      (i[8] = rn.x),
      (i[1] = Ci.y),
      (i[5] = fc.y),
      (i[9] = rn.y),
      (i[2] = Ci.z),
      (i[6] = fc.z),
      (i[10] = rn.z),
      this
    );
  },
  multiply: function (t, e) {
    return e !== void 0
      ? (console.warn(
          "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
        ),
        this.multiplyMatrices(t, e))
      : this.multiplyMatrices(this, t);
  },
  premultiply: function (t) {
    return this.multiplyMatrices(t, this);
  },
  multiplyMatrices: function (t, e) {
    const n = t.elements,
      i = e.elements,
      r = this.elements,
      s = n[0],
      o = n[4],
      a = n[8],
      c = n[12],
      l = n[1],
      u = n[5],
      h = n[9],
      d = n[13],
      f = n[2],
      p = n[6],
      _ = n[10],
      y = n[14],
      m = n[3],
      g = n[7],
      b = n[11],
      x = n[15],
      v = i[0],
      w = i[4],
      M = i[8],
      C = i[12],
      A = i[1],
      U = i[5],
      I = i[9],
      B = i[13],
      F = i[2],
      O = i[6],
      R = i[10],
      P = i[14],
      V = i[3],
      Y = i[7],
      K = i[11],
      it = i[15];
    return (
      (r[0] = s * v + o * A + a * F + c * V),
      (r[4] = s * w + o * U + a * O + c * Y),
      (r[8] = s * M + o * I + a * R + c * K),
      (r[12] = s * C + o * B + a * P + c * it),
      (r[1] = l * v + u * A + h * F + d * V),
      (r[5] = l * w + u * U + h * O + d * Y),
      (r[9] = l * M + u * I + h * R + d * K),
      (r[13] = l * C + u * B + h * P + d * it),
      (r[2] = f * v + p * A + _ * F + y * V),
      (r[6] = f * w + p * U + _ * O + y * Y),
      (r[10] = f * M + p * I + _ * R + y * K),
      (r[14] = f * C + p * B + _ * P + y * it),
      (r[3] = m * v + g * A + b * F + x * V),
      (r[7] = m * w + g * U + b * O + x * Y),
      (r[11] = m * M + g * I + b * R + x * K),
      (r[15] = m * C + g * B + b * P + x * it),
      this
    );
  },
  multiplyScalar: function (t) {
    const e = this.elements;
    return (
      (e[0] *= t),
      (e[4] *= t),
      (e[8] *= t),
      (e[12] *= t),
      (e[1] *= t),
      (e[5] *= t),
      (e[9] *= t),
      (e[13] *= t),
      (e[2] *= t),
      (e[6] *= t),
      (e[10] *= t),
      (e[14] *= t),
      (e[3] *= t),
      (e[7] *= t),
      (e[11] *= t),
      (e[15] *= t),
      this
    );
  },
  determinant: function () {
    const t = this.elements,
      e = t[0],
      n = t[4],
      i = t[8],
      r = t[12],
      s = t[1],
      o = t[5],
      a = t[9],
      c = t[13],
      l = t[2],
      u = t[6],
      h = t[10],
      d = t[14],
      f = t[3],
      p = t[7],
      _ = t[11],
      y = t[15];
    return (
      f *
        (+r * a * u -
          i * c * u -
          r * o * h +
          n * c * h +
          i * o * d -
          n * a * d) +
      p *
        (+e * a * d -
          e * c * h +
          r * s * h -
          i * s * d +
          i * c * l -
          r * a * l) +
      _ *
        (+e * c * u -
          e * o * d -
          r * s * u +
          n * s * d +
          r * o * l -
          n * c * l) +
      y *
        (-i * o * l - e * a * u + e * o * h + i * s * u - n * s * h + n * a * l)
    );
  },
  transpose: function () {
    const t = this.elements;
    let e;
    return (
      (e = t[1]),
      (t[1] = t[4]),
      (t[4] = e),
      (e = t[2]),
      (t[2] = t[8]),
      (t[8] = e),
      (e = t[6]),
      (t[6] = t[9]),
      (t[9] = e),
      (e = t[3]),
      (t[3] = t[12]),
      (t[12] = e),
      (e = t[7]),
      (t[7] = t[13]),
      (t[13] = e),
      (e = t[11]),
      (t[11] = t[14]),
      (t[14] = e),
      this
    );
  },
  setPosition: function (t, e, n) {
    const i = this.elements;
    return (
      t.isVector3
        ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
        : ((i[12] = t), (i[13] = e), (i[14] = n)),
      this
    );
  },
  getInverse: function (t, e) {
    e !== void 0 &&
      console.warn(
        "THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate."
      );
    const n = this.elements,
      i = t.elements,
      r = i[0],
      s = i[1],
      o = i[2],
      a = i[3],
      c = i[4],
      l = i[5],
      u = i[6],
      h = i[7],
      d = i[8],
      f = i[9],
      p = i[10],
      _ = i[11],
      y = i[12],
      m = i[13],
      g = i[14],
      b = i[15],
      x = f * g * h - m * p * h + m * u * _ - l * g * _ - f * u * b + l * p * b,
      v = y * p * h - d * g * h - y * u * _ + c * g * _ + d * u * b - c * p * b,
      w = d * m * h - y * f * h + y * l * _ - c * m * _ - d * l * b + c * f * b,
      M = y * f * u - d * m * u - y * l * p + c * m * p + d * l * g - c * f * g,
      C = r * x + s * v + o * w + a * M;
    if (C === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const A = 1 / C;
    return (
      (n[0] = x * A),
      (n[1] =
        (m * p * a -
          f * g * a -
          m * o * _ +
          s * g * _ +
          f * o * b -
          s * p * b) *
        A),
      (n[2] =
        (l * g * a -
          m * u * a +
          m * o * h -
          s * g * h -
          l * o * b +
          s * u * b) *
        A),
      (n[3] =
        (f * u * a -
          l * p * a -
          f * o * h +
          s * p * h +
          l * o * _ -
          s * u * _) *
        A),
      (n[4] = v * A),
      (n[5] =
        (d * g * a -
          y * p * a +
          y * o * _ -
          r * g * _ -
          d * o * b +
          r * p * b) *
        A),
      (n[6] =
        (y * u * a -
          c * g * a -
          y * o * h +
          r * g * h +
          c * o * b -
          r * u * b) *
        A),
      (n[7] =
        (c * p * a -
          d * u * a +
          d * o * h -
          r * p * h -
          c * o * _ +
          r * u * _) *
        A),
      (n[8] = w * A),
      (n[9] =
        (y * f * a -
          d * m * a -
          y * s * _ +
          r * m * _ +
          d * s * b -
          r * f * b) *
        A),
      (n[10] =
        (c * m * a -
          y * l * a +
          y * s * h -
          r * m * h -
          c * s * b +
          r * l * b) *
        A),
      (n[11] =
        (d * l * a -
          c * f * a -
          d * s * h +
          r * f * h +
          c * s * _ -
          r * l * _) *
        A),
      (n[12] = M * A),
      (n[13] =
        (d * m * o -
          y * f * o +
          y * s * p -
          r * m * p -
          d * s * g +
          r * f * g) *
        A),
      (n[14] =
        (y * l * o -
          c * m * o -
          y * s * u +
          r * m * u +
          c * s * g -
          r * l * g) *
        A),
      (n[15] =
        (c * f * o -
          d * l * o +
          d * s * u -
          r * f * u -
          c * s * p +
          r * l * p) *
        A),
      this
    );
  },
  scale: function (t) {
    const e = this.elements,
      n = t.x,
      i = t.y,
      r = t.z;
    return (
      (e[0] *= n),
      (e[4] *= i),
      (e[8] *= r),
      (e[1] *= n),
      (e[5] *= i),
      (e[9] *= r),
      (e[2] *= n),
      (e[6] *= i),
      (e[10] *= r),
      (e[3] *= n),
      (e[7] *= i),
      (e[11] *= r),
      this
    );
  },
  getMaxScaleOnAxis: function () {
    const t = this.elements,
      e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
      n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
      i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
    return Math.sqrt(Math.max(e, n, i));
  },
  makeTranslation: function (t, e, n) {
    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
  },
  makeRotationX: function (t) {
    const e = Math.cos(t),
      n = Math.sin(t);
    return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
  },
  makeRotationY: function (t) {
    const e = Math.cos(t),
      n = Math.sin(t);
    return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
  },
  makeRotationZ: function (t) {
    const e = Math.cos(t),
      n = Math.sin(t);
    return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  },
  makeRotationAxis: function (t, e) {
    const n = Math.cos(e),
      i = Math.sin(e),
      r = 1 - n,
      s = t.x,
      o = t.y,
      a = t.z,
      c = r * s,
      l = r * o;
    return (
      this.set(
        c * s + n,
        c * o - i * a,
        c * a + i * o,
        0,
        c * o + i * a,
        l * o + n,
        l * a - i * s,
        0,
        c * a - i * o,
        l * a + i * s,
        r * a * a + n,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  },
  makeScale: function (t, e, n) {
    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
  },
  makeShear: function (t, e, n) {
    return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this;
  },
  compose: function (t, e, n) {
    const i = this.elements,
      r = e._x,
      s = e._y,
      o = e._z,
      a = e._w,
      c = r + r,
      l = s + s,
      u = o + o,
      h = r * c,
      d = r * l,
      f = r * u,
      p = s * l,
      _ = s * u,
      y = o * u,
      m = a * c,
      g = a * l,
      b = a * u,
      x = n.x,
      v = n.y,
      w = n.z;
    return (
      (i[0] = (1 - (p + y)) * x),
      (i[1] = (d + b) * x),
      (i[2] = (f - g) * x),
      (i[3] = 0),
      (i[4] = (d - b) * v),
      (i[5] = (1 - (h + y)) * v),
      (i[6] = (_ + m) * v),
      (i[7] = 0),
      (i[8] = (f + g) * w),
      (i[9] = (_ - m) * w),
      (i[10] = (1 - (h + p)) * w),
      (i[11] = 0),
      (i[12] = t.x),
      (i[13] = t.y),
      (i[14] = t.z),
      (i[15] = 1),
      this
    );
  },
  decompose: function (t, e, n) {
    const i = this.elements;
    let r = ss.set(i[0], i[1], i[2]).length(),
      s = ss.set(i[4], i[5], i[6]).length(),
      o = ss.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (r = -r),
      (t.x = i[12]),
      (t.y = i[13]),
      (t.z = i[14]),
      Tn.copy(this);
    const c = 1 / r,
      l = 1 / s,
      u = 1 / o;
    return (
      (Tn.elements[0] *= c),
      (Tn.elements[1] *= c),
      (Tn.elements[2] *= c),
      (Tn.elements[4] *= l),
      (Tn.elements[5] *= l),
      (Tn.elements[6] *= l),
      (Tn.elements[8] *= u),
      (Tn.elements[9] *= u),
      (Tn.elements[10] *= u),
      e.setFromRotationMatrix(Tn),
      (n.x = r),
      (n.y = s),
      (n.z = o),
      this
    );
  },
  makePerspective: function (t, e, n, i, r, s) {
    s === void 0 &&
      console.warn(
        "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
      );
    const o = this.elements,
      a = (2 * r) / (e - t),
      c = (2 * r) / (n - i),
      l = (e + t) / (e - t),
      u = (n + i) / (n - i),
      h = -(s + r) / (s - r),
      d = (-2 * s * r) / (s - r);
    return (
      (o[0] = a),
      (o[4] = 0),
      (o[8] = l),
      (o[12] = 0),
      (o[1] = 0),
      (o[5] = c),
      (o[9] = u),
      (o[13] = 0),
      (o[2] = 0),
      (o[6] = 0),
      (o[10] = h),
      (o[14] = d),
      (o[3] = 0),
      (o[7] = 0),
      (o[11] = -1),
      (o[15] = 0),
      this
    );
  },
  makeOrthographic: function (t, e, n, i, r, s) {
    const o = this.elements,
      a = 1 / (e - t),
      c = 1 / (n - i),
      l = 1 / (s - r),
      u = (e + t) * a,
      h = (n + i) * c,
      d = (s + r) * l;
    return (
      (o[0] = 2 * a),
      (o[4] = 0),
      (o[8] = 0),
      (o[12] = -u),
      (o[1] = 0),
      (o[5] = 2 * c),
      (o[9] = 0),
      (o[13] = -h),
      (o[2] = 0),
      (o[6] = 0),
      (o[10] = -2 * l),
      (o[14] = -d),
      (o[3] = 0),
      (o[7] = 0),
      (o[11] = 0),
      (o[15] = 1),
      this
    );
  },
  equals: function (t) {
    const e = this.elements,
      n = t.elements;
    for (let i = 0; i < 16; i++) if (e[i] !== n[i]) return !1;
    return !0;
  },
  fromArray: function (t, e) {
    e === void 0 && (e = 0);
    for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
    return this;
  },
  toArray: function (t, e) {
    t === void 0 && (t = []), e === void 0 && (e = 0);
    const n = this.elements;
    return (
      (t[e] = n[0]),
      (t[e + 1] = n[1]),
      (t[e + 2] = n[2]),
      (t[e + 3] = n[3]),
      (t[e + 4] = n[4]),
      (t[e + 5] = n[5]),
      (t[e + 6] = n[6]),
      (t[e + 7] = n[7]),
      (t[e + 8] = n[8]),
      (t[e + 9] = n[9]),
      (t[e + 10] = n[10]),
      (t[e + 11] = n[11]),
      (t[e + 12] = n[12]),
      (t[e + 13] = n[13]),
      (t[e + 14] = n[14]),
      (t[e + 15] = n[15]),
      t
    );
  },
});
const Gp = new Rt(),
  Hp = new Ae();
function os(t = 0, e = 0, n = 0, i = os.DefaultOrder) {
  (this._x = t), (this._y = e), (this._z = n), (this._order = i);
}
os.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
os.DefaultOrder = "XYZ";
Object.defineProperties(os.prototype, {
  x: {
    get: function () {
      return this._x;
    },
    set: function (t) {
      (this._x = t), this._onChangeCallback();
    },
  },
  y: {
    get: function () {
      return this._y;
    },
    set: function (t) {
      (this._y = t), this._onChangeCallback();
    },
  },
  z: {
    get: function () {
      return this._z;
    },
    set: function (t) {
      (this._z = t), this._onChangeCallback();
    },
  },
  order: {
    get: function () {
      return this._order;
    },
    set: function (t) {
      (this._order = t), this._onChangeCallback();
    },
  },
});
Object.assign(os.prototype, {
  isEuler: !0,
  set: function (t, e, n, i) {
    return (
      (this._x = t),
      (this._y = e),
      (this._z = n),
      (this._order = i || this._order),
      this._onChangeCallback(),
      this
    );
  },
  clone: function () {
    return new this.constructor(this._x, this._y, this._z, this._order);
  },
  copy: function (t) {
    return (
      (this._x = t._x),
      (this._y = t._y),
      (this._z = t._z),
      (this._order = t._order),
      this._onChangeCallback(),
      this
    );
  },
  setFromRotationMatrix: function (t, e, n) {
    const i = Pt.clamp,
      r = t.elements,
      s = r[0],
      o = r[4],
      a = r[8],
      c = r[1],
      l = r[5],
      u = r[9],
      h = r[2],
      d = r[6],
      f = r[10];
    switch (((e = e || this._order), e)) {
      case "XYZ":
        (this._y = Math.asin(i(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-u, f)), (this._z = Math.atan2(-o, s)))
            : ((this._x = Math.atan2(d, l)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-i(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._y = Math.atan2(a, f)), (this._z = Math.atan2(c, l)))
            : ((this._y = Math.atan2(-h, s)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(i(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._y = Math.atan2(-h, f)), (this._z = Math.atan2(-o, l)))
            : ((this._y = 0), (this._z = Math.atan2(c, s)));
        break;
      case "ZYX":
        (this._y = Math.asin(-i(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._x = Math.atan2(d, f)), (this._z = Math.atan2(c, s)))
            : ((this._x = 0), (this._z = Math.atan2(-o, l)));
        break;
      case "YZX":
        (this._z = Math.asin(i(c, -1, 1))),
          Math.abs(c) < 0.9999999
            ? ((this._x = Math.atan2(-u, l)), (this._y = Math.atan2(-h, s)))
            : ((this._x = 0), (this._y = Math.atan2(a, f)));
        break;
      case "XZY":
        (this._z = Math.asin(-i(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(d, l)), (this._y = Math.atan2(a, s)))
            : ((this._x = Math.atan2(-u, f)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            e
        );
    }
    return (this._order = e), n !== !1 && this._onChangeCallback(), this;
  },
  setFromQuaternion: function (t, e, n) {
    return (
      Gp.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Gp, e, n)
    );
  },
  setFromVector3: function (t, e) {
    return this.set(t.x, t.y, t.z, e || this._order);
  },
  reorder: function (t) {
    return Hp.setFromEuler(this), this.setFromQuaternion(Hp, t);
  },
  equals: function (t) {
    return (
      t._x === this._x &&
      t._y === this._y &&
      t._z === this._z &&
      t._order === this._order
    );
  },
  fromArray: function (t) {
    return (
      (this._x = t[0]),
      (this._y = t[1]),
      (this._z = t[2]),
      t[3] !== void 0 && (this._order = t[3]),
      this._onChangeCallback(),
      this
    );
  },
  toArray: function (t, e) {
    return (
      t === void 0 && (t = []),
      e === void 0 && (e = 0),
      (t[e] = this._x),
      (t[e + 1] = this._y),
      (t[e + 2] = this._z),
      (t[e + 3] = this._order),
      t
    );
  },
  toVector3: function (t) {
    return t
      ? t.set(this._x, this._y, this._z)
      : new S(this._x, this._y, this._z);
  },
  _onChange: function (t) {
    return (this._onChangeCallback = t), this;
  },
  _onChangeCallback: function () {},
});
function Qu() {
  this.mask = 1 | 0;
}
Object.assign(Qu.prototype, {
  set: function (t) {
    this.mask = (1 << t) | 0;
  },
  enable: function (t) {
    this.mask |= (1 << t) | 0;
  },
  enableAll: function () {
    this.mask = 4294967295 | 0;
  },
  toggle: function (t) {
    this.mask ^= (1 << t) | 0;
  },
  disable: function (t) {
    this.mask &= ~((1 << t) | 0);
  },
  disableAll: function () {
    this.mask = 0;
  },
  test: function (t) {
    return (this.mask & t.mask) != 0;
  },
});
let dx = 0;
const Vp = new S(),
  as = new Ae(),
  oi = new Rt(),
  dc = new S(),
  wo = new S(),
  px = new S(),
  mx = new Ae(),
  Wp = new S(1, 0, 0),
  jp = new S(0, 1, 0),
  qp = new S(0, 0, 1),
  gx = { type: "added" },
  yx = { type: "removed" };
function nt() {
  Object.defineProperty(this, "id", { value: dx++ }),
    (this.uuid = Pt.generateUUID()),
    (this.name = ""),
    (this.type = "Object3D"),
    (this.parent = null),
    (this.children = []),
    (this.up = nt.DefaultUp.clone());
  const t = new S(),
    e = new os(),
    n = new Ae(),
    i = new S(1, 1, 1);
  function r() {
    n.setFromEuler(e, !1);
  }
  function s() {
    e.setFromQuaternion(n, void 0, !1);
  }
  e._onChange(r),
    n._onChange(s),
    Object.defineProperties(this, {
      position: { configurable: !0, enumerable: !0, value: t },
      rotation: { configurable: !0, enumerable: !0, value: e },
      quaternion: { configurable: !0, enumerable: !0, value: n },
      scale: { configurable: !0, enumerable: !0, value: i },
      modelViewMatrix: { value: new Rt() },
      normalMatrix: { value: new Ge() },
    }),
    (this.matrix = new Rt()),
    (this.matrixWorld = new Rt()),
    (this.matrixAutoUpdate = nt.DefaultMatrixAutoUpdate),
    (this.matrixWorldNeedsUpdate = !1),
    (this.layers = new Qu()),
    (this.visible = !0),
    (this.castShadow = !1),
    (this.receiveShadow = !1),
    (this.frustumCulled = !0),
    (this.renderOrder = 0),
    (this.userData = {});
}
nt.DefaultUp = new S(0, 1, 0);
nt.DefaultMatrixAutoUpdate = !0;
nt.prototype = Object.assign(Object.create(si.prototype), {
  constructor: nt,
  isObject3D: !0,
  onBeforeRender: function () {},
  onAfterRender: function () {},
  applyMatrix4: function (t) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(t),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  applyQuaternion: function (t) {
    return this.quaternion.premultiply(t), this;
  },
  setRotationFromAxisAngle: function (t, e) {
    this.quaternion.setFromAxisAngle(t, e);
  },
  setRotationFromEuler: function (t) {
    this.quaternion.setFromEuler(t, !0);
  },
  setRotationFromMatrix: function (t) {
    this.quaternion.setFromRotationMatrix(t);
  },
  setRotationFromQuaternion: function (t) {
    this.quaternion.copy(t);
  },
  rotateOnAxis: function (t, e) {
    return as.setFromAxisAngle(t, e), this.quaternion.multiply(as), this;
  },
  rotateOnWorldAxis: function (t, e) {
    return as.setFromAxisAngle(t, e), this.quaternion.premultiply(as), this;
  },
  rotateX: function (t) {
    return this.rotateOnAxis(Wp, t);
  },
  rotateY: function (t) {
    return this.rotateOnAxis(jp, t);
  },
  rotateZ: function (t) {
    return this.rotateOnAxis(qp, t);
  },
  translateOnAxis: function (t, e) {
    return (
      Vp.copy(t).applyQuaternion(this.quaternion),
      this.position.add(Vp.multiplyScalar(e)),
      this
    );
  },
  translateX: function (t) {
    return this.translateOnAxis(Wp, t);
  },
  translateY: function (t) {
    return this.translateOnAxis(jp, t);
  },
  translateZ: function (t) {
    return this.translateOnAxis(qp, t);
  },
  localToWorld: function (t) {
    return t.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function (t) {
    return t.applyMatrix4(oi.getInverse(this.matrixWorld));
  },
  lookAt: function (t, e, n) {
    t.isVector3 ? dc.copy(t) : dc.set(t, e, n);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1),
      wo.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? oi.lookAt(wo, dc, this.up)
        : oi.lookAt(dc, wo, this.up),
      this.quaternion.setFromRotationMatrix(oi),
      i &&
        (oi.extractRotation(i.matrixWorld),
        as.setFromRotationMatrix(oi),
        this.quaternion.premultiply(as.inverse()));
  },
  add: function (t) {
    if (arguments.length > 1) {
      for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
      return this;
    }
    return t === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          t
        ),
        this)
      : (t && t.isObject3D
          ? (t.parent !== null && t.parent.remove(t),
            (t.parent = this),
            this.children.push(t),
            t.dispatchEvent(gx))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              t
            ),
        this);
  },
  remove: function (t) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
      return this;
    }
    const e = this.children.indexOf(t);
    return (
      e !== -1 &&
        ((t.parent = null), this.children.splice(e, 1), t.dispatchEvent(yx)),
      this
    );
  },
  attach: function (t) {
    return (
      this.updateWorldMatrix(!0, !1),
      oi.getInverse(this.matrixWorld),
      t.parent !== null &&
        (t.parent.updateWorldMatrix(!0, !1), oi.multiply(t.parent.matrixWorld)),
      t.applyMatrix4(oi),
      t.updateWorldMatrix(!1, !1),
      this.add(t),
      this
    );
  },
  getObjectById: function (t) {
    return this.getObjectByProperty("id", t);
  },
  getObjectByName: function (t) {
    return this.getObjectByProperty("name", t);
  },
  getObjectByProperty: function (t, e) {
    if (this[t] === e) return this;
    for (let n = 0, i = this.children.length; n < i; n++) {
      const s = this.children[n].getObjectByProperty(t, e);
      if (s !== void 0) return s;
    }
  },
  getWorldPosition: function (t) {
    return (
      t === void 0 &&
        (console.warn(
          "THREE.Object3D: .getWorldPosition() target is now required"
        ),
        (t = new S())),
      this.updateMatrixWorld(!0),
      t.setFromMatrixPosition(this.matrixWorld)
    );
  },
  getWorldQuaternion: function (t) {
    return (
      t === void 0 &&
        (console.warn(
          "THREE.Object3D: .getWorldQuaternion() target is now required"
        ),
        (t = new Ae())),
      this.updateMatrixWorld(!0),
      this.matrixWorld.decompose(wo, t, px),
      t
    );
  },
  getWorldScale: function (t) {
    return (
      t === void 0 &&
        (console.warn(
          "THREE.Object3D: .getWorldScale() target is now required"
        ),
        (t = new S())),
      this.updateMatrixWorld(!0),
      this.matrixWorld.decompose(wo, mx, t),
      t
    );
  },
  getWorldDirection: function (t) {
    t === void 0 &&
      (console.warn(
        "THREE.Object3D: .getWorldDirection() target is now required"
      ),
      (t = new S())),
      this.updateMatrixWorld(!0);
    const e = this.matrixWorld.elements;
    return t.set(e[8], e[9], e[10]).normalize();
  },
  raycast: function () {},
  traverse: function (t) {
    t(this);
    const e = this.children;
    for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
  },
  traverseVisible: function (t) {
    if (this.visible === !1) return;
    t(this);
    const e = this.children;
    for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);
  },
  traverseAncestors: function (t) {
    const e = this.parent;
    e !== null && (t(e), e.traverseAncestors(t));
  },
  updateMatrix: function () {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  },
  updateMatrixWorld: function (t) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || t) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (t = !0));
    const e = this.children;
    for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t);
  },
  updateWorldMatrix: function (t, e) {
    const n = this.parent;
    if (
      (t === !0 && n !== null && n.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      e === !0)
    ) {
      const i = this.children;
      for (let r = 0, s = i.length; r < s; r++) i[r].updateWorldMatrix(!1, !0);
    }
  },
  toJSON: function (t) {
    const e = t === void 0 || typeof t == "string",
      n = {};
    e &&
      ((t = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
      }),
      (n.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const i = {};
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.castShadow === !0 && (i.castShadow = !0),
      this.receiveShadow === !0 && (i.receiveShadow = !0),
      this.visible === !1 && (i.visible = !1),
      this.frustumCulled === !1 && (i.frustumCulled = !1),
      this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
      JSON.stringify(this.userData) !== "{}" && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = "InstancedMesh"),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()));
    function r(o, a) {
      return o[a.uuid] === void 0 && (o[a.uuid] = a.toJSON(t)), a.uuid;
    }
    if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = r(t.geometries, this.geometry);
      const o = this.geometry.parameters;
      if (o !== void 0 && o.shapes !== void 0) {
        const a = o.shapes;
        if (Array.isArray(a))
          for (let c = 0, l = a.length; c < l; c++) {
            const u = a[c];
            r(t.shapes, u);
          }
        else r(t.shapes, a);
      }
    }
    if (this.material !== void 0)
      if (Array.isArray(this.material)) {
        const o = [];
        for (let a = 0, c = this.material.length; a < c; a++)
          o.push(r(t.materials, this.material[a]));
        i.material = o;
      } else i.material = r(t.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let o = 0; o < this.children.length; o++)
        i.children.push(this.children[o].toJSON(t).object);
    }
    if (e) {
      const o = s(t.geometries),
        a = s(t.materials),
        c = s(t.textures),
        l = s(t.images),
        u = s(t.shapes);
      o.length > 0 && (n.geometries = o),
        a.length > 0 && (n.materials = a),
        c.length > 0 && (n.textures = c),
        l.length > 0 && (n.images = l),
        u.length > 0 && (n.shapes = u);
    }
    return (n.object = i), n;
    function s(o) {
      const a = [];
      for (const c in o) {
        const l = o[c];
        delete l.metadata, a.push(l);
      }
      return a;
    }
  },
  clone: function (t) {
    return new this.constructor().copy(this, t);
  },
  copy: function (t, e) {
    if (
      (e === void 0 && (e = !0),
      (this.name = t.name),
      this.up.copy(t.up),
      this.position.copy(t.position),
      this.quaternion.copy(t.quaternion),
      this.scale.copy(t.scale),
      this.matrix.copy(t.matrix),
      this.matrixWorld.copy(t.matrixWorld),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
      (this.layers.mask = t.layers.mask),
      (this.visible = t.visible),
      (this.castShadow = t.castShadow),
      (this.receiveShadow = t.receiveShadow),
      (this.frustumCulled = t.frustumCulled),
      (this.renderOrder = t.renderOrder),
      (this.userData = JSON.parse(JSON.stringify(t.userData))),
      e === !0)
    )
      for (let n = 0; n < t.children.length; n++) {
        const i = t.children[n];
        this.add(i.clone());
      }
    return this;
  },
});
function pc() {
  nt.call(this),
    (this.type = "Scene"),
    (this.background = null),
    (this.environment = null),
    (this.fog = null),
    (this.overrideMaterial = null),
    (this.autoUpdate = !0),
    typeof __THREE_DEVTOOLS__ != "undefined" &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("observe", { detail: this })
      );
}
pc.prototype = Object.assign(Object.create(nt.prototype), {
  constructor: pc,
  isScene: !0,
  copy: function (t, e) {
    return (
      nt.prototype.copy.call(this, t, e),
      t.background !== null && (this.background = t.background.clone()),
      t.environment !== null && (this.environment = t.environment.clone()),
      t.fog !== null && (this.fog = t.fog.clone()),
      t.overrideMaterial !== null &&
        (this.overrideMaterial = t.overrideMaterial.clone()),
      (this.autoUpdate = t.autoUpdate),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      this
    );
  },
  toJSON: function (t) {
    const e = nt.prototype.toJSON.call(this, t);
    return (
      this.background !== null &&
        (e.object.background = this.background.toJSON(t)),
      this.environment !== null &&
        (e.object.environment = this.environment.toJSON(t)),
      this.fog !== null && (e.object.fog = this.fog.toJSON()),
      e
    );
  },
  dispose: function () {
    this.dispatchEvent({ type: "dispose" });
  },
});
const ai = [
    new S(),
    new S(),
    new S(),
    new S(),
    new S(),
    new S(),
    new S(),
    new S(),
  ],
  Mo = new S(),
  Ku = new Hn(),
  cs = new S(),
  ls = new S(),
  us = new S(),
  Ri = new S(),
  Oi = new S(),
  lr = new S(),
  So = new S(),
  mc = new S(),
  gc = new S(),
  ur = new S();
function Hn(t, e) {
  (this.min = t !== void 0 ? t : new S(1 / 0, 1 / 0, 1 / 0)),
    (this.max = e !== void 0 ? e : new S(-1 / 0, -1 / 0, -1 / 0));
}
Object.assign(Hn.prototype, {
  isBox3: !0,
  set: function (t, e) {
    return this.min.copy(t), this.max.copy(e), this;
  },
  setFromArray: function (t) {
    let e = 1 / 0,
      n = 1 / 0,
      i = 1 / 0,
      r = -1 / 0,
      s = -1 / 0,
      o = -1 / 0;
    for (let a = 0, c = t.length; a < c; a += 3) {
      const l = t[a],
        u = t[a + 1],
        h = t[a + 2];
      l < e && (e = l),
        u < n && (n = u),
        h < i && (i = h),
        l > r && (r = l),
        u > s && (s = u),
        h > o && (o = h);
    }
    return this.min.set(e, n, i), this.max.set(r, s, o), this;
  },
  setFromBufferAttribute: function (t) {
    let e = 1 / 0,
      n = 1 / 0,
      i = 1 / 0,
      r = -1 / 0,
      s = -1 / 0,
      o = -1 / 0;
    for (let a = 0, c = t.count; a < c; a++) {
      const l = t.getX(a),
        u = t.getY(a),
        h = t.getZ(a);
      l < e && (e = l),
        u < n && (n = u),
        h < i && (i = h),
        l > r && (r = l),
        u > s && (s = u),
        h > o && (o = h);
    }
    return this.min.set(e, n, i), this.max.set(r, s, o), this;
  },
  setFromPoints: function (t) {
    this.makeEmpty();
    for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
    return this;
  },
  setFromCenterAndSize: function (t, e) {
    const n = Mo.copy(e).multiplyScalar(0.5);
    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
  },
  setFromObject: function (t) {
    return this.makeEmpty(), this.expandByObject(t);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return this.min.copy(t.min), this.max.copy(t.max), this;
  },
  makeEmpty: function () {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  },
  isEmpty: function () {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  },
  getCenter: function (t) {
    return (
      t === void 0 &&
        (console.warn("THREE.Box3: .getCenter() target is now required"),
        (t = new S())),
      this.isEmpty()
        ? t.set(0, 0, 0)
        : t.addVectors(this.min, this.max).multiplyScalar(0.5)
    );
  },
  getSize: function (t) {
    return (
      t === void 0 &&
        (console.warn("THREE.Box3: .getSize() target is now required"),
        (t = new S())),
      this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
    );
  },
  expandByPoint: function (t) {
    return this.min.min(t), this.max.max(t), this;
  },
  expandByVector: function (t) {
    return this.min.sub(t), this.max.add(t), this;
  },
  expandByScalar: function (t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this;
  },
  expandByObject: function (t) {
    t.updateWorldMatrix(!1, !1);
    const e = t.geometry;
    e !== void 0 &&
      (e.boundingBox === null && e.computeBoundingBox(),
      Ku.copy(e.boundingBox),
      Ku.applyMatrix4(t.matrixWorld),
      this.union(Ku));
    const n = t.children;
    for (let i = 0, r = n.length; i < r; i++) this.expandByObject(n[i]);
    return this;
  },
  containsPoint: function (t) {
    return !(
      t.x < this.min.x ||
      t.x > this.max.x ||
      t.y < this.min.y ||
      t.y > this.max.y ||
      t.z < this.min.z ||
      t.z > this.max.z
    );
  },
  containsBox: function (t) {
    return (
      this.min.x <= t.min.x &&
      t.max.x <= this.max.x &&
      this.min.y <= t.min.y &&
      t.max.y <= this.max.y &&
      this.min.z <= t.min.z &&
      t.max.z <= this.max.z
    );
  },
  getParameter: function (t, e) {
    return (
      e === void 0 &&
        (console.warn("THREE.Box3: .getParameter() target is now required"),
        (e = new S())),
      e.set(
        (t.x - this.min.x) / (this.max.x - this.min.x),
        (t.y - this.min.y) / (this.max.y - this.min.y),
        (t.z - this.min.z) / (this.max.z - this.min.z)
      )
    );
  },
  intersectsBox: function (t) {
    return !(
      t.max.x < this.min.x ||
      t.min.x > this.max.x ||
      t.max.y < this.min.y ||
      t.min.y > this.max.y ||
      t.max.z < this.min.z ||
      t.min.z > this.max.z
    );
  },
  intersectsSphere: function (t) {
    return (
      this.clampPoint(t.center, Mo),
      Mo.distanceToSquared(t.center) <= t.radius * t.radius
    );
  },
  intersectsPlane: function (t) {
    let e, n;
    return (
      t.normal.x > 0
        ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
        : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
      t.normal.y > 0
        ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
        : ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),
      t.normal.z > 0
        ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
        : ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),
      e <= -t.constant && n >= -t.constant
    );
  },
  intersectsTriangle: function (t) {
    if (this.isEmpty()) return !1;
    this.getCenter(So),
      mc.subVectors(this.max, So),
      cs.subVectors(t.a, So),
      ls.subVectors(t.b, So),
      us.subVectors(t.c, So),
      Ri.subVectors(ls, cs),
      Oi.subVectors(us, ls),
      lr.subVectors(cs, us);
    let e = [
      0,
      -Ri.z,
      Ri.y,
      0,
      -Oi.z,
      Oi.y,
      0,
      -lr.z,
      lr.y,
      Ri.z,
      0,
      -Ri.x,
      Oi.z,
      0,
      -Oi.x,
      lr.z,
      0,
      -lr.x,
      -Ri.y,
      Ri.x,
      0,
      -Oi.y,
      Oi.x,
      0,
      -lr.y,
      lr.x,
      0,
    ];
    return !th(e, cs, ls, us, mc) ||
      ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !th(e, cs, ls, us, mc))
      ? !1
      : (gc.crossVectors(Ri, Oi),
        (e = [gc.x, gc.y, gc.z]),
        th(e, cs, ls, us, mc));
  },
  clampPoint: function (t, e) {
    return (
      e === void 0 &&
        (console.warn("THREE.Box3: .clampPoint() target is now required"),
        (e = new S())),
      e.copy(t).clamp(this.min, this.max)
    );
  },
  distanceToPoint: function (t) {
    return Mo.copy(t).clamp(this.min, this.max).sub(t).length();
  },
  getBoundingSphere: function (t) {
    return (
      t === void 0 &&
        console.error(
          "THREE.Box3: .getBoundingSphere() target is now required"
        ),
      this.getCenter(t.center),
      (t.radius = this.getSize(Mo).length() * 0.5),
      t
    );
  },
  intersect: function (t) {
    return (
      this.min.max(t.min),
      this.max.min(t.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  },
  union: function (t) {
    return this.min.min(t.min), this.max.max(t.max), this;
  },
  applyMatrix4: function (t) {
    return this.isEmpty()
      ? this
      : (ai[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
        ai[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
        ai[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
        ai[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
        ai[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
        ai[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
        ai[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
        ai[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
        this.setFromPoints(ai),
        this);
  },
  translate: function (t) {
    return this.min.add(t), this.max.add(t), this;
  },
  equals: function (t) {
    return t.min.equals(this.min) && t.max.equals(this.max);
  },
});
function th(t, e, n, i, r) {
  for (let s = 0, o = t.length - 3; s <= o; s += 3) {
    ur.fromArray(t, s);
    const a =
        r.x * Math.abs(ur.x) + r.y * Math.abs(ur.y) + r.z * Math.abs(ur.z),
      c = e.dot(ur),
      l = n.dot(ur),
      u = i.dot(ur);
    if (Math.max(-Math.max(c, l, u), Math.min(c, l, u)) > a) return !1;
  }
  return !0;
}
const _x = new Hn();
function ci(t, e) {
  (this.center = t !== void 0 ? t : new S()),
    (this.radius = e !== void 0 ? e : -1);
}
Object.assign(ci.prototype, {
  set: function (t, e) {
    return this.center.copy(t), (this.radius = e), this;
  },
  setFromPoints: function (t, e) {
    const n = this.center;
    e !== void 0 ? n.copy(e) : _x.setFromPoints(t).getCenter(n);
    let i = 0;
    for (let r = 0, s = t.length; r < s; r++)
      i = Math.max(i, n.distanceToSquared(t[r]));
    return (this.radius = Math.sqrt(i)), this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return this.center.copy(t.center), (this.radius = t.radius), this;
  },
  isEmpty: function () {
    return this.radius < 0;
  },
  makeEmpty: function () {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  },
  containsPoint: function (t) {
    return t.distanceToSquared(this.center) <= this.radius * this.radius;
  },
  distanceToPoint: function (t) {
    return t.distanceTo(this.center) - this.radius;
  },
  intersectsSphere: function (t) {
    const e = this.radius + t.radius;
    return t.center.distanceToSquared(this.center) <= e * e;
  },
  intersectsBox: function (t) {
    return t.intersectsSphere(this);
  },
  intersectsPlane: function (t) {
    return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
  },
  clampPoint: function (t, e) {
    const n = this.center.distanceToSquared(t);
    return (
      e === void 0 &&
        (console.warn("THREE.Sphere: .clampPoint() target is now required"),
        (e = new S())),
      e.copy(t),
      n > this.radius * this.radius &&
        (e.sub(this.center).normalize(),
        e.multiplyScalar(this.radius).add(this.center)),
      e
    );
  },
  getBoundingBox: function (t) {
    return (
      t === void 0 &&
        (console.warn("THREE.Sphere: .getBoundingBox() target is now required"),
        (t = new Hn())),
      this.isEmpty()
        ? (t.makeEmpty(), t)
        : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
    );
  },
  applyMatrix4: function (t) {
    return (
      this.center.applyMatrix4(t),
      (this.radius = this.radius * t.getMaxScaleOnAxis()),
      this
    );
  },
  translate: function (t) {
    return this.center.add(t), this;
  },
  equals: function (t) {
    return t.center.equals(this.center) && t.radius === this.radius;
  },
});
const li = new S(),
  eh = new S(),
  yc = new S(),
  Di = new S(),
  nh = new S(),
  _c = new S(),
  ih = new S();
function hs(t, e) {
  (this.origin = t !== void 0 ? t : new S()),
    (this.direction = e !== void 0 ? e : new S(0, 0, -1));
}
Object.assign(hs.prototype, {
  set: function (t, e) {
    return this.origin.copy(t), this.direction.copy(e), this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
  },
  at: function (t, e) {
    return (
      e === void 0 &&
        (console.warn("THREE.Ray: .at() target is now required"),
        (e = new S())),
      e.copy(this.direction).multiplyScalar(t).add(this.origin)
    );
  },
  lookAt: function (t) {
    return this.direction.copy(t).sub(this.origin).normalize(), this;
  },
  recast: function (t) {
    return this.origin.copy(this.at(t, li)), this;
  },
  closestPointToPoint: function (t, e) {
    e === void 0 &&
      (console.warn("THREE.Ray: .closestPointToPoint() target is now required"),
      (e = new S())),
      e.subVectors(t, this.origin);
    const n = e.dot(this.direction);
    return n < 0
      ? e.copy(this.origin)
      : e.copy(this.direction).multiplyScalar(n).add(this.origin);
  },
  distanceToPoint: function (t) {
    return Math.sqrt(this.distanceSqToPoint(t));
  },
  distanceSqToPoint: function (t) {
    const e = li.subVectors(t, this.origin).dot(this.direction);
    return e < 0
      ? this.origin.distanceToSquared(t)
      : (li.copy(this.direction).multiplyScalar(e).add(this.origin),
        li.distanceToSquared(t));
  },
  distanceSqToSegment: function (t, e, n, i) {
    eh.copy(t).add(e).multiplyScalar(0.5),
      yc.copy(e).sub(t).normalize(),
      Di.copy(this.origin).sub(eh);
    const r = t.distanceTo(e) * 0.5,
      s = -this.direction.dot(yc),
      o = Di.dot(this.direction),
      a = -Di.dot(yc),
      c = Di.lengthSq(),
      l = Math.abs(1 - s * s);
    let u, h, d, f;
    if (l > 0)
      if (((u = s * a - o), (h = s * o - a), (f = r * l), u >= 0))
        if (h >= -f)
          if (h <= f) {
            const p = 1 / l;
            (u *= p),
              (h *= p),
              (d = u * (u + s * h + 2 * o) + h * (s * u + h + 2 * a) + c);
          } else
            (h = r),
              (u = Math.max(0, -(s * h + o))),
              (d = -u * u + h * (h + 2 * a) + c);
        else
          (h = -r),
            (u = Math.max(0, -(s * h + o))),
            (d = -u * u + h * (h + 2 * a) + c);
      else
        h <= -f
          ? ((u = Math.max(0, -(-s * r + o))),
            (h = u > 0 ? -r : Math.min(Math.max(-r, -a), r)),
            (d = -u * u + h * (h + 2 * a) + c))
          : h <= f
          ? ((u = 0),
            (h = Math.min(Math.max(-r, -a), r)),
            (d = h * (h + 2 * a) + c))
          : ((u = Math.max(0, -(s * r + o))),
            (h = u > 0 ? r : Math.min(Math.max(-r, -a), r)),
            (d = -u * u + h * (h + 2 * a) + c));
    else
      (h = s > 0 ? -r : r),
        (u = Math.max(0, -(s * h + o))),
        (d = -u * u + h * (h + 2 * a) + c);
    return (
      n && n.copy(this.direction).multiplyScalar(u).add(this.origin),
      i && i.copy(yc).multiplyScalar(h).add(eh),
      d
    );
  },
  intersectSphere: function (t, e) {
    li.subVectors(t.center, this.origin);
    const n = li.dot(this.direction),
      i = li.dot(li) - n * n,
      r = t.radius * t.radius;
    if (i > r) return null;
    const s = Math.sqrt(r - i),
      o = n - s,
      a = n + s;
    return o < 0 && a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e);
  },
  intersectsSphere: function (t) {
    return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
  },
  distanceToPlane: function (t) {
    const e = t.normal.dot(this.direction);
    if (e === 0) return t.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(t.normal) + t.constant) / e;
    return n >= 0 ? n : null;
  },
  intersectPlane: function (t, e) {
    const n = this.distanceToPlane(t);
    return n === null ? null : this.at(n, e);
  },
  intersectsPlane: function (t) {
    const e = t.distanceToPoint(this.origin);
    return e === 0 || t.normal.dot(this.direction) * e < 0;
  },
  intersectBox: function (t, e) {
    let n, i, r, s, o, a;
    const c = 1 / this.direction.x,
      l = 1 / this.direction.y,
      u = 1 / this.direction.z,
      h = this.origin;
    return (
      c >= 0
        ? ((n = (t.min.x - h.x) * c), (i = (t.max.x - h.x) * c))
        : ((n = (t.max.x - h.x) * c), (i = (t.min.x - h.x) * c)),
      l >= 0
        ? ((r = (t.min.y - h.y) * l), (s = (t.max.y - h.y) * l))
        : ((r = (t.max.y - h.y) * l), (s = (t.min.y - h.y) * l)),
      n > s ||
      r > i ||
      ((r > n || n !== n) && (n = r),
      (s < i || i !== i) && (i = s),
      u >= 0
        ? ((o = (t.min.z - h.z) * u), (a = (t.max.z - h.z) * u))
        : ((o = (t.max.z - h.z) * u), (a = (t.min.z - h.z) * u)),
      n > a || o > i) ||
      ((o > n || n !== n) && (n = o), (a < i || i !== i) && (i = a), i < 0)
        ? null
        : this.at(n >= 0 ? n : i, e)
    );
  },
  intersectsBox: function (t) {
    return this.intersectBox(t, li) !== null;
  },
  intersectTriangle: function (t, e, n, i, r) {
    nh.subVectors(e, t), _c.subVectors(n, t), ih.crossVectors(nh, _c);
    let s = this.direction.dot(ih),
      o;
    if (s > 0) {
      if (i) return null;
      o = 1;
    } else if (s < 0) (o = -1), (s = -s);
    else return null;
    Di.subVectors(this.origin, t);
    const a = o * this.direction.dot(_c.crossVectors(Di, _c));
    if (a < 0) return null;
    const c = o * this.direction.dot(nh.cross(Di));
    if (c < 0 || a + c > s) return null;
    const l = -o * Di.dot(ih);
    return l < 0 ? null : this.at(l / s, r);
  },
  applyMatrix4: function (t) {
    return (
      this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
    );
  },
  equals: function (t) {
    return t.origin.equals(this.origin) && t.direction.equals(this.direction);
  },
});
const rh = new S(),
  xx = new S(),
  vx = new Ge();
function Vn(t, e) {
  (this.normal = t !== void 0 ? t : new S(1, 0, 0)),
    (this.constant = e !== void 0 ? e : 0);
}
Object.assign(Vn.prototype, {
  isPlane: !0,
  set: function (t, e) {
    return this.normal.copy(t), (this.constant = e), this;
  },
  setComponents: function (t, e, n, i) {
    return this.normal.set(t, e, n), (this.constant = i), this;
  },
  setFromNormalAndCoplanarPoint: function (t, e) {
    return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
  },
  setFromCoplanarPoints: function (t, e, n) {
    const i = rh.subVectors(n, e).cross(xx.subVectors(t, e)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, t), this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return this.normal.copy(t.normal), (this.constant = t.constant), this;
  },
  normalize: function () {
    const t = 1 / this.normal.length();
    return this.normal.multiplyScalar(t), (this.constant *= t), this;
  },
  negate: function () {
    return (this.constant *= -1), this.normal.negate(), this;
  },
  distanceToPoint: function (t) {
    return this.normal.dot(t) + this.constant;
  },
  distanceToSphere: function (t) {
    return this.distanceToPoint(t.center) - t.radius;
  },
  projectPoint: function (t, e) {
    return (
      e === void 0 &&
        (console.warn("THREE.Plane: .projectPoint() target is now required"),
        (e = new S())),
      e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
    );
  },
  intersectLine: function (t, e) {
    e === void 0 &&
      (console.warn("THREE.Plane: .intersectLine() target is now required"),
      (e = new S()));
    const n = t.delta(rh),
      i = this.normal.dot(n);
    if (i === 0)
      return this.distanceToPoint(t.start) === 0 ? e.copy(t.start) : void 0;
    const r = -(t.start.dot(this.normal) + this.constant) / i;
    if (!(r < 0 || r > 1)) return e.copy(n).multiplyScalar(r).add(t.start);
  },
  intersectsLine: function (t) {
    const e = this.distanceToPoint(t.start),
      n = this.distanceToPoint(t.end);
    return (e < 0 && n > 0) || (n < 0 && e > 0);
  },
  intersectsBox: function (t) {
    return t.intersectsPlane(this);
  },
  intersectsSphere: function (t) {
    return t.intersectsPlane(this);
  },
  coplanarPoint: function (t) {
    return (
      t === void 0 &&
        (console.warn("THREE.Plane: .coplanarPoint() target is now required"),
        (t = new S())),
      t.copy(this.normal).multiplyScalar(-this.constant)
    );
  },
  applyMatrix4: function (t, e) {
    const n = e || vx.getNormalMatrix(t),
      i = this.coplanarPoint(rh).applyMatrix4(t),
      r = this.normal.applyMatrix3(n).normalize();
    return (this.constant = -i.dot(r)), this;
  },
  translate: function (t) {
    return (this.constant -= t.dot(this.normal)), this;
  },
  equals: function (t) {
    return t.normal.equals(this.normal) && t.constant === this.constant;
  },
});
const En = new S(),
  ui = new S(),
  sh = new S(),
  hi = new S(),
  fs = new S(),
  ds = new S(),
  Xp = new S(),
  oh = new S(),
  ah = new S(),
  ch = new S();
function Re(t, e, n) {
  (this.a = t !== void 0 ? t : new S()),
    (this.b = e !== void 0 ? e : new S()),
    (this.c = n !== void 0 ? n : new S());
}
Object.assign(Re, {
  getNormal: function (t, e, n, i) {
    i === void 0 &&
      (console.warn("THREE.Triangle: .getNormal() target is now required"),
      (i = new S())),
      i.subVectors(n, e),
      En.subVectors(t, e),
      i.cross(En);
    const r = i.lengthSq();
    return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
  },
  getBarycoord: function (t, e, n, i, r) {
    En.subVectors(i, e), ui.subVectors(n, e), sh.subVectors(t, e);
    const s = En.dot(En),
      o = En.dot(ui),
      a = En.dot(sh),
      c = ui.dot(ui),
      l = ui.dot(sh),
      u = s * c - o * o;
    if (
      (r === void 0 &&
        (console.warn("THREE.Triangle: .getBarycoord() target is now required"),
        (r = new S())),
      u === 0)
    )
      return r.set(-2, -1, -1);
    const h = 1 / u,
      d = (c * a - o * l) * h,
      f = (s * l - o * a) * h;
    return r.set(1 - d - f, f, d);
  },
  containsPoint: function (t, e, n, i) {
    return (
      Re.getBarycoord(t, e, n, i, hi),
      hi.x >= 0 && hi.y >= 0 && hi.x + hi.y <= 1
    );
  },
  getUV: function (t, e, n, i, r, s, o, a) {
    return (
      this.getBarycoord(t, e, n, i, hi),
      a.set(0, 0),
      a.addScaledVector(r, hi.x),
      a.addScaledVector(s, hi.y),
      a.addScaledVector(o, hi.z),
      a
    );
  },
  isFrontFacing: function (t, e, n, i) {
    return En.subVectors(n, e), ui.subVectors(t, e), En.cross(ui).dot(i) < 0;
  },
});
Object.assign(Re.prototype, {
  set: function (t, e, n) {
    return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
  },
  setFromPointsAndIndices: function (t, e, n, i) {
    return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
  },
  getArea: function () {
    return (
      En.subVectors(this.c, this.b),
      ui.subVectors(this.a, this.b),
      En.cross(ui).length() * 0.5
    );
  },
  getMidpoint: function (t) {
    return (
      t === void 0 &&
        (console.warn("THREE.Triangle: .getMidpoint() target is now required"),
        (t = new S())),
      t
        .addVectors(this.a, this.b)
        .add(this.c)
        .multiplyScalar(1 / 3)
    );
  },
  getNormal: function (t) {
    return Re.getNormal(this.a, this.b, this.c, t);
  },
  getPlane: function (t) {
    return (
      t === void 0 &&
        (console.warn("THREE.Triangle: .getPlane() target is now required"),
        (t = new Vn())),
      t.setFromCoplanarPoints(this.a, this.b, this.c)
    );
  },
  getBarycoord: function (t, e) {
    return Re.getBarycoord(t, this.a, this.b, this.c, e);
  },
  getUV: function (t, e, n, i, r) {
    return Re.getUV(t, this.a, this.b, this.c, e, n, i, r);
  },
  containsPoint: function (t) {
    return Re.containsPoint(t, this.a, this.b, this.c);
  },
  isFrontFacing: function (t) {
    return Re.isFrontFacing(this.a, this.b, this.c, t);
  },
  intersectsBox: function (t) {
    return t.intersectsTriangle(this);
  },
  closestPointToPoint: function (t, e) {
    e === void 0 &&
      (console.warn(
        "THREE.Triangle: .closestPointToPoint() target is now required"
      ),
      (e = new S()));
    const n = this.a,
      i = this.b,
      r = this.c;
    let s, o;
    fs.subVectors(i, n), ds.subVectors(r, n), oh.subVectors(t, n);
    const a = fs.dot(oh),
      c = ds.dot(oh);
    if (a <= 0 && c <= 0) return e.copy(n);
    ah.subVectors(t, i);
    const l = fs.dot(ah),
      u = ds.dot(ah);
    if (l >= 0 && u <= l) return e.copy(i);
    const h = a * u - l * c;
    if (h <= 0 && a >= 0 && l <= 0)
      return (s = a / (a - l)), e.copy(n).addScaledVector(fs, s);
    ch.subVectors(t, r);
    const d = fs.dot(ch),
      f = ds.dot(ch);
    if (f >= 0 && d <= f) return e.copy(r);
    const p = d * c - a * f;
    if (p <= 0 && c >= 0 && f <= 0)
      return (o = c / (c - f)), e.copy(n).addScaledVector(ds, o);
    const _ = l * f - d * u;
    if (_ <= 0 && u - l >= 0 && d - f >= 0)
      return (
        Xp.subVectors(r, i),
        (o = (u - l) / (u - l + (d - f))),
        e.copy(i).addScaledVector(Xp, o)
      );
    const y = 1 / (_ + p + h);
    return (
      (s = p * y),
      (o = h * y),
      e.copy(n).addScaledVector(fs, s).addScaledVector(ds, o)
    );
  },
  equals: function (t) {
    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
  },
});
const Yp = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  An = { h: 0, s: 0, l: 0 },
  xc = { h: 0, s: 0, l: 0 };
function lt(t, e, n) {
  return e === void 0 && n === void 0 ? this.set(t) : this.setRGB(t, e, n);
}
function lh(t, e, n) {
  return (
    n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6
      ? t + (e - t) * 6 * n
      : n < 1 / 2
      ? e
      : n < 2 / 3
      ? t + (e - t) * 6 * (2 / 3 - n)
      : t
  );
}
function uh(t) {
  return t < 0.04045
    ? t * 0.0773993808
    : Math.pow(t * 0.9478672986 + 0.0521327014, 2.4);
}
function hh(t) {
  return t < 0.0031308 ? t * 12.92 : 1.055 * Math.pow(t, 0.41666) - 0.055;
}
Object.assign(lt.prototype, {
  isColor: !0,
  r: 1,
  g: 1,
  b: 1,
  set: function (t) {
    return (
      t && t.isColor
        ? this.copy(t)
        : typeof t == "number"
        ? this.setHex(t)
        : typeof t == "string" && this.setStyle(t),
      this
    );
  },
  setScalar: function (t) {
    return (this.r = t), (this.g = t), (this.b = t), this;
  },
  setHex: function (t) {
    return (
      (t = Math.floor(t)),
      (this.r = ((t >> 16) & 255) / 255),
      (this.g = ((t >> 8) & 255) / 255),
      (this.b = (t & 255) / 255),
      this
    );
  },
  setRGB: function (t, e, n) {
    return (this.r = t), (this.g = e), (this.b = n), this;
  },
  setHSL: function (t, e, n) {
    if (
      ((t = Pt.euclideanModulo(t, 1)),
      (e = Pt.clamp(e, 0, 1)),
      (n = Pt.clamp(n, 0, 1)),
      e === 0)
    )
      this.r = this.g = this.b = n;
    else {
      const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
        r = 2 * n - i;
      (this.r = lh(r, i, t + 1 / 3)),
        (this.g = lh(r, i, t)),
        (this.b = lh(r, i, t - 1 / 3));
    }
    return this;
  },
  setStyle: function (t) {
    function e(i) {
      i !== void 0 &&
        parseFloat(i) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + t + " will be ignored."
        );
    }
    let n;
    if ((n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t))) {
      let i;
      const r = n[1],
        s = n[2];
      switch (r) {
        case "rgb":
        case "rgba":
          if (
            (i =
              /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                s
              ))
          )
            return (
              (this.r = Math.min(255, parseInt(i[1], 10)) / 255),
              (this.g = Math.min(255, parseInt(i[2], 10)) / 255),
              (this.b = Math.min(255, parseInt(i[3], 10)) / 255),
              e(i[5]),
              this
            );
          if (
            (i =
              /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                s
              ))
          )
            return (
              (this.r = Math.min(100, parseInt(i[1], 10)) / 100),
              (this.g = Math.min(100, parseInt(i[2], 10)) / 100),
              (this.b = Math.min(100, parseInt(i[3], 10)) / 100),
              e(i[5]),
              this
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (i =
              /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                s
              ))
          ) {
            const o = parseFloat(i[1]) / 360,
              a = parseInt(i[2], 10) / 100,
              c = parseInt(i[3], 10) / 100;
            return e(i[5]), this.setHSL(o, a, c);
          }
          break;
      }
    } else if ((n = /^\#([A-Fa-f0-9]+)$/.exec(t))) {
      const i = n[1],
        r = i.length;
      if (r === 3)
        return (
          (this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255),
          (this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255),
          (this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255),
          this
        );
      if (r === 6)
        return (
          (this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255),
          (this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255),
          (this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255),
          this
        );
    }
    return t && t.length > 0 ? this.setColorName(t) : this;
  },
  setColorName: function (t) {
    const e = Yp[t];
    return (
      e !== void 0
        ? this.setHex(e)
        : console.warn("THREE.Color: Unknown color " + t),
      this
    );
  },
  clone: function () {
    return new this.constructor(this.r, this.g, this.b);
  },
  copy: function (t) {
    return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
  },
  copyGammaToLinear: function (t, e) {
    return (
      e === void 0 && (e = 2),
      (this.r = Math.pow(t.r, e)),
      (this.g = Math.pow(t.g, e)),
      (this.b = Math.pow(t.b, e)),
      this
    );
  },
  copyLinearToGamma: function (t, e) {
    e === void 0 && (e = 2);
    const n = e > 0 ? 1 / e : 1;
    return (
      (this.r = Math.pow(t.r, n)),
      (this.g = Math.pow(t.g, n)),
      (this.b = Math.pow(t.b, n)),
      this
    );
  },
  convertGammaToLinear: function (t) {
    return this.copyGammaToLinear(this, t), this;
  },
  convertLinearToGamma: function (t) {
    return this.copyLinearToGamma(this, t), this;
  },
  copySRGBToLinear: function (t) {
    return (this.r = uh(t.r)), (this.g = uh(t.g)), (this.b = uh(t.b)), this;
  },
  copyLinearToSRGB: function (t) {
    return (this.r = hh(t.r)), (this.g = hh(t.g)), (this.b = hh(t.b)), this;
  },
  convertSRGBToLinear: function () {
    return this.copySRGBToLinear(this), this;
  },
  convertLinearToSRGB: function () {
    return this.copyLinearToSRGB(this), this;
  },
  getHex: function () {
    return (
      ((this.r * 255) << 16) ^ ((this.g * 255) << 8) ^ ((this.b * 255) << 0)
    );
  },
  getHexString: function () {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  },
  getHSL: function (t) {
    t === void 0 &&
      (console.warn("THREE.Color: .getHSL() target is now required"),
      (t = { h: 0, s: 0, l: 0 }));
    const e = this.r,
      n = this.g,
      i = this.b,
      r = Math.max(e, n, i),
      s = Math.min(e, n, i);
    let o, a;
    const c = (s + r) / 2;
    if (s === r) (o = 0), (a = 0);
    else {
      const l = r - s;
      switch (((a = c <= 0.5 ? l / (r + s) : l / (2 - r - s)), r)) {
        case e:
          o = (n - i) / l + (n < i ? 6 : 0);
          break;
        case n:
          o = (i - e) / l + 2;
          break;
        case i:
          o = (e - n) / l + 4;
          break;
      }
      o /= 6;
    }
    return (t.h = o), (t.s = a), (t.l = c), t;
  },
  getStyle: function () {
    return (
      "rgb(" +
      ((this.r * 255) | 0) +
      "," +
      ((this.g * 255) | 0) +
      "," +
      ((this.b * 255) | 0) +
      ")"
    );
  },
  offsetHSL: function (t, e, n) {
    return (
      this.getHSL(An),
      (An.h += t),
      (An.s += e),
      (An.l += n),
      this.setHSL(An.h, An.s, An.l),
      this
    );
  },
  add: function (t) {
    return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
  },
  addColors: function (t, e) {
    return (
      (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
    );
  },
  addScalar: function (t) {
    return (this.r += t), (this.g += t), (this.b += t), this;
  },
  sub: function (t) {
    return (
      (this.r = Math.max(0, this.r - t.r)),
      (this.g = Math.max(0, this.g - t.g)),
      (this.b = Math.max(0, this.b - t.b)),
      this
    );
  },
  multiply: function (t) {
    return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
  },
  multiplyScalar: function (t) {
    return (this.r *= t), (this.g *= t), (this.b *= t), this;
  },
  lerp: function (t, e) {
    return (
      (this.r += (t.r - this.r) * e),
      (this.g += (t.g - this.g) * e),
      (this.b += (t.b - this.b) * e),
      this
    );
  },
  lerpHSL: function (t, e) {
    this.getHSL(An), t.getHSL(xc);
    const n = Pt.lerp(An.h, xc.h, e),
      i = Pt.lerp(An.s, xc.s, e),
      r = Pt.lerp(An.l, xc.l, e);
    return this.setHSL(n, i, r), this;
  },
  equals: function (t) {
    return t.r === this.r && t.g === this.g && t.b === this.b;
  },
  fromArray: function (t, e) {
    return (
      e === void 0 && (e = 0),
      (this.r = t[e]),
      (this.g = t[e + 1]),
      (this.b = t[e + 2]),
      this
    );
  },
  toArray: function (t, e) {
    return (
      t === void 0 && (t = []),
      e === void 0 && (e = 0),
      (t[e] = this.r),
      (t[e + 1] = this.g),
      (t[e + 2] = this.b),
      t
    );
  },
  fromBufferAttribute: function (t, e) {
    return (
      (this.r = t.getX(e)),
      (this.g = t.getY(e)),
      (this.b = t.getZ(e)),
      t.normalized === !0 &&
        ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
      this
    );
  },
  toJSON: function () {
    return this.getHex();
  },
});
lt.NAMES = Yp;
function vc(t, e, n, i, r, s) {
  (this.a = t),
    (this.b = e),
    (this.c = n),
    (this.normal = i && i.isVector3 ? i : new S()),
    (this.vertexNormals = Array.isArray(i) ? i : []),
    (this.color = r && r.isColor ? r : new lt()),
    (this.vertexColors = Array.isArray(r) ? r : []),
    (this.materialIndex = s !== void 0 ? s : 0);
}
Object.assign(vc.prototype, {
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    (this.a = t.a),
      (this.b = t.b),
      (this.c = t.c),
      this.normal.copy(t.normal),
      this.color.copy(t.color),
      (this.materialIndex = t.materialIndex);
    for (let e = 0, n = t.vertexNormals.length; e < n; e++)
      this.vertexNormals[e] = t.vertexNormals[e].clone();
    for (let e = 0, n = t.vertexColors.length; e < n; e++)
      this.vertexColors[e] = t.vertexColors[e].clone();
    return this;
  },
});
let bx = 0;
function bt() {
  Object.defineProperty(this, "id", { value: bx++ }),
    (this.uuid = Pt.generateUUID()),
    (this.name = ""),
    (this.type = "Material"),
    (this.fog = !0),
    (this.blending = go),
    (this.side = po),
    (this.flatShading = !1),
    (this.vertexColors = !1),
    (this.opacity = 1),
    (this.transparent = !1),
    (this.blendSrc = Mp),
    (this.blendDst = Sp),
    (this.blendEquation = Kr),
    (this.blendSrcAlpha = null),
    (this.blendDstAlpha = null),
    (this.blendEquationAlpha = null),
    (this.depthFunc = Uu),
    (this.depthTest = !0),
    (this.depthWrite = !0),
    (this.stencilWriteMask = 255),
    (this.stencilFunc = lx),
    (this.stencilRef = 0),
    (this.stencilFuncMask = 255),
    (this.stencilFail = Ju),
    (this.stencilZFail = Ju),
    (this.stencilZPass = Ju),
    (this.stencilWrite = !1),
    (this.clippingPlanes = null),
    (this.clipIntersection = !1),
    (this.clipShadows = !1),
    (this.shadowSide = null),
    (this.colorWrite = !0),
    (this.precision = null),
    (this.polygonOffset = !1),
    (this.polygonOffsetFactor = 0),
    (this.polygonOffsetUnits = 0),
    (this.dithering = !1),
    (this.alphaTest = 0),
    (this.premultipliedAlpha = !1),
    (this.visible = !0),
    (this.toneMapped = !0),
    (this.userData = {}),
    (this.version = 0);
}
bt.prototype = Object.assign(Object.create(si.prototype), {
  constructor: bt,
  isMaterial: !0,
  onBeforeCompile: function () {},
  customProgramCacheKey: function () {
    return this.onBeforeCompile.toString();
  },
  setValues: function (t) {
    if (t !== void 0)
      for (const e in t) {
        const n = t[e];
        if (n === void 0) {
          console.warn("THREE.Material: '" + e + "' parameter is undefined.");
          continue;
        }
        if (e === "shading") {
          console.warn(
            "THREE." +
              this.type +
              ": .shading has been removed. Use the boolean .flatShading instead."
          ),
            (this.flatShading = n === yp);
          continue;
        }
        const i = this[e];
        if (i === void 0) {
          console.warn(
            "THREE." +
              this.type +
              ": '" +
              e +
              "' is not a property of this material."
          );
          continue;
        }
        i && i.isColor
          ? i.set(n)
          : i && i.isVector3 && n && n.isVector3
          ? i.copy(n)
          : (this[e] = n);
      }
  },
  toJSON: function (t) {
    const e = t === void 0 || typeof t == "string";
    e && (t = { textures: {}, images: {} });
    const n = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (n.uuid = this.uuid),
      (n.type = this.type),
      this.name !== "" && (n.name = this.name),
      this.color && this.color.isColor && (n.color = this.color.getHex()),
      this.roughness !== void 0 && (n.roughness = this.roughness),
      this.metalness !== void 0 && (n.metalness = this.metalness),
      this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
      this.emissive &&
        this.emissive.isColor &&
        (n.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (n.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (n.specular = this.specular.getHex()),
      this.shininess !== void 0 && (n.shininess = this.shininess),
      this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (n.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
        (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (n.matcap = this.matcap.toJSON(t).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (n.alphaMap = this.alphaMap.toJSON(t).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        (n.lightMap = this.lightMap.toJSON(t).uuid),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((n.aoMap = this.aoMap.toJSON(t).uuid),
        (n.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
        (n.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((n.normalMap = this.normalMap.toJSON(t).uuid),
        (n.normalMapType = this.normalMapType),
        (n.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
        (n.displacementScale = this.displacementScale),
        (n.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (n.specularMap = this.specularMap.toJSON(t).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((n.envMap = this.envMap.toJSON(t).uuid),
        (n.reflectivity = this.reflectivity),
        (n.refractionRatio = this.refractionRatio),
        this.combine !== void 0 && (n.combine = this.combine),
        this.envMapIntensity !== void 0 &&
          (n.envMapIntensity = this.envMapIntensity)),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (n.gradientMap = this.gradientMap.toJSON(t).uuid),
      this.size !== void 0 && (n.size = this.size),
      this.sizeAttenuation !== void 0 &&
        (n.sizeAttenuation = this.sizeAttenuation),
      this.blending !== go && (n.blending = this.blending),
      this.flatShading === !0 && (n.flatShading = this.flatShading),
      this.side !== po && (n.side = this.side),
      this.vertexColors && (n.vertexColors = !0),
      this.opacity < 1 && (n.opacity = this.opacity),
      this.transparent === !0 && (n.transparent = this.transparent),
      (n.depthFunc = this.depthFunc),
      (n.depthTest = this.depthTest),
      (n.depthWrite = this.depthWrite),
      (n.stencilWrite = this.stencilWrite),
      (n.stencilWriteMask = this.stencilWriteMask),
      (n.stencilFunc = this.stencilFunc),
      (n.stencilRef = this.stencilRef),
      (n.stencilFuncMask = this.stencilFuncMask),
      (n.stencilFail = this.stencilFail),
      (n.stencilZFail = this.stencilZFail),
      (n.stencilZPass = this.stencilZPass),
      this.rotation && this.rotation !== 0 && (n.rotation = this.rotation),
      this.polygonOffset === !0 && (n.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (n.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (n.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth && this.linewidth !== 1 && (n.linewidth = this.linewidth),
      this.dashSize !== void 0 && (n.dashSize = this.dashSize),
      this.gapSize !== void 0 && (n.gapSize = this.gapSize),
      this.scale !== void 0 && (n.scale = this.scale),
      this.dithering === !0 && (n.dithering = !0),
      this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
      this.premultipliedAlpha === !0 &&
        (n.premultipliedAlpha = this.premultipliedAlpha),
      this.wireframe === !0 && (n.wireframe = this.wireframe),
      this.wireframeLinewidth > 1 &&
        (n.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (n.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (n.wireframeLinejoin = this.wireframeLinejoin),
      this.morphTargets === !0 && (n.morphTargets = !0),
      this.morphNormals === !0 && (n.morphNormals = !0),
      this.skinning === !0 && (n.skinning = !0),
      this.visible === !1 && (n.visible = !1),
      this.toneMapped === !1 && (n.toneMapped = !1),
      JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData);
    function i(r) {
      const s = [];
      for (const o in r) {
        const a = r[o];
        delete a.metadata, s.push(a);
      }
      return s;
    }
    if (e) {
      const r = i(t.textures),
        s = i(t.images);
      r.length > 0 && (n.textures = r), s.length > 0 && (n.images = s);
    }
    return n;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    (this.name = t.name),
      (this.fog = t.fog),
      (this.blending = t.blending),
      (this.side = t.side),
      (this.flatShading = t.flatShading),
      (this.vertexColors = t.vertexColors),
      (this.opacity = t.opacity),
      (this.transparent = t.transparent),
      (this.blendSrc = t.blendSrc),
      (this.blendDst = t.blendDst),
      (this.blendEquation = t.blendEquation),
      (this.blendSrcAlpha = t.blendSrcAlpha),
      (this.blendDstAlpha = t.blendDstAlpha),
      (this.blendEquationAlpha = t.blendEquationAlpha),
      (this.depthFunc = t.depthFunc),
      (this.depthTest = t.depthTest),
      (this.depthWrite = t.depthWrite),
      (this.stencilWriteMask = t.stencilWriteMask),
      (this.stencilFunc = t.stencilFunc),
      (this.stencilRef = t.stencilRef),
      (this.stencilFuncMask = t.stencilFuncMask),
      (this.stencilFail = t.stencilFail),
      (this.stencilZFail = t.stencilZFail),
      (this.stencilZPass = t.stencilZPass),
      (this.stencilWrite = t.stencilWrite);
    const e = t.clippingPlanes;
    let n = null;
    if (e !== null) {
      const i = e.length;
      n = new Array(i);
      for (let r = 0; r !== i; ++r) n[r] = e[r].clone();
    }
    return (
      (this.clippingPlanes = n),
      (this.clipIntersection = t.clipIntersection),
      (this.clipShadows = t.clipShadows),
      (this.shadowSide = t.shadowSide),
      (this.colorWrite = t.colorWrite),
      (this.precision = t.precision),
      (this.polygonOffset = t.polygonOffset),
      (this.polygonOffsetFactor = t.polygonOffsetFactor),
      (this.polygonOffsetUnits = t.polygonOffsetUnits),
      (this.dithering = t.dithering),
      (this.alphaTest = t.alphaTest),
      (this.premultipliedAlpha = t.premultipliedAlpha),
      (this.visible = t.visible),
      (this.toneMapped = t.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(t.userData))),
      this
    );
  },
  dispose: function () {
    this.dispatchEvent({ type: "dispose" });
  },
});
Object.defineProperty(bt.prototype, "needsUpdate", {
  set: function (t) {
    t === !0 && this.version++;
  },
});
function Ln(t) {
  bt.call(this),
    (this.type = "MeshBasicMaterial"),
    (this.color = new lt(16777215)),
    (this.map = null),
    (this.lightMap = null),
    (this.lightMapIntensity = 1),
    (this.aoMap = null),
    (this.aoMapIntensity = 1),
    (this.specularMap = null),
    (this.alphaMap = null),
    (this.envMap = null),
    (this.combine = tc),
    (this.reflectivity = 1),
    (this.refractionRatio = 0.98),
    (this.wireframe = !1),
    (this.wireframeLinewidth = 1),
    (this.wireframeLinecap = "round"),
    (this.wireframeLinejoin = "round"),
    (this.skinning = !1),
    (this.morphTargets = !1),
    this.setValues(t);
}
Ln.prototype = Object.create(bt.prototype);
Ln.prototype.constructor = Ln;
Ln.prototype.isMeshBasicMaterial = !0;
Ln.prototype.copy = function (t) {
  return (
    bt.prototype.copy.call(this, t),
    this.color.copy(t.color),
    (this.map = t.map),
    (this.lightMap = t.lightMap),
    (this.lightMapIntensity = t.lightMapIntensity),
    (this.aoMap = t.aoMap),
    (this.aoMapIntensity = t.aoMapIntensity),
    (this.specularMap = t.specularMap),
    (this.alphaMap = t.alphaMap),
    (this.envMap = t.envMap),
    (this.combine = t.combine),
    (this.reflectivity = t.reflectivity),
    (this.refractionRatio = t.refractionRatio),
    (this.wireframe = t.wireframe),
    (this.wireframeLinewidth = t.wireframeLinewidth),
    (this.wireframeLinecap = t.wireframeLinecap),
    (this.wireframeLinejoin = t.wireframeLinejoin),
    (this.skinning = t.skinning),
    (this.morphTargets = t.morphTargets),
    this
  );
};
const $t = new S(),
  bc = new H();
function wt(t, e, n) {
  if (Array.isArray(t))
    throw new TypeError(
      "THREE.BufferAttribute: array should be a Typed Array."
    );
  (this.name = ""),
    (this.array = t),
    (this.itemSize = e),
    (this.count = t !== void 0 ? t.length / e : 0),
    (this.normalized = n === !0),
    (this.usage = hc),
    (this.updateRange = { offset: 0, count: -1 }),
    (this.version = 0);
}
Object.defineProperty(wt.prototype, "needsUpdate", {
  set: function (t) {
    t === !0 && this.version++;
  },
});
Object.assign(wt.prototype, {
  isBufferAttribute: !0,
  onUploadCallback: function () {},
  setUsage: function (t) {
    return (this.usage = t), this;
  },
  copy: function (t) {
    return (
      (this.name = t.name),
      (this.array = new t.array.constructor(t.array)),
      (this.itemSize = t.itemSize),
      (this.count = t.count),
      (this.normalized = t.normalized),
      (this.usage = t.usage),
      this
    );
  },
  copyAt: function (t, e, n) {
    (t *= this.itemSize), (n *= e.itemSize);
    for (let i = 0, r = this.itemSize; i < r; i++)
      this.array[t + i] = e.array[n + i];
    return this;
  },
  copyArray: function (t) {
    return this.array.set(t), this;
  },
  copyColorsArray: function (t) {
    const e = this.array;
    let n = 0;
    for (let i = 0, r = t.length; i < r; i++) {
      let s = t[i];
      s === void 0 &&
        (console.warn(
          "THREE.BufferAttribute.copyColorsArray(): color is undefined",
          i
        ),
        (s = new lt())),
        (e[n++] = s.r),
        (e[n++] = s.g),
        (e[n++] = s.b);
    }
    return this;
  },
  copyVector2sArray: function (t) {
    const e = this.array;
    let n = 0;
    for (let i = 0, r = t.length; i < r; i++) {
      let s = t[i];
      s === void 0 &&
        (console.warn(
          "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
          i
        ),
        (s = new H())),
        (e[n++] = s.x),
        (e[n++] = s.y);
    }
    return this;
  },
  copyVector3sArray: function (t) {
    const e = this.array;
    let n = 0;
    for (let i = 0, r = t.length; i < r; i++) {
      let s = t[i];
      s === void 0 &&
        (console.warn(
          "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
          i
        ),
        (s = new S())),
        (e[n++] = s.x),
        (e[n++] = s.y),
        (e[n++] = s.z);
    }
    return this;
  },
  copyVector4sArray: function (t) {
    const e = this.array;
    let n = 0;
    for (let i = 0, r = t.length; i < r; i++) {
      let s = t[i];
      s === void 0 &&
        (console.warn(
          "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
          i
        ),
        (s = new Vt())),
        (e[n++] = s.x),
        (e[n++] = s.y),
        (e[n++] = s.z),
        (e[n++] = s.w);
    }
    return this;
  },
  applyMatrix3: function (t) {
    if (this.itemSize === 2)
      for (let e = 0, n = this.count; e < n; e++)
        bc.fromBufferAttribute(this, e),
          bc.applyMatrix3(t),
          this.setXY(e, bc.x, bc.y);
    else if (this.itemSize === 3)
      for (let e = 0, n = this.count; e < n; e++)
        $t.fromBufferAttribute(this, e),
          $t.applyMatrix3(t),
          this.setXYZ(e, $t.x, $t.y, $t.z);
    return this;
  },
  applyMatrix4: function (t) {
    for (let e = 0, n = this.count; e < n; e++)
      ($t.x = this.getX(e)),
        ($t.y = this.getY(e)),
        ($t.z = this.getZ(e)),
        $t.applyMatrix4(t),
        this.setXYZ(e, $t.x, $t.y, $t.z);
    return this;
  },
  applyNormalMatrix: function (t) {
    for (let e = 0, n = this.count; e < n; e++)
      ($t.x = this.getX(e)),
        ($t.y = this.getY(e)),
        ($t.z = this.getZ(e)),
        $t.applyNormalMatrix(t),
        this.setXYZ(e, $t.x, $t.y, $t.z);
    return this;
  },
  transformDirection: function (t) {
    for (let e = 0, n = this.count; e < n; e++)
      ($t.x = this.getX(e)),
        ($t.y = this.getY(e)),
        ($t.z = this.getZ(e)),
        $t.transformDirection(t),
        this.setXYZ(e, $t.x, $t.y, $t.z);
    return this;
  },
  set: function (t, e) {
    return e === void 0 && (e = 0), this.array.set(t, e), this;
  },
  getX: function (t) {
    return this.array[t * this.itemSize];
  },
  setX: function (t, e) {
    return (this.array[t * this.itemSize] = e), this;
  },
  getY: function (t) {
    return this.array[t * this.itemSize + 1];
  },
  setY: function (t, e) {
    return (this.array[t * this.itemSize + 1] = e), this;
  },
  getZ: function (t) {
    return this.array[t * this.itemSize + 2];
  },
  setZ: function (t, e) {
    return (this.array[t * this.itemSize + 2] = e), this;
  },
  getW: function (t) {
    return this.array[t * this.itemSize + 3];
  },
  setW: function (t, e) {
    return (this.array[t * this.itemSize + 3] = e), this;
  },
  setXY: function (t, e, n) {
    return (
      (t *= this.itemSize),
      (this.array[t + 0] = e),
      (this.array[t + 1] = n),
      this
    );
  },
  setXYZ: function (t, e, n, i) {
    return (
      (t *= this.itemSize),
      (this.array[t + 0] = e),
      (this.array[t + 1] = n),
      (this.array[t + 2] = i),
      this
    );
  },
  setXYZW: function (t, e, n, i, r) {
    return (
      (t *= this.itemSize),
      (this.array[t + 0] = e),
      (this.array[t + 1] = n),
      (this.array[t + 2] = i),
      (this.array[t + 3] = r),
      this
    );
  },
  onUpload: function (t) {
    return (this.onUploadCallback = t), this;
  },
  clone: function () {
    return new this.constructor(this.array, this.itemSize).copy(this);
  },
  toJSON: function () {
    return {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized,
    };
  },
});
function fh(t, e, n) {
  wt.call(this, new Int8Array(t), e, n);
}
fh.prototype = Object.create(wt.prototype);
fh.prototype.constructor = fh;
function dh(t, e, n) {
  wt.call(this, new Uint8Array(t), e, n);
}
dh.prototype = Object.create(wt.prototype);
dh.prototype.constructor = dh;
function ph(t, e, n) {
  wt.call(this, new Uint8ClampedArray(t), e, n);
}
ph.prototype = Object.create(wt.prototype);
ph.prototype.constructor = ph;
function mh(t, e, n) {
  wt.call(this, new Int16Array(t), e, n);
}
mh.prototype = Object.create(wt.prototype);
mh.prototype.constructor = mh;
function To(t, e, n) {
  wt.call(this, new Uint16Array(t), e, n);
}
To.prototype = Object.create(wt.prototype);
To.prototype.constructor = To;
function gh(t, e, n) {
  wt.call(this, new Int32Array(t), e, n);
}
gh.prototype = Object.create(wt.prototype);
gh.prototype.constructor = gh;
function Eo(t, e, n) {
  wt.call(this, new Uint32Array(t), e, n);
}
Eo.prototype = Object.create(wt.prototype);
Eo.prototype.constructor = Eo;
function rt(t, e, n) {
  wt.call(this, new Float32Array(t), e, n);
}
rt.prototype = Object.create(wt.prototype);
rt.prototype.constructor = rt;
function yh(t, e, n) {
  wt.call(this, new Float64Array(t), e, n);
}
yh.prototype = Object.create(wt.prototype);
yh.prototype.constructor = yh;
function Zp() {
  (this.vertices = []),
    (this.normals = []),
    (this.colors = []),
    (this.uvs = []),
    (this.uvs2 = []),
    (this.groups = []),
    (this.morphTargets = {}),
    (this.skinWeights = []),
    (this.skinIndices = []),
    (this.boundingBox = null),
    (this.boundingSphere = null),
    (this.verticesNeedUpdate = !1),
    (this.normalsNeedUpdate = !1),
    (this.colorsNeedUpdate = !1),
    (this.uvsNeedUpdate = !1),
    (this.groupsNeedUpdate = !1);
}
Object.assign(Zp.prototype, {
  computeGroups: function (t) {
    const e = [];
    let n, i, r;
    const s = t.faces;
    for (i = 0; i < s.length; i++) {
      const o = s[i];
      o.materialIndex !== r &&
        ((r = o.materialIndex),
        n !== void 0 && ((n.count = i * 3 - n.start), e.push(n)),
        (n = { start: i * 3, materialIndex: r }));
    }
    n !== void 0 && ((n.count = i * 3 - n.start), e.push(n)), (this.groups = e);
  },
  fromGeometry: function (t) {
    const e = t.faces,
      n = t.vertices,
      i = t.faceVertexUvs,
      r = i[0] && i[0].length > 0,
      s = i[1] && i[1].length > 0,
      o = t.morphTargets,
      a = o.length;
    let c;
    if (a > 0) {
      c = [];
      for (let y = 0; y < a; y++) c[y] = { name: o[y].name, data: [] };
      this.morphTargets.position = c;
    }
    const l = t.morphNormals,
      u = l.length;
    let h;
    if (u > 0) {
      h = [];
      for (let y = 0; y < u; y++) h[y] = { name: l[y].name, data: [] };
      this.morphTargets.normal = h;
    }
    const d = t.skinIndices,
      f = t.skinWeights,
      p = d.length === n.length,
      _ = f.length === n.length;
    n.length > 0 &&
      e.length === 0 &&
      console.error(
        "THREE.DirectGeometry: Faceless geometries are not supported."
      );
    for (let y = 0; y < e.length; y++) {
      const m = e[y];
      this.vertices.push(n[m.a], n[m.b], n[m.c]);
      const g = m.vertexNormals;
      if (g.length === 3) this.normals.push(g[0], g[1], g[2]);
      else {
        const x = m.normal;
        this.normals.push(x, x, x);
      }
      const b = m.vertexColors;
      if (b.length === 3) this.colors.push(b[0], b[1], b[2]);
      else {
        const x = m.color;
        this.colors.push(x, x, x);
      }
      if (r === !0) {
        const x = i[0][y];
        x !== void 0
          ? this.uvs.push(x[0], x[1], x[2])
          : (console.warn(
              "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
              y
            ),
            this.uvs.push(new H(), new H(), new H()));
      }
      if (s === !0) {
        const x = i[1][y];
        x !== void 0
          ? this.uvs2.push(x[0], x[1], x[2])
          : (console.warn(
              "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
              y
            ),
            this.uvs2.push(new H(), new H(), new H()));
      }
      for (let x = 0; x < a; x++) {
        const v = o[x].vertices;
        c[x].data.push(v[m.a], v[m.b], v[m.c]);
      }
      for (let x = 0; x < u; x++) {
        const v = l[x].vertexNormals[y];
        h[x].data.push(v.a, v.b, v.c);
      }
      p && this.skinIndices.push(d[m.a], d[m.b], d[m.c]),
        _ && this.skinWeights.push(f[m.a], f[m.b], f[m.c]);
    }
    return (
      this.computeGroups(t),
      (this.verticesNeedUpdate = t.verticesNeedUpdate),
      (this.normalsNeedUpdate = t.normalsNeedUpdate),
      (this.colorsNeedUpdate = t.colorsNeedUpdate),
      (this.uvsNeedUpdate = t.uvsNeedUpdate),
      (this.groupsNeedUpdate = t.groupsNeedUpdate),
      t.boundingSphere !== null &&
        (this.boundingSphere = t.boundingSphere.clone()),
      t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()),
      this
    );
  },
});
function Jp(t) {
  if (t.length === 0) return -1 / 0;
  let e = t[0];
  for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
  return e;
}
let wx = 1;
const Wn = new Rt(),
  _h = new nt(),
  ps = new S(),
  sn = new Hn(),
  Ao = new Hn(),
  Le = new S();
function ct() {
  Object.defineProperty(this, "id", { value: (wx += 2) }),
    (this.uuid = Pt.generateUUID()),
    (this.name = ""),
    (this.type = "BufferGeometry"),
    (this.index = null),
    (this.attributes = {}),
    (this.morphAttributes = {}),
    (this.morphTargetsRelative = !1),
    (this.groups = []),
    (this.boundingBox = null),
    (this.boundingSphere = null),
    (this.drawRange = { start: 0, count: 1 / 0 }),
    (this.userData = {});
}
ct.prototype = Object.assign(Object.create(si.prototype), {
  constructor: ct,
  isBufferGeometry: !0,
  getIndex: function () {
    return this.index;
  },
  setIndex: function (t) {
    Array.isArray(t)
      ? (this.index = new (Jp(t) > 65535 ? Eo : To)(t, 1))
      : (this.index = t);
  },
  getAttribute: function (t) {
    return this.attributes[t];
  },
  setAttribute: function (t, e) {
    return (this.attributes[t] = e), this;
  },
  deleteAttribute: function (t) {
    return delete this.attributes[t], this;
  },
  addGroup: function (t, e, n) {
    this.groups.push({
      start: t,
      count: e,
      materialIndex: n !== void 0 ? n : 0,
    });
  },
  clearGroups: function () {
    this.groups = [];
  },
  setDrawRange: function (t, e) {
    (this.drawRange.start = t), (this.drawRange.count = e);
  },
  applyMatrix4: function (t) {
    const e = this.attributes.position;
    e !== void 0 && (e.applyMatrix4(t), (e.needsUpdate = !0));
    const n = this.attributes.normal;
    if (n !== void 0) {
      const r = new Ge().getNormalMatrix(t);
      n.applyNormalMatrix(r), (n.needsUpdate = !0);
    }
    const i = this.attributes.tangent;
    return (
      i !== void 0 && (i.transformDirection(t), (i.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  },
  rotateX: function (t) {
    return Wn.makeRotationX(t), this.applyMatrix4(Wn), this;
  },
  rotateY: function (t) {
    return Wn.makeRotationY(t), this.applyMatrix4(Wn), this;
  },
  rotateZ: function (t) {
    return Wn.makeRotationZ(t), this.applyMatrix4(Wn), this;
  },
  translate: function (t, e, n) {
    return Wn.makeTranslation(t, e, n), this.applyMatrix4(Wn), this;
  },
  scale: function (t, e, n) {
    return Wn.makeScale(t, e, n), this.applyMatrix4(Wn), this;
  },
  lookAt: function (t) {
    return _h.lookAt(t), _h.updateMatrix(), this.applyMatrix4(_h.matrix), this;
  },
  center: function () {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(ps).negate(),
      this.translate(ps.x, ps.y, ps.z),
      this
    );
  },
  setFromObject: function (t) {
    const e = t.geometry;
    if (t.isPoints || t.isLine) {
      const n = new rt(e.vertices.length * 3, 3),
        i = new rt(e.colors.length * 3, 3);
      if (
        (this.setAttribute("position", n.copyVector3sArray(e.vertices)),
        this.setAttribute("color", i.copyColorsArray(e.colors)),
        e.lineDistances && e.lineDistances.length === e.vertices.length)
      ) {
        const r = new rt(e.lineDistances.length, 1);
        this.setAttribute("lineDistance", r.copyArray(e.lineDistances));
      }
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone());
    } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
    return this;
  },
  setFromPoints: function (t) {
    const e = [];
    for (let n = 0, i = t.length; n < i; n++) {
      const r = t[n];
      e.push(r.x, r.y, r.z || 0);
    }
    return this.setAttribute("position", new rt(e, 3)), this;
  },
  updateFromObject: function (t) {
    let e = t.geometry;
    if (t.isMesh) {
      let n = e.__directGeometry;
      if (
        (e.elementsNeedUpdate === !0 &&
          ((n = void 0), (e.elementsNeedUpdate = !1)),
        n === void 0)
      )
        return this.fromGeometry(e);
      (n.verticesNeedUpdate = e.verticesNeedUpdate),
        (n.normalsNeedUpdate = e.normalsNeedUpdate),
        (n.colorsNeedUpdate = e.colorsNeedUpdate),
        (n.uvsNeedUpdate = e.uvsNeedUpdate),
        (n.groupsNeedUpdate = e.groupsNeedUpdate),
        (e.verticesNeedUpdate = !1),
        (e.normalsNeedUpdate = !1),
        (e.colorsNeedUpdate = !1),
        (e.uvsNeedUpdate = !1),
        (e.groupsNeedUpdate = !1),
        (e = n);
    }
    if (e.verticesNeedUpdate === !0) {
      const n = this.attributes.position;
      n !== void 0 && (n.copyVector3sArray(e.vertices), (n.needsUpdate = !0)),
        (e.verticesNeedUpdate = !1);
    }
    if (e.normalsNeedUpdate === !0) {
      const n = this.attributes.normal;
      n !== void 0 && (n.copyVector3sArray(e.normals), (n.needsUpdate = !0)),
        (e.normalsNeedUpdate = !1);
    }
    if (e.colorsNeedUpdate === !0) {
      const n = this.attributes.color;
      n !== void 0 && (n.copyColorsArray(e.colors), (n.needsUpdate = !0)),
        (e.colorsNeedUpdate = !1);
    }
    if (e.uvsNeedUpdate) {
      const n = this.attributes.uv;
      n !== void 0 && (n.copyVector2sArray(e.uvs), (n.needsUpdate = !0)),
        (e.uvsNeedUpdate = !1);
    }
    if (e.lineDistancesNeedUpdate) {
      const n = this.attributes.lineDistance;
      n !== void 0 && (n.copyArray(e.lineDistances), (n.needsUpdate = !0)),
        (e.lineDistancesNeedUpdate = !1);
    }
    return (
      e.groupsNeedUpdate &&
        (e.computeGroups(t.geometry),
        (this.groups = e.groups),
        (e.groupsNeedUpdate = !1)),
      this
    );
  },
  fromGeometry: function (t) {
    return (
      (t.__directGeometry = new Zp().fromGeometry(t)),
      this.fromDirectGeometry(t.__directGeometry)
    );
  },
  fromDirectGeometry: function (t) {
    const e = new Float32Array(t.vertices.length * 3);
    if (
      (this.setAttribute(
        "position",
        new wt(e, 3).copyVector3sArray(t.vertices)
      ),
      t.normals.length > 0)
    ) {
      const n = new Float32Array(t.normals.length * 3);
      this.setAttribute("normal", new wt(n, 3).copyVector3sArray(t.normals));
    }
    if (t.colors.length > 0) {
      const n = new Float32Array(t.colors.length * 3);
      this.setAttribute("color", new wt(n, 3).copyColorsArray(t.colors));
    }
    if (t.uvs.length > 0) {
      const n = new Float32Array(t.uvs.length * 2);
      this.setAttribute("uv", new wt(n, 2).copyVector2sArray(t.uvs));
    }
    if (t.uvs2.length > 0) {
      const n = new Float32Array(t.uvs2.length * 2);
      this.setAttribute("uv2", new wt(n, 2).copyVector2sArray(t.uvs2));
    }
    this.groups = t.groups;
    for (const n in t.morphTargets) {
      const i = [],
        r = t.morphTargets[n];
      for (let s = 0, o = r.length; s < o; s++) {
        const a = r[s],
          c = new rt(a.data.length * 3, 3);
        (c.name = a.name), i.push(c.copyVector3sArray(a.data));
      }
      this.morphAttributes[n] = i;
    }
    if (t.skinIndices.length > 0) {
      const n = new rt(t.skinIndices.length * 4, 4);
      this.setAttribute("skinIndex", n.copyVector4sArray(t.skinIndices));
    }
    if (t.skinWeights.length > 0) {
      const n = new rt(t.skinWeights.length * 4, 4);
      this.setAttribute("skinWeight", n.copyVector4sArray(t.skinWeights));
    }
    return (
      t.boundingSphere !== null &&
        (this.boundingSphere = t.boundingSphere.clone()),
      t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()),
      this
    );
  },
  computeBoundingBox: function () {
    this.boundingBox === null && (this.boundingBox = new Hn());
    const t = this.attributes.position,
      e = this.morphAttributes.position;
    if (t !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(t), e))
        for (let n = 0, i = e.length; n < i; n++) {
          const r = e[n];
          sn.setFromBufferAttribute(r),
            this.morphTargetsRelative
              ? (Le.addVectors(this.boundingBox.min, sn.min),
                this.boundingBox.expandByPoint(Le),
                Le.addVectors(this.boundingBox.max, sn.max),
                this.boundingBox.expandByPoint(Le))
              : (this.boundingBox.expandByPoint(sn.min),
                this.boundingBox.expandByPoint(sn.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  },
  computeBoundingSphere: function () {
    this.boundingSphere === null && (this.boundingSphere = new ci());
    const t = this.attributes.position,
      e = this.morphAttributes.position;
    if (t) {
      const n = this.boundingSphere.center;
      if ((sn.setFromBufferAttribute(t), e))
        for (let r = 0, s = e.length; r < s; r++) {
          const o = e[r];
          Ao.setFromBufferAttribute(o),
            this.morphTargetsRelative
              ? (Le.addVectors(sn.min, Ao.min),
                sn.expandByPoint(Le),
                Le.addVectors(sn.max, Ao.max),
                sn.expandByPoint(Le))
              : (sn.expandByPoint(Ao.min), sn.expandByPoint(Ao.max));
        }
      sn.getCenter(n);
      let i = 0;
      for (let r = 0, s = t.count; r < s; r++)
        Le.fromBufferAttribute(t, r),
          (i = Math.max(i, n.distanceToSquared(Le)));
      if (e)
        for (let r = 0, s = e.length; r < s; r++) {
          const o = e[r],
            a = this.morphTargetsRelative;
          for (let c = 0, l = o.count; c < l; c++)
            Le.fromBufferAttribute(o, c),
              a && (ps.fromBufferAttribute(t, c), Le.add(ps)),
              (i = Math.max(i, n.distanceToSquared(Le)));
        }
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  },
  computeFaceNormals: function () {},
  computeVertexNormals: function () {
    const t = this.index,
      e = this.getAttribute("position");
    if (e !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        (n = new wt(new Float32Array(e.count * 3), 3)),
          this.setAttribute("normal", n);
      else for (let h = 0, d = n.count; h < d; h++) n.setXYZ(h, 0, 0, 0);
      const i = new S(),
        r = new S(),
        s = new S(),
        o = new S(),
        a = new S(),
        c = new S(),
        l = new S(),
        u = new S();
      if (t)
        for (let h = 0, d = t.count; h < d; h += 3) {
          const f = t.getX(h + 0),
            p = t.getX(h + 1),
            _ = t.getX(h + 2);
          i.fromBufferAttribute(e, f),
            r.fromBufferAttribute(e, p),
            s.fromBufferAttribute(e, _),
            l.subVectors(s, r),
            u.subVectors(i, r),
            l.cross(u),
            o.fromBufferAttribute(n, f),
            a.fromBufferAttribute(n, p),
            c.fromBufferAttribute(n, _),
            o.add(l),
            a.add(l),
            c.add(l),
            n.setXYZ(f, o.x, o.y, o.z),
            n.setXYZ(p, a.x, a.y, a.z),
            n.setXYZ(_, c.x, c.y, c.z);
        }
      else
        for (let h = 0, d = e.count; h < d; h += 3)
          i.fromBufferAttribute(e, h + 0),
            r.fromBufferAttribute(e, h + 1),
            s.fromBufferAttribute(e, h + 2),
            l.subVectors(s, r),
            u.subVectors(i, r),
            l.cross(u),
            n.setXYZ(h + 0, l.x, l.y, l.z),
            n.setXYZ(h + 1, l.x, l.y, l.z),
            n.setXYZ(h + 2, l.x, l.y, l.z);
      this.normalizeNormals(), (n.needsUpdate = !0);
    }
  },
  merge: function (t, e) {
    if (!(t && t.isBufferGeometry)) {
      console.error(
        "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
        t
      );
      return;
    }
    e === void 0 &&
      ((e = 0),
      console.warn(
        "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
      ));
    const n = this.attributes;
    for (const i in n) {
      if (t.attributes[i] === void 0) continue;
      const s = n[i].array,
        o = t.attributes[i],
        a = o.array,
        c = o.itemSize * e,
        l = Math.min(a.length, s.length - c);
      for (let u = 0, h = c; u < l; u++, h++) s[h] = a[u];
    }
    return this;
  },
  normalizeNormals: function () {
    const t = this.attributes.normal;
    for (let e = 0, n = t.count; e < n; e++)
      Le.fromBufferAttribute(t, e),
        Le.normalize(),
        t.setXYZ(e, Le.x, Le.y, Le.z);
  },
  toNonIndexed: function () {
    function t(o, a) {
      const c = o.array,
        l = o.itemSize,
        u = o.normalized,
        h = new c.constructor(a.length * l);
      let d = 0,
        f = 0;
      for (let p = 0, _ = a.length; p < _; p++) {
        d = a[p] * l;
        for (let y = 0; y < l; y++) h[f++] = c[d++];
      }
      return new wt(h, l, u);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."
        ),
        this
      );
    const e = new ct(),
      n = this.index.array,
      i = this.attributes;
    for (const o in i) {
      const a = i[o],
        c = t(a, n);
      e.setAttribute(o, c);
    }
    const r = this.morphAttributes;
    for (const o in r) {
      const a = [],
        c = r[o];
      for (let l = 0, u = c.length; l < u; l++) {
        const h = c[l],
          d = t(h, n);
        a.push(d);
      }
      e.morphAttributes[o] = a;
    }
    e.morphTargetsRelative = this.morphTargetsRelative;
    const s = this.groups;
    for (let o = 0, a = s.length; o < a; o++) {
      const c = s[o];
      e.addGroup(c.start, c.count, c.materialIndex);
    }
    return e;
  },
  toJSON: function () {
    const t = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((t.uuid = this.uuid),
      (t.type = this.type),
      this.name !== "" && (t.name = this.name),
      Object.keys(this.userData).length > 0 && (t.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const a = this.parameters;
      for (const c in a) a[c] !== void 0 && (t[c] = a[c]);
      return t;
    }
    t.data = { attributes: {} };
    const e = this.index;
    e !== null &&
      (t.data.index = {
        type: e.array.constructor.name,
        array: Array.prototype.slice.call(e.array),
      });
    const n = this.attributes;
    for (const a in n) {
      const c = n[a],
        l = c.toJSON(t.data);
      c.name !== "" && (l.name = c.name), (t.data.attributes[a] = l);
    }
    const i = {};
    let r = !1;
    for (const a in this.morphAttributes) {
      const c = this.morphAttributes[a],
        l = [];
      for (let u = 0, h = c.length; u < h; u++) {
        const d = c[u],
          f = d.toJSON(t.data);
        d.name !== "" && (f.name = d.name), l.push(f);
      }
      l.length > 0 && ((i[a] = l), (r = !0));
    }
    r &&
      ((t.data.morphAttributes = i),
      (t.data.morphTargetsRelative = this.morphTargetsRelative));
    const s = this.groups;
    s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
    const o = this.boundingSphere;
    return (
      o !== null &&
        (t.data.boundingSphere = {
          center: o.center.toArray(),
          radius: o.radius,
        }),
      t
    );
  },
  clone: function () {
    return new ct().copy(this);
  },
  copy: function (t) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const e = {};
    this.name = t.name;
    const n = t.index;
    n !== null && this.setIndex(n.clone(e));
    const i = t.attributes;
    for (const c in i) {
      const l = i[c];
      this.setAttribute(c, l.clone(e));
    }
    const r = t.morphAttributes;
    for (const c in r) {
      const l = [],
        u = r[c];
      for (let h = 0, d = u.length; h < d; h++) l.push(u[h].clone(e));
      this.morphAttributes[c] = l;
    }
    this.morphTargetsRelative = t.morphTargetsRelative;
    const s = t.groups;
    for (let c = 0, l = s.length; c < l; c++) {
      const u = s[c];
      this.addGroup(u.start, u.count, u.materialIndex);
    }
    const o = t.boundingBox;
    o !== null && (this.boundingBox = o.clone());
    const a = t.boundingSphere;
    return (
      a !== null && (this.boundingSphere = a.clone()),
      (this.drawRange.start = t.drawRange.start),
      (this.drawRange.count = t.drawRange.count),
      (this.userData = t.userData),
      this
    );
  },
  dispose: function () {
    this.dispatchEvent({ type: "dispose" });
  },
});
const $p = new Rt(),
  hr = new hs(),
  xh = new ci(),
  Ii = new S(),
  Ni = new S(),
  Fi = new S(),
  vh = new S(),
  bh = new S(),
  wh = new S(),
  wc = new S(),
  Mc = new S(),
  Sc = new S(),
  ms = new H(),
  gs = new H(),
  ys = new H(),
  Lo = new S(),
  Tc = new S();
function he(t, e) {
  nt.call(this),
    (this.type = "Mesh"),
    (this.geometry = t !== void 0 ? t : new ct()),
    (this.material = e !== void 0 ? e : new Ln()),
    this.updateMorphTargets();
}
he.prototype = Object.assign(Object.create(nt.prototype), {
  constructor: he,
  isMesh: !0,
  copy: function (t) {
    return (
      nt.prototype.copy.call(this, t),
      t.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
      t.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          t.morphTargetDictionary
        )),
      (this.material = t.material),
      (this.geometry = t.geometry),
      this
    );
  },
  updateMorphTargets: function () {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      const e = t.morphAttributes,
        n = Object.keys(e);
      if (n.length > 0) {
        const i = e[n[0]];
        if (i !== void 0) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let r = 0, s = i.length; r < s; r++) {
            const o = i[r].name || String(r);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[o] = r);
          }
        }
      }
    } else {
      const e = t.morphTargets;
      e !== void 0 &&
        e.length > 0 &&
        console.error(
          "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
        );
    }
  },
  raycast: function (t, e) {
    const n = this.geometry,
      i = this.material,
      r = this.matrixWorld;
    if (
      i === void 0 ||
      (n.boundingSphere === null && n.computeBoundingSphere(),
      xh.copy(n.boundingSphere),
      xh.applyMatrix4(r),
      t.ray.intersectsSphere(xh) === !1) ||
      ($p.getInverse(r),
      hr.copy(t.ray).applyMatrix4($p),
      n.boundingBox !== null && hr.intersectsBox(n.boundingBox) === !1)
    )
      return;
    let s;
    if (n.isBufferGeometry) {
      const o = n.index,
        a = n.attributes.position,
        c = n.morphAttributes.position,
        l = n.morphTargetsRelative,
        u = n.attributes.uv,
        h = n.attributes.uv2,
        d = n.groups,
        f = n.drawRange;
      if (o !== null)
        if (Array.isArray(i))
          for (let p = 0, _ = d.length; p < _; p++) {
            const y = d[p],
              m = i[y.materialIndex],
              g = Math.max(y.start, f.start),
              b = Math.min(y.start + y.count, f.start + f.count);
            for (let x = g, v = b; x < v; x += 3) {
              const w = o.getX(x),
                M = o.getX(x + 1),
                C = o.getX(x + 2);
              (s = Ec(this, m, t, hr, a, c, l, u, h, w, M, C)),
                s &&
                  ((s.faceIndex = Math.floor(x / 3)),
                  (s.face.materialIndex = y.materialIndex),
                  e.push(s));
            }
          }
        else {
          const p = Math.max(0, f.start),
            _ = Math.min(o.count, f.start + f.count);
          for (let y = p, m = _; y < m; y += 3) {
            const g = o.getX(y),
              b = o.getX(y + 1),
              x = o.getX(y + 2);
            (s = Ec(this, i, t, hr, a, c, l, u, h, g, b, x)),
              s && ((s.faceIndex = Math.floor(y / 3)), e.push(s));
          }
        }
      else if (a !== void 0)
        if (Array.isArray(i))
          for (let p = 0, _ = d.length; p < _; p++) {
            const y = d[p],
              m = i[y.materialIndex],
              g = Math.max(y.start, f.start),
              b = Math.min(y.start + y.count, f.start + f.count);
            for (let x = g, v = b; x < v; x += 3) {
              const w = x,
                M = x + 1,
                C = x + 2;
              (s = Ec(this, m, t, hr, a, c, l, u, h, w, M, C)),
                s &&
                  ((s.faceIndex = Math.floor(x / 3)),
                  (s.face.materialIndex = y.materialIndex),
                  e.push(s));
            }
          }
        else {
          const p = Math.max(0, f.start),
            _ = Math.min(a.count, f.start + f.count);
          for (let y = p, m = _; y < m; y += 3) {
            const g = y,
              b = y + 1,
              x = y + 2;
            (s = Ec(this, i, t, hr, a, c, l, u, h, g, b, x)),
              s && ((s.faceIndex = Math.floor(y / 3)), e.push(s));
          }
        }
    } else if (n.isGeometry) {
      const o = Array.isArray(i),
        a = n.vertices,
        c = n.faces;
      let l;
      const u = n.faceVertexUvs[0];
      u.length > 0 && (l = u);
      for (let h = 0, d = c.length; h < d; h++) {
        const f = c[h],
          p = o ? i[f.materialIndex] : i;
        if (p === void 0) continue;
        const _ = a[f.a],
          y = a[f.b],
          m = a[f.c];
        if (((s = Qp(this, p, t, hr, _, y, m, Lo)), s)) {
          if (l && l[h]) {
            const g = l[h];
            ms.copy(g[0]),
              gs.copy(g[1]),
              ys.copy(g[2]),
              (s.uv = Re.getUV(Lo, _, y, m, ms, gs, ys, new H()));
          }
          (s.face = f), (s.faceIndex = h), e.push(s);
        }
      }
    }
  },
});
function Qp(t, e, n, i, r, s, o, a) {
  let c;
  if (
    (e.side === Ee
      ? (c = i.intersectTriangle(o, s, r, !0, a))
      : (c = i.intersectTriangle(r, s, o, e.side !== Ka, a)),
    c === null)
  )
    return null;
  Tc.copy(a), Tc.applyMatrix4(t.matrixWorld);
  const l = n.ray.origin.distanceTo(Tc);
  return l < n.near || l > n.far
    ? null
    : { distance: l, point: Tc.clone(), object: t };
}
function Ec(t, e, n, i, r, s, o, a, c, l, u, h) {
  Ii.fromBufferAttribute(r, l),
    Ni.fromBufferAttribute(r, u),
    Fi.fromBufferAttribute(r, h);
  const d = t.morphTargetInfluences;
  if (e.morphTargets && s && d) {
    wc.set(0, 0, 0), Mc.set(0, 0, 0), Sc.set(0, 0, 0);
    for (let p = 0, _ = s.length; p < _; p++) {
      const y = d[p],
        m = s[p];
      y !== 0 &&
        (vh.fromBufferAttribute(m, l),
        bh.fromBufferAttribute(m, u),
        wh.fromBufferAttribute(m, h),
        o
          ? (wc.addScaledVector(vh, y),
            Mc.addScaledVector(bh, y),
            Sc.addScaledVector(wh, y))
          : (wc.addScaledVector(vh.sub(Ii), y),
            Mc.addScaledVector(bh.sub(Ni), y),
            Sc.addScaledVector(wh.sub(Fi), y)));
    }
    Ii.add(wc), Ni.add(Mc), Fi.add(Sc);
  }
  t.isSkinnedMesh &&
    (t.boneTransform(l, Ii), t.boneTransform(u, Ni), t.boneTransform(h, Fi));
  const f = Qp(t, e, n, i, Ii, Ni, Fi, Lo);
  if (f) {
    a &&
      (ms.fromBufferAttribute(a, l),
      gs.fromBufferAttribute(a, u),
      ys.fromBufferAttribute(a, h),
      (f.uv = Re.getUV(Lo, Ii, Ni, Fi, ms, gs, ys, new H()))),
      c &&
        (ms.fromBufferAttribute(c, l),
        gs.fromBufferAttribute(c, u),
        ys.fromBufferAttribute(c, h),
        (f.uv2 = Re.getUV(Lo, Ii, Ni, Fi, ms, gs, ys, new H())));
    const p = new vc(l, u, h);
    Re.getNormal(Ii, Ni, Fi, p.normal), (f.face = p);
  }
  return f;
}
let Mx = 0;
const jn = new Rt(),
  Mh = new nt(),
  Ac = new S();
function Mt() {
  Object.defineProperty(this, "id", { value: (Mx += 2) }),
    (this.uuid = Pt.generateUUID()),
    (this.name = ""),
    (this.type = "Geometry"),
    (this.vertices = []),
    (this.colors = []),
    (this.faces = []),
    (this.faceVertexUvs = [[]]),
    (this.morphTargets = []),
    (this.morphNormals = []),
    (this.skinWeights = []),
    (this.skinIndices = []),
    (this.lineDistances = []),
    (this.boundingBox = null),
    (this.boundingSphere = null),
    (this.elementsNeedUpdate = !1),
    (this.verticesNeedUpdate = !1),
    (this.uvsNeedUpdate = !1),
    (this.normalsNeedUpdate = !1),
    (this.colorsNeedUpdate = !1),
    (this.lineDistancesNeedUpdate = !1),
    (this.groupsNeedUpdate = !1);
}
Mt.prototype = Object.assign(Object.create(si.prototype), {
  constructor: Mt,
  isGeometry: !0,
  applyMatrix4: function (t) {
    const e = new Ge().getNormalMatrix(t);
    for (let n = 0, i = this.vertices.length; n < i; n++)
      this.vertices[n].applyMatrix4(t);
    for (let n = 0, i = this.faces.length; n < i; n++) {
      const r = this.faces[n];
      r.normal.applyMatrix3(e).normalize();
      for (let s = 0, o = r.vertexNormals.length; s < o; s++)
        r.vertexNormals[s].applyMatrix3(e).normalize();
    }
    return (
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      (this.verticesNeedUpdate = !0),
      (this.normalsNeedUpdate = !0),
      this
    );
  },
  rotateX: function (t) {
    return jn.makeRotationX(t), this.applyMatrix4(jn), this;
  },
  rotateY: function (t) {
    return jn.makeRotationY(t), this.applyMatrix4(jn), this;
  },
  rotateZ: function (t) {
    return jn.makeRotationZ(t), this.applyMatrix4(jn), this;
  },
  translate: function (t, e, n) {
    return jn.makeTranslation(t, e, n), this.applyMatrix4(jn), this;
  },
  scale: function (t, e, n) {
    return jn.makeScale(t, e, n), this.applyMatrix4(jn), this;
  },
  lookAt: function (t) {
    return Mh.lookAt(t), Mh.updateMatrix(), this.applyMatrix4(Mh.matrix), this;
  },
  fromBufferGeometry: function (t) {
    const e = this,
      n = t.index !== null ? t.index : void 0,
      i = t.attributes;
    if (i.position === void 0)
      return (
        console.error(
          "THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."
        ),
        this
      );
    const r = i.position,
      s = i.normal,
      o = i.color,
      a = i.uv,
      c = i.uv2;
    c !== void 0 && (this.faceVertexUvs[1] = []);
    for (let h = 0; h < r.count; h++)
      e.vertices.push(new S().fromBufferAttribute(r, h)),
        o !== void 0 && e.colors.push(new lt().fromBufferAttribute(o, h));
    function l(h, d, f, p) {
      const _ =
          o === void 0
            ? []
            : [e.colors[h].clone(), e.colors[d].clone(), e.colors[f].clone()],
        y =
          s === void 0
            ? []
            : [
                new S().fromBufferAttribute(s, h),
                new S().fromBufferAttribute(s, d),
                new S().fromBufferAttribute(s, f),
              ],
        m = new vc(h, d, f, y, _, p);
      e.faces.push(m),
        a !== void 0 &&
          e.faceVertexUvs[0].push([
            new H().fromBufferAttribute(a, h),
            new H().fromBufferAttribute(a, d),
            new H().fromBufferAttribute(a, f),
          ]),
        c !== void 0 &&
          e.faceVertexUvs[1].push([
            new H().fromBufferAttribute(c, h),
            new H().fromBufferAttribute(c, d),
            new H().fromBufferAttribute(c, f),
          ]);
    }
    const u = t.groups;
    if (u.length > 0)
      for (let h = 0; h < u.length; h++) {
        const d = u[h],
          f = d.start,
          p = d.count;
        for (let _ = f, y = f + p; _ < y; _ += 3)
          n !== void 0
            ? l(n.getX(_), n.getX(_ + 1), n.getX(_ + 2), d.materialIndex)
            : l(_, _ + 1, _ + 2, d.materialIndex);
      }
    else if (n !== void 0)
      for (let h = 0; h < n.count; h += 3)
        l(n.getX(h), n.getX(h + 1), n.getX(h + 2));
    else for (let h = 0; h < r.count; h += 3) l(h, h + 1, h + 2);
    return (
      this.computeFaceNormals(),
      t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()),
      t.boundingSphere !== null &&
        (this.boundingSphere = t.boundingSphere.clone()),
      this
    );
  },
  center: function () {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(Ac).negate(),
      this.translate(Ac.x, Ac.y, Ac.z),
      this
    );
  },
  normalize: function () {
    this.computeBoundingSphere();
    const t = this.boundingSphere.center,
      e = this.boundingSphere.radius,
      n = e === 0 ? 1 : 1 / e,
      i = new Rt();
    return (
      i.set(
        n,
        0,
        0,
        -n * t.x,
        0,
        n,
        0,
        -n * t.y,
        0,
        0,
        n,
        -n * t.z,
        0,
        0,
        0,
        1
      ),
      this.applyMatrix4(i),
      this
    );
  },
  computeFaceNormals: function () {
    const t = new S(),
      e = new S();
    for (let n = 0, i = this.faces.length; n < i; n++) {
      const r = this.faces[n],
        s = this.vertices[r.a],
        o = this.vertices[r.b],
        a = this.vertices[r.c];
      t.subVectors(a, o),
        e.subVectors(s, o),
        t.cross(e),
        t.normalize(),
        r.normal.copy(t);
    }
  },
  computeVertexNormals: function (t) {
    t === void 0 && (t = !0);
    const e = new Array(this.vertices.length);
    for (let n = 0, i = this.vertices.length; n < i; n++) e[n] = new S();
    if (t) {
      const n = new S(),
        i = new S();
      for (let r = 0, s = this.faces.length; r < s; r++) {
        const o = this.faces[r],
          a = this.vertices[o.a],
          c = this.vertices[o.b],
          l = this.vertices[o.c];
        n.subVectors(l, c),
          i.subVectors(a, c),
          n.cross(i),
          e[o.a].add(n),
          e[o.b].add(n),
          e[o.c].add(n);
      }
    } else {
      this.computeFaceNormals();
      for (let n = 0, i = this.faces.length; n < i; n++) {
        const r = this.faces[n];
        e[r.a].add(r.normal), e[r.b].add(r.normal), e[r.c].add(r.normal);
      }
    }
    for (let n = 0, i = this.vertices.length; n < i; n++) e[n].normalize();
    for (let n = 0, i = this.faces.length; n < i; n++) {
      const r = this.faces[n],
        s = r.vertexNormals;
      s.length === 3
        ? (s[0].copy(e[r.a]), s[1].copy(e[r.b]), s[2].copy(e[r.c]))
        : ((s[0] = e[r.a].clone()),
          (s[1] = e[r.b].clone()),
          (s[2] = e[r.c].clone()));
    }
    this.faces.length > 0 && (this.normalsNeedUpdate = !0);
  },
  computeFlatVertexNormals: function () {
    this.computeFaceNormals();
    for (let t = 0, e = this.faces.length; t < e; t++) {
      const n = this.faces[t],
        i = n.vertexNormals;
      i.length === 3
        ? (i[0].copy(n.normal), i[1].copy(n.normal), i[2].copy(n.normal))
        : ((i[0] = n.normal.clone()),
          (i[1] = n.normal.clone()),
          (i[2] = n.normal.clone()));
    }
    this.faces.length > 0 && (this.normalsNeedUpdate = !0);
  },
  computeMorphNormals: function () {
    for (let e = 0, n = this.faces.length; e < n; e++) {
      const i = this.faces[e];
      i.__originalFaceNormal
        ? i.__originalFaceNormal.copy(i.normal)
        : (i.__originalFaceNormal = i.normal.clone()),
        i.__originalVertexNormals || (i.__originalVertexNormals = []);
      for (let r = 0, s = i.vertexNormals.length; r < s; r++)
        i.__originalVertexNormals[r]
          ? i.__originalVertexNormals[r].copy(i.vertexNormals[r])
          : (i.__originalVertexNormals[r] = i.vertexNormals[r].clone());
    }
    const t = new Mt();
    t.faces = this.faces;
    for (let e = 0, n = this.morphTargets.length; e < n; e++) {
      if (!this.morphNormals[e]) {
        (this.morphNormals[e] = {}),
          (this.morphNormals[e].faceNormals = []),
          (this.morphNormals[e].vertexNormals = []);
        const r = this.morphNormals[e].faceNormals,
          s = this.morphNormals[e].vertexNormals;
        for (let o = 0, a = this.faces.length; o < a; o++) {
          const c = new S(),
            l = { a: new S(), b: new S(), c: new S() };
          r.push(c), s.push(l);
        }
      }
      const i = this.morphNormals[e];
      (t.vertices = this.morphTargets[e].vertices),
        t.computeFaceNormals(),
        t.computeVertexNormals();
      for (let r = 0, s = this.faces.length; r < s; r++) {
        const o = this.faces[r],
          a = i.faceNormals[r],
          c = i.vertexNormals[r];
        a.copy(o.normal),
          c.a.copy(o.vertexNormals[0]),
          c.b.copy(o.vertexNormals[1]),
          c.c.copy(o.vertexNormals[2]);
      }
    }
    for (let e = 0, n = this.faces.length; e < n; e++) {
      const i = this.faces[e];
      (i.normal = i.__originalFaceNormal),
        (i.vertexNormals = i.__originalVertexNormals);
    }
  },
  computeBoundingBox: function () {
    this.boundingBox === null && (this.boundingBox = new Hn()),
      this.boundingBox.setFromPoints(this.vertices);
  },
  computeBoundingSphere: function () {
    this.boundingSphere === null && (this.boundingSphere = new ci()),
      this.boundingSphere.setFromPoints(this.vertices);
  },
  merge: function (t, e, n) {
    if (!(t && t.isGeometry)) {
      console.error(
        "THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
        t
      );
      return;
    }
    let i,
      r = this.vertices.length,
      s = this.vertices,
      o = t.vertices,
      a = this.faces,
      c = t.faces,
      l = this.colors,
      u = t.colors;
    n === void 0 && (n = 0), e !== void 0 && (i = new Ge().getNormalMatrix(e));
    for (let h = 0, d = o.length; h < d; h++) {
      const p = o[h].clone();
      e !== void 0 && p.applyMatrix4(e), s.push(p);
    }
    for (let h = 0, d = u.length; h < d; h++) l.push(u[h].clone());
    for (let h = 0, d = c.length; h < d; h++) {
      let f = c[h],
        p,
        _,
        y,
        m = f.vertexNormals,
        g = f.vertexColors;
      (p = new vc(f.a + r, f.b + r, f.c + r)),
        p.normal.copy(f.normal),
        i !== void 0 && p.normal.applyMatrix3(i).normalize();
      for (let b = 0, x = m.length; b < x; b++)
        (_ = m[b].clone()),
          i !== void 0 && _.applyMatrix3(i).normalize(),
          p.vertexNormals.push(_);
      p.color.copy(f.color);
      for (let b = 0, x = g.length; b < x; b++)
        (y = g[b]), p.vertexColors.push(y.clone());
      (p.materialIndex = f.materialIndex + n), a.push(p);
    }
    for (let h = 0, d = t.faceVertexUvs.length; h < d; h++) {
      const f = t.faceVertexUvs[h];
      this.faceVertexUvs[h] === void 0 && (this.faceVertexUvs[h] = []);
      for (let p = 0, _ = f.length; p < _; p++) {
        const y = f[p],
          m = [];
        for (let g = 0, b = y.length; g < b; g++) m.push(y[g].clone());
        this.faceVertexUvs[h].push(m);
      }
    }
  },
  mergeMesh: function (t) {
    if (!(t && t.isMesh)) {
      console.error(
        "THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
        t
      );
      return;
    }
    t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix);
  },
  mergeVertices: function () {
    const t = {},
      e = [],
      n = [],
      r = Math.pow(10, 4);
    for (let a = 0, c = this.vertices.length; a < c; a++) {
      const l = this.vertices[a],
        u =
          Math.round(l.x * r) +
          "_" +
          Math.round(l.y * r) +
          "_" +
          Math.round(l.z * r);
      t[u] === void 0
        ? ((t[u] = a), e.push(this.vertices[a]), (n[a] = e.length - 1))
        : (n[a] = n[t[u]]);
    }
    const s = [];
    for (let a = 0, c = this.faces.length; a < c; a++) {
      const l = this.faces[a];
      (l.a = n[l.a]), (l.b = n[l.b]), (l.c = n[l.c]);
      const u = [l.a, l.b, l.c];
      for (let h = 0; h < 3; h++)
        if (u[h] === u[(h + 1) % 3]) {
          s.push(a);
          break;
        }
    }
    for (let a = s.length - 1; a >= 0; a--) {
      const c = s[a];
      this.faces.splice(c, 1);
      for (let l = 0, u = this.faceVertexUvs.length; l < u; l++)
        this.faceVertexUvs[l].splice(c, 1);
    }
    const o = this.vertices.length - e.length;
    return (this.vertices = e), o;
  },
  setFromPoints: function (t) {
    this.vertices = [];
    for (let e = 0, n = t.length; e < n; e++) {
      const i = t[e];
      this.vertices.push(new S(i.x, i.y, i.z || 0));
    }
    return this;
  },
  sortFacesByMaterialIndex: function () {
    const t = this.faces,
      e = t.length;
    for (let a = 0; a < e; a++) t[a]._id = a;
    function n(a, c) {
      return a.materialIndex - c.materialIndex;
    }
    t.sort(n);
    const i = this.faceVertexUvs[0],
      r = this.faceVertexUvs[1];
    let s, o;
    i && i.length === e && (s = []), r && r.length === e && (o = []);
    for (let a = 0; a < e; a++) {
      const c = t[a]._id;
      s && s.push(i[c]), o && o.push(r[c]);
    }
    s && (this.faceVertexUvs[0] = s), o && (this.faceVertexUvs[1] = o);
  },
  toJSON: function () {
    const t = {
      metadata: {
        version: 4.5,
        type: "Geometry",
        generator: "Geometry.toJSON",
      },
    };
    if (
      ((t.uuid = this.uuid),
      (t.type = this.type),
      this.name !== "" && (t.name = this.name),
      this.parameters !== void 0)
    ) {
      const f = this.parameters;
      for (const p in f) f[p] !== void 0 && (t[p] = f[p]);
      return t;
    }
    const e = [];
    for (let f = 0; f < this.vertices.length; f++) {
      const p = this.vertices[f];
      e.push(p.x, p.y, p.z);
    }
    const n = [],
      i = [],
      r = {},
      s = [],
      o = {},
      a = [],
      c = {};
    for (let f = 0; f < this.faces.length; f++) {
      const p = this.faces[f],
        _ = !0,
        y = !1,
        m = this.faceVertexUvs[0][f] !== void 0,
        g = p.normal.length() > 0,
        b = p.vertexNormals.length > 0,
        x = p.color.r !== 1 || p.color.g !== 1 || p.color.b !== 1,
        v = p.vertexColors.length > 0;
      let w = 0;
      if (
        ((w = l(w, 0, 0)),
        (w = l(w, 1, _)),
        (w = l(w, 2, y)),
        (w = l(w, 3, m)),
        (w = l(w, 4, g)),
        (w = l(w, 5, b)),
        (w = l(w, 6, x)),
        (w = l(w, 7, v)),
        n.push(w),
        n.push(p.a, p.b, p.c),
        n.push(p.materialIndex),
        m)
      ) {
        const M = this.faceVertexUvs[0][f];
        n.push(d(M[0]), d(M[1]), d(M[2]));
      }
      if ((g && n.push(u(p.normal)), b)) {
        const M = p.vertexNormals;
        n.push(u(M[0]), u(M[1]), u(M[2]));
      }
      if ((x && n.push(h(p.color)), v)) {
        const M = p.vertexColors;
        n.push(h(M[0]), h(M[1]), h(M[2]));
      }
    }
    function l(f, p, _) {
      return _ ? f | (1 << p) : f & ~(1 << p);
    }
    function u(f) {
      const p = f.x.toString() + f.y.toString() + f.z.toString();
      return (
        r[p] !== void 0 || ((r[p] = i.length / 3), i.push(f.x, f.y, f.z)), r[p]
      );
    }
    function h(f) {
      const p = f.r.toString() + f.g.toString() + f.b.toString();
      return o[p] !== void 0 || ((o[p] = s.length), s.push(f.getHex())), o[p];
    }
    function d(f) {
      const p = f.x.toString() + f.y.toString();
      return c[p] !== void 0 || ((c[p] = a.length / 2), a.push(f.x, f.y)), c[p];
    }
    return (
      (t.data = {}),
      (t.data.vertices = e),
      (t.data.normals = i),
      s.length > 0 && (t.data.colors = s),
      a.length > 0 && (t.data.uvs = [a]),
      (t.data.faces = n),
      t
    );
  },
  clone: function () {
    return new Mt().copy(this);
  },
  copy: function (t) {
    (this.vertices = []),
      (this.colors = []),
      (this.faces = []),
      (this.faceVertexUvs = [[]]),
      (this.morphTargets = []),
      (this.morphNormals = []),
      (this.skinWeights = []),
      (this.skinIndices = []),
      (this.lineDistances = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.name = t.name);
    const e = t.vertices;
    for (let h = 0, d = e.length; h < d; h++) this.vertices.push(e[h].clone());
    const n = t.colors;
    for (let h = 0, d = n.length; h < d; h++) this.colors.push(n[h].clone());
    const i = t.faces;
    for (let h = 0, d = i.length; h < d; h++) this.faces.push(i[h].clone());
    for (let h = 0, d = t.faceVertexUvs.length; h < d; h++) {
      const f = t.faceVertexUvs[h];
      this.faceVertexUvs[h] === void 0 && (this.faceVertexUvs[h] = []);
      for (let p = 0, _ = f.length; p < _; p++) {
        const y = f[p],
          m = [];
        for (let g = 0, b = y.length; g < b; g++) {
          const x = y[g];
          m.push(x.clone());
        }
        this.faceVertexUvs[h].push(m);
      }
    }
    const r = t.morphTargets;
    for (let h = 0, d = r.length; h < d; h++) {
      const f = {};
      if (((f.name = r[h].name), r[h].vertices !== void 0)) {
        f.vertices = [];
        for (let p = 0, _ = r[h].vertices.length; p < _; p++)
          f.vertices.push(r[h].vertices[p].clone());
      }
      if (r[h].normals !== void 0) {
        f.normals = [];
        for (let p = 0, _ = r[h].normals.length; p < _; p++)
          f.normals.push(r[h].normals[p].clone());
      }
      this.morphTargets.push(f);
    }
    const s = t.morphNormals;
    for (let h = 0, d = s.length; h < d; h++) {
      const f = {};
      if (s[h].vertexNormals !== void 0) {
        f.vertexNormals = [];
        for (let p = 0, _ = s[h].vertexNormals.length; p < _; p++) {
          const y = s[h].vertexNormals[p],
            m = {};
          (m.a = y.a.clone()),
            (m.b = y.b.clone()),
            (m.c = y.c.clone()),
            f.vertexNormals.push(m);
        }
      }
      if (s[h].faceNormals !== void 0) {
        f.faceNormals = [];
        for (let p = 0, _ = s[h].faceNormals.length; p < _; p++)
          f.faceNormals.push(s[h].faceNormals[p].clone());
      }
      this.morphNormals.push(f);
    }
    const o = t.skinWeights;
    for (let h = 0, d = o.length; h < d; h++)
      this.skinWeights.push(o[h].clone());
    const a = t.skinIndices;
    for (let h = 0, d = a.length; h < d; h++)
      this.skinIndices.push(a[h].clone());
    const c = t.lineDistances;
    for (let h = 0, d = c.length; h < d; h++) this.lineDistances.push(c[h]);
    const l = t.boundingBox;
    l !== null && (this.boundingBox = l.clone());
    const u = t.boundingSphere;
    return (
      u !== null && (this.boundingSphere = u.clone()),
      (this.elementsNeedUpdate = t.elementsNeedUpdate),
      (this.verticesNeedUpdate = t.verticesNeedUpdate),
      (this.uvsNeedUpdate = t.uvsNeedUpdate),
      (this.normalsNeedUpdate = t.normalsNeedUpdate),
      (this.colorsNeedUpdate = t.colorsNeedUpdate),
      (this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate),
      (this.groupsNeedUpdate = t.groupsNeedUpdate),
      this
    );
  },
  dispose: function () {
    this.dispatchEvent({ type: "dispose" });
  },
});
class Sx extends Mt {
  constructor(e, n, i, r, s, o) {
    super();
    (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: n,
        depth: i,
        widthSegments: r,
        heightSegments: s,
        depthSegments: o,
      }),
      this.fromBufferGeometry(new Lc(e, n, i, r, s, o)),
      this.mergeVertices();
  }
}
class Lc extends ct {
  constructor(e, n, i, r, s, o) {
    super();
    (this.type = "BoxBufferGeometry"),
      (this.parameters = {
        width: e,
        height: n,
        depth: i,
        widthSegments: r,
        heightSegments: s,
        depthSegments: o,
      });
    const a = this;
    (e = e || 1),
      (n = n || 1),
      (i = i || 1),
      (r = Math.floor(r) || 1),
      (s = Math.floor(s) || 1),
      (o = Math.floor(o) || 1);
    const c = [],
      l = [],
      u = [],
      h = [];
    let d = 0,
      f = 0;
    p("z", "y", "x", -1, -1, i, n, e, o, s, 0),
      p("z", "y", "x", 1, -1, i, n, -e, o, s, 1),
      p("x", "z", "y", 1, 1, e, i, n, r, o, 2),
      p("x", "z", "y", 1, -1, e, i, -n, r, o, 3),
      p("x", "y", "z", 1, -1, e, n, i, r, s, 4),
      p("x", "y", "z", -1, -1, e, n, -i, r, s, 5),
      this.setIndex(c),
      this.setAttribute("position", new rt(l, 3)),
      this.setAttribute("normal", new rt(u, 3)),
      this.setAttribute("uv", new rt(h, 2));
    function p(_, y, m, g, b, x, v, w, M, C, A) {
      const U = x / M,
        I = v / C,
        B = x / 2,
        F = v / 2,
        O = w / 2,
        R = M + 1,
        P = C + 1;
      let V = 0,
        Y = 0;
      const K = new S();
      for (let it = 0; it < P; it++) {
        const et = it * I - F;
        for (let Ct = 0; Ct < R; Ct++) {
          const mt = Ct * U - B;
          (K[_] = mt * g),
            (K[y] = et * b),
            (K[m] = O),
            l.push(K.x, K.y, K.z),
            (K[_] = 0),
            (K[y] = 0),
            (K[m] = w > 0 ? 1 : -1),
            u.push(K.x, K.y, K.z),
            h.push(Ct / M),
            h.push(1 - it / C),
            (V += 1);
        }
      }
      for (let it = 0; it < C; it++)
        for (let et = 0; et < M; et++) {
          const Ct = d + et + R * it,
            mt = d + et + R * (it + 1),
            Nt = d + (et + 1) + R * (it + 1),
            Ot = d + (et + 1) + R * it;
          c.push(Ct, mt, Ot), c.push(mt, Nt, Ot), (Y += 6);
        }
      a.addGroup(f, Y, A), (f += Y), (d += V);
    }
  }
}
function _s(t) {
  const e = {};
  for (const n in t) {
    e[n] = {};
    for (const i in t[n]) {
      const r = t[n][i];
      r &&
      (r.isColor ||
        r.isMatrix3 ||
        r.isMatrix4 ||
        r.isVector2 ||
        r.isVector3 ||
        r.isVector4 ||
        r.isTexture)
        ? (e[n][i] = r.clone())
        : Array.isArray(r)
        ? (e[n][i] = r.slice())
        : (e[n][i] = r);
    }
  }
  return e;
}
function Ne(t) {
  const e = {};
  for (let n = 0; n < t.length; n++) {
    const i = _s(t[n]);
    for (const r in i) e[r] = i[r];
  }
  return e;
}
const Tx = { clone: _s, merge: Ne };
var Ex = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  Ax = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
function Je(t) {
  bt.call(this),
    (this.type = "ShaderMaterial"),
    (this.defines = {}),
    (this.uniforms = {}),
    (this.vertexShader = Ex),
    (this.fragmentShader = Ax),
    (this.linewidth = 1),
    (this.wireframe = !1),
    (this.wireframeLinewidth = 1),
    (this.fog = !1),
    (this.lights = !1),
    (this.clipping = !1),
    (this.skinning = !1),
    (this.morphTargets = !1),
    (this.morphNormals = !1),
    (this.extensions = {
      derivatives: !1,
      fragDepth: !1,
      drawBuffers: !1,
      shaderTextureLOD: !1,
    }),
    (this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv2: [0, 0],
    }),
    (this.index0AttributeName = void 0),
    (this.uniformsNeedUpdate = !1),
    t !== void 0 &&
      (t.attributes !== void 0 &&
        console.error(
          "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
        ),
      this.setValues(t));
}
Je.prototype = Object.create(bt.prototype);
Je.prototype.constructor = Je;
Je.prototype.isShaderMaterial = !0;
Je.prototype.copy = function (t) {
  return (
    bt.prototype.copy.call(this, t),
    (this.fragmentShader = t.fragmentShader),
    (this.vertexShader = t.vertexShader),
    (this.uniforms = _s(t.uniforms)),
    (this.defines = Object.assign({}, t.defines)),
    (this.wireframe = t.wireframe),
    (this.wireframeLinewidth = t.wireframeLinewidth),
    (this.lights = t.lights),
    (this.clipping = t.clipping),
    (this.skinning = t.skinning),
    (this.morphTargets = t.morphTargets),
    (this.morphNormals = t.morphNormals),
    (this.extensions = Object.assign({}, t.extensions)),
    this
  );
};
Je.prototype.toJSON = function (t) {
  const e = bt.prototype.toJSON.call(this, t);
  e.uniforms = {};
  for (const i in this.uniforms) {
    const s = this.uniforms[i].value;
    s && s.isTexture
      ? (e.uniforms[i] = { type: "t", value: s.toJSON(t).uuid })
      : s && s.isColor
      ? (e.uniforms[i] = { type: "c", value: s.getHex() })
      : s && s.isVector2
      ? (e.uniforms[i] = { type: "v2", value: s.toArray() })
      : s && s.isVector3
      ? (e.uniforms[i] = { type: "v3", value: s.toArray() })
      : s && s.isVector4
      ? (e.uniforms[i] = { type: "v4", value: s.toArray() })
      : s && s.isMatrix3
      ? (e.uniforms[i] = { type: "m3", value: s.toArray() })
      : s && s.isMatrix4
      ? (e.uniforms[i] = { type: "m4", value: s.toArray() })
      : (e.uniforms[i] = { value: s });
  }
  Object.keys(this.defines).length > 0 && (e.defines = this.defines),
    (e.vertexShader = this.vertexShader),
    (e.fragmentShader = this.fragmentShader);
  const n = {};
  for (const i in this.extensions) this.extensions[i] === !0 && (n[i] = !0);
  return Object.keys(n).length > 0 && (e.extensions = n), e;
};
function fi() {
  nt.call(this),
    (this.type = "Camera"),
    (this.matrixWorldInverse = new Rt()),
    (this.projectionMatrix = new Rt()),
    (this.projectionMatrixInverse = new Rt());
}
fi.prototype = Object.assign(Object.create(nt.prototype), {
  constructor: fi,
  isCamera: !0,
  copy: function (t, e) {
    return (
      nt.prototype.copy.call(this, t, e),
      this.matrixWorldInverse.copy(t.matrixWorldInverse),
      this.projectionMatrix.copy(t.projectionMatrix),
      this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
      this
    );
  },
  getWorldDirection: function (t) {
    t === void 0 &&
      (console.warn(
        "THREE.Camera: .getWorldDirection() target is now required"
      ),
      (t = new S())),
      this.updateMatrixWorld(!0);
    const e = this.matrixWorld.elements;
    return t.set(-e[8], -e[9], -e[10]).normalize();
  },
  updateMatrixWorld: function (t) {
    nt.prototype.updateMatrixWorld.call(this, t),
      this.matrixWorldInverse.getInverse(this.matrixWorld);
  },
  updateWorldMatrix: function (t, e) {
    nt.prototype.updateWorldMatrix.call(this, t, e),
      this.matrixWorldInverse.getInverse(this.matrixWorld);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
});
function Pe(t, e, n, i) {
  fi.call(this),
    (this.type = "PerspectiveCamera"),
    (this.fov = t !== void 0 ? t : 50),
    (this.zoom = 1),
    (this.near = n !== void 0 ? n : 0.1),
    (this.far = i !== void 0 ? i : 2e3),
    (this.focus = 10),
    (this.aspect = e !== void 0 ? e : 1),
    (this.view = null),
    (this.filmGauge = 35),
    (this.filmOffset = 0),
    this.updateProjectionMatrix();
}
Pe.prototype = Object.assign(Object.create(fi.prototype), {
  constructor: Pe,
  isPerspectiveCamera: !0,
  copy: function (t, e) {
    return (
      fi.prototype.copy.call(this, t, e),
      (this.fov = t.fov),
      (this.zoom = t.zoom),
      (this.near = t.near),
      (this.far = t.far),
      (this.focus = t.focus),
      (this.aspect = t.aspect),
      (this.view = t.view === null ? null : Object.assign({}, t.view)),
      (this.filmGauge = t.filmGauge),
      (this.filmOffset = t.filmOffset),
      this
    );
  },
  setFocalLength: function (t) {
    const e = (0.5 * this.getFilmHeight()) / t;
    (this.fov = Pt.RAD2DEG * 2 * Math.atan(e)), this.updateProjectionMatrix();
  },
  getFocalLength: function () {
    const t = Math.tan(Pt.DEG2RAD * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / t;
  },
  getEffectiveFOV: function () {
    return (
      Pt.RAD2DEG *
      2 *
      Math.atan(Math.tan(Pt.DEG2RAD * 0.5 * this.fov) / this.zoom)
    );
  },
  getFilmWidth: function () {
    return this.filmGauge * Math.min(this.aspect, 1);
  },
  getFilmHeight: function () {
    return this.filmGauge / Math.max(this.aspect, 1);
  },
  setViewOffset: function (t, e, n, i, r, s) {
    (this.aspect = t / e),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = t),
      (this.view.fullHeight = e),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = r),
      (this.view.height = s),
      this.updateProjectionMatrix();
  },
  clearViewOffset: function () {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function () {
    let t = this.near,
      e = (t * Math.tan(Pt.DEG2RAD * 0.5 * this.fov)) / this.zoom,
      n = 2 * e,
      i = this.aspect * n,
      r = -0.5 * i,
      s = this.view;
    if (this.view !== null && this.view.enabled) {
      const a = s.fullWidth,
        c = s.fullHeight;
      (r += (s.offsetX * i) / a),
        (e -= (s.offsetY * n) / c),
        (i *= s.width / a),
        (n *= s.height / c);
    }
    const o = this.filmOffset;
    o !== 0 && (r += (t * o) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far),
      this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  },
  toJSON: function (t) {
    const e = nt.prototype.toJSON.call(this, t);
    return (
      (e.object.fov = this.fov),
      (e.object.zoom = this.zoom),
      (e.object.near = this.near),
      (e.object.far = this.far),
      (e.object.focus = this.focus),
      (e.object.aspect = this.aspect),
      this.view !== null && (e.object.view = Object.assign({}, this.view)),
      (e.object.filmGauge = this.filmGauge),
      (e.object.filmOffset = this.filmOffset),
      e
    );
  },
});
const xs = 90,
  vs = 1;
function Po(t, e, n) {
  if (
    (nt.call(this),
    (this.type = "CubeCamera"),
    n.isWebGLCubeRenderTarget !== !0)
  ) {
    console.error(
      "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
    );
    return;
  }
  this.renderTarget = n;
  const i = new Pe(xs, vs, t, e);
  (i.layers = this.layers),
    i.up.set(0, -1, 0),
    i.lookAt(new S(1, 0, 0)),
    this.add(i);
  const r = new Pe(xs, vs, t, e);
  (r.layers = this.layers),
    r.up.set(0, -1, 0),
    r.lookAt(new S(-1, 0, 0)),
    this.add(r);
  const s = new Pe(xs, vs, t, e);
  (s.layers = this.layers),
    s.up.set(0, 0, 1),
    s.lookAt(new S(0, 1, 0)),
    this.add(s);
  const o = new Pe(xs, vs, t, e);
  (o.layers = this.layers),
    o.up.set(0, 0, -1),
    o.lookAt(new S(0, -1, 0)),
    this.add(o);
  const a = new Pe(xs, vs, t, e);
  (a.layers = this.layers),
    a.up.set(0, -1, 0),
    a.lookAt(new S(0, 0, 1)),
    this.add(a);
  const c = new Pe(xs, vs, t, e);
  (c.layers = this.layers),
    c.up.set(0, -1, 0),
    c.lookAt(new S(0, 0, -1)),
    this.add(c),
    (this.update = function (l, u) {
      this.parent === null && this.updateMatrixWorld();
      const h = l.xr.enabled,
        d = l.getRenderTarget();
      l.xr.enabled = !1;
      const f = n.texture.generateMipmaps;
      (n.texture.generateMipmaps = !1),
        l.setRenderTarget(n, 0),
        l.render(u, i),
        l.setRenderTarget(n, 1),
        l.render(u, r),
        l.setRenderTarget(n, 2),
        l.render(u, s),
        l.setRenderTarget(n, 3),
        l.render(u, o),
        l.setRenderTarget(n, 4),
        l.render(u, a),
        (n.texture.generateMipmaps = f),
        l.setRenderTarget(n, 5),
        l.render(u, c),
        l.setRenderTarget(d),
        (l.xr.enabled = h);
    }),
    (this.clear = function (l, u, h, d) {
      const f = l.getRenderTarget();
      for (let p = 0; p < 6; p++) l.setRenderTarget(n, p), l.clear(u, h, d);
      l.setRenderTarget(f);
    });
}
Po.prototype = Object.create(nt.prototype);
Po.prototype.constructor = Po;
function Co(t, e, n) {
  Number.isInteger(e) &&
    (console.warn(
      "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
    ),
    (e = n)),
    Sn.call(this, t, t, e);
}
Co.prototype = Object.create(Sn.prototype);
Co.prototype.constructor = Co;
Co.prototype.isWebGLCubeRenderTarget = !0;
Co.prototype.fromEquirectangularTexture = function (t, e) {
  (this.texture.type = e.type),
    (this.texture.format = e.format),
    (this.texture.encoding = e.encoding);
  const n = new pc(),
    i = {
      uniforms: { tEquirect: { value: null } },
      vertexShader: [
        "varying vec3 vWorldDirection;",
        "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {",
        "	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );",
        "}",
        "void main() {",
        "	vWorldDirection = transformDirection( position, modelMatrix );",
        "	#include <begin_vertex>",
        "	#include <project_vertex>",
        "}",
      ].join(`
`),
      fragmentShader: [
        "uniform sampler2D tEquirect;",
        "varying vec3 vWorldDirection;",
        "#include <common>",
        "void main() {",
        "	vec3 direction = normalize( vWorldDirection );",
        "	vec2 sampleUV = equirectUv( direction );",
        "	gl_FragColor = texture2D( tEquirect, sampleUV );",
        "}",
      ].join(`
`),
    },
    r = new Je({
      name: "CubemapFromEquirect",
      uniforms: _s(i.uniforms),
      vertexShader: i.vertexShader,
      fragmentShader: i.fragmentShader,
      side: Ee,
      blending: mo,
    });
  r.uniforms.tEquirect.value = e;
  const s = new he(new Lc(5, 5, 5), r);
  return (
    n.add(s),
    new Po(1, 10, this).update(t, n),
    s.geometry.dispose(),
    s.material.dispose(),
    this
  );
};
function bs(t, e, n, i, r, s, o, a, c, l, u, h) {
  Jt.call(this, null, s, o, a, c, l, i, r, u, h),
    (this.image = { data: t || null, width: e || 1, height: n || 1 }),
    (this.magFilter = c !== void 0 ? c : De),
    (this.minFilter = l !== void 0 ? l : De),
    (this.generateMipmaps = !1),
    (this.flipY = !1),
    (this.unpackAlignment = 1),
    (this.needsUpdate = !0);
}
bs.prototype = Object.create(Jt.prototype);
bs.prototype.constructor = bs;
bs.prototype.isDataTexture = !0;
const ws = new ci(),
  Pc = new S();
function Ro(t, e, n, i, r, s) {
  this.planes = [
    t !== void 0 ? t : new Vn(),
    e !== void 0 ? e : new Vn(),
    n !== void 0 ? n : new Vn(),
    i !== void 0 ? i : new Vn(),
    r !== void 0 ? r : new Vn(),
    s !== void 0 ? s : new Vn(),
  ];
}
Object.assign(Ro.prototype, {
  set: function (t, e, n, i, r, s) {
    const o = this.planes;
    return (
      o[0].copy(t),
      o[1].copy(e),
      o[2].copy(n),
      o[3].copy(i),
      o[4].copy(r),
      o[5].copy(s),
      this
    );
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
    return this;
  },
  setFromProjectionMatrix: function (t) {
    const e = this.planes,
      n = t.elements,
      i = n[0],
      r = n[1],
      s = n[2],
      o = n[3],
      a = n[4],
      c = n[5],
      l = n[6],
      u = n[7],
      h = n[8],
      d = n[9],
      f = n[10],
      p = n[11],
      _ = n[12],
      y = n[13],
      m = n[14],
      g = n[15];
    return (
      e[0].setComponents(o - i, u - a, p - h, g - _).normalize(),
      e[1].setComponents(o + i, u + a, p + h, g + _).normalize(),
      e[2].setComponents(o + r, u + c, p + d, g + y).normalize(),
      e[3].setComponents(o - r, u - c, p - d, g - y).normalize(),
      e[4].setComponents(o - s, u - l, p - f, g - m).normalize(),
      e[5].setComponents(o + s, u + l, p + f, g + m).normalize(),
      this
    );
  },
  intersectsObject: function (t) {
    const e = t.geometry;
    return (
      e.boundingSphere === null && e.computeBoundingSphere(),
      ws.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
      this.intersectsSphere(ws)
    );
  },
  intersectsSprite: function (t) {
    return (
      ws.center.set(0, 0, 0),
      (ws.radius = 0.7071067811865476),
      ws.applyMatrix4(t.matrixWorld),
      this.intersectsSphere(ws)
    );
  },
  intersectsSphere: function (t) {
    const e = this.planes,
      n = t.center,
      i = -t.radius;
    for (let r = 0; r < 6; r++) if (e[r].distanceToPoint(n) < i) return !1;
    return !0;
  },
  intersectsBox: function (t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++) {
      const i = e[n];
      if (
        ((Pc.x = i.normal.x > 0 ? t.max.x : t.min.x),
        (Pc.y = i.normal.y > 0 ? t.max.y : t.min.y),
        (Pc.z = i.normal.z > 0 ? t.max.z : t.min.z),
        i.distanceToPoint(Pc) < 0)
      )
        return !1;
    }
    return !0;
  },
  containsPoint: function (t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1;
    return !0;
  },
});
const st = {
  common: {
    diffuse: { value: new lt(15658734) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: new Ge() },
    uv2Transform: { value: new Ge() },
    alphaMap: { value: null },
  },
  specularmap: { specularMap: { value: null } },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    refractionRatio: { value: 0.98 },
    maxMipLevel: { value: 0 },
  },
  aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
  lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
  emissivemap: { emissiveMap: { value: null } },
  bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: new H(1, 1) },
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 },
  },
  roughnessmap: { roughnessMap: { value: null } },
  metalnessmap: { metalnessMap: { value: null } },
  gradientmap: { gradientMap: { value: null } },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: new lt(16777215) },
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: { direction: {}, color: {} } },
    directionalLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
      },
    },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        direction: {},
        distance: {},
        coneCos: {},
        penumbraCos: {},
        decay: {},
      },
    },
    spotLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
      },
    },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: {
      value: [],
      properties: { color: {}, position: {}, decay: {}, distance: {} },
    },
    pointLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
        shadowCameraNear: {},
        shadowCameraFar: {},
      },
    },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: {
      value: [],
      properties: { direction: {}, skyColor: {}, groundColor: {} },
    },
    rectAreaLights: {
      value: [],
      properties: { color: {}, position: {}, width: {}, height: {} },
    },
  },
  points: {
    diffuse: { value: new lt(15658734) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    uvTransform: { value: new Ge() },
  },
  sprite: {
    diffuse: { value: new lt(15658734) },
    opacity: { value: 1 },
    center: { value: new H(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    alphaMap: { value: null },
    uvTransform: { value: new Ge() },
  },
};
function Kp() {
  let t = null,
    e = !1,
    n = null,
    i = null;
  function r(s, o) {
    n(s, o), (i = t.requestAnimationFrame(r));
  }
  return {
    start: function () {
      e !== !0 && n !== null && ((i = t.requestAnimationFrame(r)), (e = !0));
    },
    stop: function () {
      t.cancelAnimationFrame(i), (e = !1);
    },
    setAnimationLoop: function (s) {
      n = s;
    },
    setContext: function (s) {
      t = s;
    },
  };
}
function Lx(t, e) {
  const n = e.isWebGL2,
    i = new WeakMap();
  function r(l, u) {
    const h = l.array,
      d = l.usage,
      f = t.createBuffer();
    t.bindBuffer(u, f), t.bufferData(u, h, d), l.onUploadCallback();
    let p = 5126;
    return (
      h instanceof Float32Array
        ? (p = 5126)
        : h instanceof Float64Array
        ? console.warn(
            "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
          )
        : h instanceof Uint16Array
        ? (p = 5123)
        : h instanceof Int16Array
        ? (p = 5122)
        : h instanceof Uint32Array
        ? (p = 5125)
        : h instanceof Int32Array
        ? (p = 5124)
        : h instanceof Int8Array
        ? (p = 5120)
        : h instanceof Uint8Array && (p = 5121),
      {
        buffer: f,
        type: p,
        bytesPerElement: h.BYTES_PER_ELEMENT,
        version: l.version,
      }
    );
  }
  function s(l, u, h) {
    const d = u.array,
      f = u.updateRange;
    t.bindBuffer(h, l),
      f.count === -1
        ? t.bufferSubData(h, 0, d)
        : (n
            ? t.bufferSubData(
                h,
                f.offset * d.BYTES_PER_ELEMENT,
                d,
                f.offset,
                f.count
              )
            : t.bufferSubData(
                h,
                f.offset * d.BYTES_PER_ELEMENT,
                d.subarray(f.offset, f.offset + f.count)
              ),
          (f.count = -1));
  }
  function o(l) {
    return l.isInterleavedBufferAttribute && (l = l.data), i.get(l);
  }
  function a(l) {
    l.isInterleavedBufferAttribute && (l = l.data);
    const u = i.get(l);
    u && (t.deleteBuffer(u.buffer), i.delete(l));
  }
  function c(l, u) {
    l.isInterleavedBufferAttribute && (l = l.data);
    const h = i.get(l);
    h === void 0
      ? i.set(l, r(l, u))
      : h.version < l.version && (s(h.buffer, l, u), (h.version = l.version));
  }
  return { get: o, remove: a, update: c };
}
function Cc(t, e, n, i) {
  Mt.call(this),
    (this.type = "PlaneGeometry"),
    (this.parameters = {
      width: t,
      height: e,
      widthSegments: n,
      heightSegments: i,
    }),
    this.fromBufferGeometry(new Ms(t, e, n, i)),
    this.mergeVertices();
}
Cc.prototype = Object.create(Mt.prototype);
Cc.prototype.constructor = Cc;
function Ms(t, e, n, i) {
  ct.call(this),
    (this.type = "PlaneBufferGeometry"),
    (this.parameters = {
      width: t,
      height: e,
      widthSegments: n,
      heightSegments: i,
    }),
    (t = t || 1),
    (e = e || 1);
  const r = t / 2,
    s = e / 2,
    o = Math.floor(n) || 1,
    a = Math.floor(i) || 1,
    c = o + 1,
    l = a + 1,
    u = t / o,
    h = e / a,
    d = [],
    f = [],
    p = [],
    _ = [];
  for (let y = 0; y < l; y++) {
    const m = y * h - s;
    for (let g = 0; g < c; g++) {
      const b = g * u - r;
      f.push(b, -m, 0), p.push(0, 0, 1), _.push(g / o), _.push(1 - y / a);
    }
  }
  for (let y = 0; y < a; y++)
    for (let m = 0; m < o; m++) {
      const g = m + c * y,
        b = m + c * (y + 1),
        x = m + 1 + c * (y + 1),
        v = m + 1 + c * y;
      d.push(g, b, v), d.push(b, x, v);
    }
  this.setIndex(d),
    this.setAttribute("position", new rt(f, 3)),
    this.setAttribute("normal", new rt(p, 3)),
    this.setAttribute("uv", new rt(_, 2));
}
Ms.prototype = Object.create(ct.prototype);
Ms.prototype.constructor = Ms;
var Px = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
  Cx = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  Rx = `#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`,
  Ox = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`,
  Dx = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  Ix = "vec3 transformed = vec3( position );",
  Nx = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  Fx = `vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE  = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS  = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha  = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`,
  Bx = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 );
		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  zx = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  Ux = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  kx = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  Gx = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  Hx = `#ifdef USE_COLOR
	diffuseColor.rgb *= vColor;
#endif`,
  Vx = `#ifdef USE_COLOR
	varying vec3 vColor;
#endif`,
  Wx = `#ifdef USE_COLOR
	varying vec3 vColor;
#endif`,
  jx = `#ifdef USE_COLOR
	vColor.xyz = color.xyz;
#endif`,
  qx = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
  return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
  Xx = `#ifdef ENVMAP_TYPE_CUBE_UV
#define cubeUV_maxMipLevel 8.0
#define cubeUV_minMipLevel 4.0
#define cubeUV_maxTileSize 256.0
#define cubeUV_minTileSize 16.0
float getFace(vec3 direction) {
    vec3 absDirection = abs(direction);
    float face = -1.0;
    if (absDirection.x > absDirection.z) {
      if (absDirection.x > absDirection.y)
        face = direction.x > 0.0 ? 0.0 : 3.0;
      else
        face = direction.y > 0.0 ? 1.0 : 4.0;
    } else {
      if (absDirection.z > absDirection.y)
        face = direction.z > 0.0 ? 2.0 : 5.0;
      else
        face = direction.y > 0.0 ? 1.0 : 4.0;
    }
    return face;
}
vec2 getUV(vec3 direction, float face) {
    vec2 uv;
    if (face == 0.0) {
      uv = vec2(direction.z, direction.y) / abs(direction.x);    } else if (face == 1.0) {
      uv = vec2(-direction.x, -direction.z) / abs(direction.y);    } else if (face == 2.0) {
      uv = vec2(-direction.x, direction.y) / abs(direction.z);    } else if (face == 3.0) {
      uv = vec2(-direction.z, direction.y) / abs(direction.x);    } else if (face == 4.0) {
      uv = vec2(-direction.x, direction.z) / abs(direction.y);    } else {
      uv = vec2(direction.x, direction.y) / abs(direction.z);    }
    return 0.5 * (uv + 1.0);
}
vec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {
  float face = getFace(direction);
  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);
  mipInt = max(mipInt, cubeUV_minMipLevel);
  float faceSize = exp2(mipInt);
  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);
  vec2 uv = getUV(direction, face) * (faceSize - 1.0);
  vec2 f = fract(uv);
  uv += 0.5 - f;
  if (face > 2.0) {
    uv.y += faceSize;
    face -= 3.0;
  }
  uv.x += face * faceSize;
  if(mipInt < cubeUV_maxMipLevel){
    uv.y += 2.0 * cubeUV_maxTileSize;
  }
  uv.y += filterInt * 2.0 * cubeUV_minTileSize;
  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);
  uv *= texelSize;
  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  uv.x += texelSize;
  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  uv.y += texelSize;
  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  uv.x -= texelSize;
  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  vec3 tm = mix(tl, tr, f.x);
  vec3 bm = mix(bl, br, f.x);
  return mix(tm, bm, f.y);
}
#define r0 1.0
#define v0 0.339
#define m0 -2.0
#define r1 0.8
#define v1 0.276
#define m1 -1.0
#define r4 0.4
#define v4 0.046
#define m4 2.0
#define r5 0.305
#define v5 0.016
#define m5 3.0
#define r6 0.21
#define v6 0.0038
#define m6 4.0
float roughnessToMip(float roughness) {
  float mip = 0.0;
  if (roughness >= r1) {
    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;
  } else if (roughness >= r4) {
    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;
  } else if (roughness >= r5) {
    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;
  } else if (roughness >= r6) {
    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;
  } else {
    mip = -2.0 * log2(1.16 * roughness);  }
  return mip;
}
vec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {
  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);
  float mipF = fract(mip);
  float mipInt = floor(mip);
  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);
  if (mipF == 0.0) {
    return vec4(color0, 1.0);
  } else {
    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);
    return vec4(mix(color0, color1, mipF), 1.0);
  }
}
#endif`,
  Yx = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  Zx = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  Jx = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
  $x = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  Qx = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  Kx = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  tv = `
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value )  {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,
  ev = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		}  else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#elif defined( ENVMAP_TYPE_EQUIREC )
		reflectVec = normalize( reflectVec );
		vec2 sampleUV = equirectUv( reflectVec );
		vec4 envColor = texture2D( envMap, sampleUV );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  nv = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  iv = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  rv = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  sv = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) { 
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  ov = `#ifdef USE_FOG
	fogDepth = -mvPosition.z;
#endif`,
  av = `#ifdef USE_FOG
	varying float fogDepth;
#endif`,
  cv = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  lv = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  uv = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,
  hv = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`,
  fv = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  dv = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`,
  pv = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`,
  mv = `#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
		  vec3 reflectVec = reflect( -viewDir, normal );
		  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
		  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#elif defined( ENVMAP_TYPE_EQUIREC )
			vec2 sampleUV = equirectUv( reflectVec );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );
			#else
				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`,
  gv = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  yv = `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3	diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,
  _v = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  xv = `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3	diffuseColor;
	vec3	specularColor;
	float	specularShininess;
	float	specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,
  vv = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`,
  bv = `struct PhysicalMaterial {
	vec3	diffuseColor;
	float	specularRoughness;
	vec3	specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  wv = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  Mv = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`,
  Sv = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
  Tv = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  Ev = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  Av = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  Lv = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  Pv = `#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,
  Cv = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  Rv = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  Ov = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  Dv = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  Iv = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  Nv = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`,
  Fv = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
	uniform float morphTargetInfluences[ 8 ];
	#else
	uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,
  Bv = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
	transformed += morphTarget4 * morphTargetInfluences[ 4 ];
	transformed += morphTarget5 * morphTargetInfluences[ 5 ];
	transformed += morphTarget6 * morphTargetInfluences[ 6 ];
	transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`,
  zv = `#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
  Uv = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );
#endif`,
  kv = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		float scale = sign( st1.t * st0.s - st0.t * st1.s );
		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
		vec3 N = normalize( surf_norm );
		mat3 tsn = mat3( S, T, N );
		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		return normalize( tsn * mapN );
	}
#endif`,
  Gv = `#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
  Hv = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );
	#endif
#endif`,
  Vv = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
  Wv = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
  jv = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  qv = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  Xv = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  Yv = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  Zv = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  Jv = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  $v = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  Qv = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  Kv = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,
  tb = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  eb = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  nb = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,
  ib = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  rb = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  sb = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  ob = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  ab = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  cb = `#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  lb = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
  ub = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
  hb = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
  fb = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
  db = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
  pb = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
  mb = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,
  gb = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  yb = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  _b = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  xb = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  vb = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  bb = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  wb = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  Mb = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  Sb = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  Tb = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  Eb = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  Ab = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  Lb = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Pb = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  Cb = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Rb = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  Ob = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Db = `#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  Ib = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Nb = `#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  Fb = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Bb = `#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  zb = `#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSPARENCY
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef TRANSPARENCY
	uniform float transparency;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#ifdef TRANSPARENCY
		diffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );
	#endif
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Ub = `#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  kb = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,
  Gb = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  Hb = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  Vb = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  Wb = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  jb = `#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  qb = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  Xb = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;
const It = {
    alphamap_fragment: Px,
    alphamap_pars_fragment: Cx,
    alphatest_fragment: Rx,
    aomap_fragment: Ox,
    aomap_pars_fragment: Dx,
    begin_vertex: Ix,
    beginnormal_vertex: Nx,
    bsdfs: Fx,
    bumpmap_pars_fragment: Bx,
    clipping_planes_fragment: zx,
    clipping_planes_pars_fragment: Ux,
    clipping_planes_pars_vertex: kx,
    clipping_planes_vertex: Gx,
    color_fragment: Hx,
    color_pars_fragment: Vx,
    color_pars_vertex: Wx,
    color_vertex: jx,
    common: qx,
    cube_uv_reflection_fragment: Xx,
    defaultnormal_vertex: Yx,
    displacementmap_pars_vertex: Zx,
    displacementmap_vertex: Jx,
    emissivemap_fragment: $x,
    emissivemap_pars_fragment: Qx,
    encodings_fragment: Kx,
    encodings_pars_fragment: tv,
    envmap_fragment: ev,
    envmap_common_pars_fragment: nv,
    envmap_pars_fragment: iv,
    envmap_pars_vertex: rv,
    envmap_physical_pars_fragment: mv,
    envmap_vertex: sv,
    fog_vertex: ov,
    fog_pars_vertex: av,
    fog_fragment: cv,
    fog_pars_fragment: lv,
    gradientmap_pars_fragment: uv,
    lightmap_fragment: hv,
    lightmap_pars_fragment: fv,
    lights_lambert_vertex: dv,
    lights_pars_begin: pv,
    lights_toon_fragment: gv,
    lights_toon_pars_fragment: yv,
    lights_phong_fragment: _v,
    lights_phong_pars_fragment: xv,
    lights_physical_fragment: vv,
    lights_physical_pars_fragment: bv,
    lights_fragment_begin: wv,
    lights_fragment_maps: Mv,
    lights_fragment_end: Sv,
    logdepthbuf_fragment: Tv,
    logdepthbuf_pars_fragment: Ev,
    logdepthbuf_pars_vertex: Av,
    logdepthbuf_vertex: Lv,
    map_fragment: Pv,
    map_pars_fragment: Cv,
    map_particle_fragment: Rv,
    map_particle_pars_fragment: Ov,
    metalnessmap_fragment: Dv,
    metalnessmap_pars_fragment: Iv,
    morphnormal_vertex: Nv,
    morphtarget_pars_vertex: Fv,
    morphtarget_vertex: Bv,
    normal_fragment_begin: zv,
    normal_fragment_maps: Uv,
    normalmap_pars_fragment: kv,
    clearcoat_normal_fragment_begin: Gv,
    clearcoat_normal_fragment_maps: Hv,
    clearcoat_pars_fragment: Vv,
    packing: Wv,
    premultiplied_alpha_fragment: jv,
    project_vertex: qv,
    dithering_fragment: Xv,
    dithering_pars_fragment: Yv,
    roughnessmap_fragment: Zv,
    roughnessmap_pars_fragment: Jv,
    shadowmap_pars_fragment: $v,
    shadowmap_pars_vertex: Qv,
    shadowmap_vertex: Kv,
    shadowmask_pars_fragment: tb,
    skinbase_vertex: eb,
    skinning_pars_vertex: nb,
    skinning_vertex: ib,
    skinnormal_vertex: rb,
    specularmap_fragment: sb,
    specularmap_pars_fragment: ob,
    tonemapping_fragment: ab,
    tonemapping_pars_fragment: cb,
    uv_pars_fragment: lb,
    uv_pars_vertex: ub,
    uv_vertex: hb,
    uv2_pars_fragment: fb,
    uv2_pars_vertex: db,
    uv2_vertex: pb,
    worldpos_vertex: mb,
    background_frag: gb,
    background_vert: yb,
    cube_frag: _b,
    cube_vert: xb,
    depth_frag: vb,
    depth_vert: bb,
    distanceRGBA_frag: wb,
    distanceRGBA_vert: Mb,
    equirect_frag: Sb,
    equirect_vert: Tb,
    linedashed_frag: Eb,
    linedashed_vert: Ab,
    meshbasic_frag: Lb,
    meshbasic_vert: Pb,
    meshlambert_frag: Cb,
    meshlambert_vert: Rb,
    meshmatcap_frag: Ob,
    meshmatcap_vert: Db,
    meshtoon_frag: Ib,
    meshtoon_vert: Nb,
    meshphong_frag: Fb,
    meshphong_vert: Bb,
    meshphysical_frag: zb,
    meshphysical_vert: Ub,
    normal_frag: kb,
    normal_vert: Gb,
    points_frag: Hb,
    points_vert: Vb,
    shadow_frag: Wb,
    shadow_vert: jb,
    sprite_frag: qb,
    sprite_vert: Xb,
  },
  di = {
    basic: {
      uniforms: Ne([
        st.common,
        st.specularmap,
        st.envmap,
        st.aomap,
        st.lightmap,
        st.fog,
      ]),
      vertexShader: It.meshbasic_vert,
      fragmentShader: It.meshbasic_frag,
    },
    lambert: {
      uniforms: Ne([
        st.common,
        st.specularmap,
        st.envmap,
        st.aomap,
        st.lightmap,
        st.emissivemap,
        st.fog,
        st.lights,
        { emissive: { value: new lt(0) } },
      ]),
      vertexShader: It.meshlambert_vert,
      fragmentShader: It.meshlambert_frag,
    },
    phong: {
      uniforms: Ne([
        st.common,
        st.specularmap,
        st.envmap,
        st.aomap,
        st.lightmap,
        st.emissivemap,
        st.bumpmap,
        st.normalmap,
        st.displacementmap,
        st.fog,
        st.lights,
        {
          emissive: { value: new lt(0) },
          specular: { value: new lt(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: It.meshphong_vert,
      fragmentShader: It.meshphong_frag,
    },
    standard: {
      uniforms: Ne([
        st.common,
        st.envmap,
        st.aomap,
        st.lightmap,
        st.emissivemap,
        st.bumpmap,
        st.normalmap,
        st.displacementmap,
        st.roughnessmap,
        st.metalnessmap,
        st.fog,
        st.lights,
        {
          emissive: { value: new lt(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: It.meshphysical_vert,
      fragmentShader: It.meshphysical_frag,
    },
    toon: {
      uniforms: Ne([
        st.common,
        st.aomap,
        st.lightmap,
        st.emissivemap,
        st.bumpmap,
        st.normalmap,
        st.displacementmap,
        st.gradientmap,
        st.fog,
        st.lights,
        { emissive: { value: new lt(0) } },
      ]),
      vertexShader: It.meshtoon_vert,
      fragmentShader: It.meshtoon_frag,
    },
    matcap: {
      uniforms: Ne([
        st.common,
        st.bumpmap,
        st.normalmap,
        st.displacementmap,
        st.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: It.meshmatcap_vert,
      fragmentShader: It.meshmatcap_frag,
    },
    points: {
      uniforms: Ne([st.points, st.fog]),
      vertexShader: It.points_vert,
      fragmentShader: It.points_frag,
    },
    dashed: {
      uniforms: Ne([
        st.common,
        st.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: It.linedashed_vert,
      fragmentShader: It.linedashed_frag,
    },
    depth: {
      uniforms: Ne([st.common, st.displacementmap]),
      vertexShader: It.depth_vert,
      fragmentShader: It.depth_frag,
    },
    normal: {
      uniforms: Ne([
        st.common,
        st.bumpmap,
        st.normalmap,
        st.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: It.normal_vert,
      fragmentShader: It.normal_frag,
    },
    sprite: {
      uniforms: Ne([st.sprite, st.fog]),
      vertexShader: It.sprite_vert,
      fragmentShader: It.sprite_frag,
    },
    background: {
      uniforms: { uvTransform: { value: new Ge() }, t2D: { value: null } },
      vertexShader: It.background_vert,
      fragmentShader: It.background_frag,
    },
    cube: {
      uniforms: Ne([st.envmap, { opacity: { value: 1 } }]),
      vertexShader: It.cube_vert,
      fragmentShader: It.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: It.equirect_vert,
      fragmentShader: It.equirect_frag,
    },
    distanceRGBA: {
      uniforms: Ne([
        st.common,
        st.displacementmap,
        {
          referencePosition: { value: new S() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: It.distanceRGBA_vert,
      fragmentShader: It.distanceRGBA_frag,
    },
    shadow: {
      uniforms: Ne([
        st.lights,
        st.fog,
        { color: { value: new lt(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: It.shadow_vert,
      fragmentShader: It.shadow_frag,
    },
  };
di.physical = {
  uniforms: Ne([
    di.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: new H(1, 1) },
      clearcoatNormalMap: { value: null },
      sheen: { value: new lt(0) },
      transparency: { value: 0 },
    },
  ]),
  vertexShader: It.meshphysical_vert,
  fragmentShader: It.meshphysical_frag,
};
function Yb(t, e, n, i) {
  const r = new lt(0);
  let s = 0,
    o,
    a,
    c = null,
    l = 0,
    u = null;
  function h(f, p, _, y) {
    let m = p.isScene === !0 ? p.background : null;
    const g = t.xr,
      b = g.getSession && g.getSession();
    if (
      (b && b.environmentBlendMode === "additive" && (m = null),
      m === null ? d(r, s) : m && m.isColor && (d(m, 1), (y = !0)),
      (t.autoClear || y) &&
        t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
      m && (m.isCubeTexture || m.isWebGLCubeRenderTarget || m.mapping === ec))
    ) {
      a === void 0 &&
        ((a = new he(
          new Lc(1, 1, 1),
          new Je({
            name: "BackgroundCubeMaterial",
            uniforms: _s(di.cube.uniforms),
            vertexShader: di.cube.vertexShader,
            fragmentShader: di.cube.fragmentShader,
            side: Ee,
            depthTest: !1,
            depthWrite: !1,
            fog: !1,
          })
        )),
        a.geometry.deleteAttribute("normal"),
        a.geometry.deleteAttribute("uv"),
        (a.onBeforeRender = function (v, w, M) {
          this.matrixWorld.copyPosition(M.matrixWorld);
        }),
        Object.defineProperty(a.material, "envMap", {
          get: function () {
            return this.uniforms.envMap.value;
          },
        }),
        n.update(a));
      const x = m.isWebGLCubeRenderTarget ? m.texture : m;
      (a.material.uniforms.envMap.value = x),
        (a.material.uniforms.flipEnvMap.value = x.isCubeTexture ? -1 : 1),
        (c !== m || l !== x.version || u !== t.toneMapping) &&
          ((a.material.needsUpdate = !0),
          (c = m),
          (l = x.version),
          (u = t.toneMapping)),
        f.unshift(a, a.geometry, a.material, 0, 0, null);
    } else
      m &&
        m.isTexture &&
        (o === void 0 &&
          ((o = new he(
            new Ms(2, 2),
            new Je({
              name: "BackgroundMaterial",
              uniforms: _s(di.background.uniforms),
              vertexShader: di.background.vertexShader,
              fragmentShader: di.background.fragmentShader,
              side: po,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            })
          )),
          o.geometry.deleteAttribute("normal"),
          Object.defineProperty(o.material, "map", {
            get: function () {
              return this.uniforms.t2D.value;
            },
          }),
          n.update(o)),
        (o.material.uniforms.t2D.value = m),
        m.matrixAutoUpdate === !0 && m.updateMatrix(),
        o.material.uniforms.uvTransform.value.copy(m.matrix),
        (c !== m || l !== m.version || u !== t.toneMapping) &&
          ((o.material.needsUpdate = !0),
          (c = m),
          (l = m.version),
          (u = t.toneMapping)),
        f.unshift(o, o.geometry, o.material, 0, 0, null));
  }
  function d(f, p) {
    e.buffers.color.setClear(f.r, f.g, f.b, p, i);
  }
  return {
    getClearColor: function () {
      return r;
    },
    setClearColor: function (f, p) {
      r.set(f), (s = p !== void 0 ? p : 1), d(r, s);
    },
    getClearAlpha: function () {
      return s;
    },
    setClearAlpha: function (f) {
      (s = f), d(r, s);
    },
    render: h,
  };
}
function Zb(t, e, n, i) {
  const r = t.getParameter(34921),
    s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    o = i.isWebGL2 || s !== null,
    a = {},
    c = _(null);
  let l = c;
  function u(F, O, R, P, V) {
    let Y = !1;
    if (o) {
      const K = p(P, R, O);
      l !== K && ((l = K), d(l.object)), (Y = y(P)), Y && m(P);
    } else {
      const K = O.wireframe === !0;
      (l.geometry !== P.id || l.program !== R.id || l.wireframe !== K) &&
        ((l.geometry = P.id), (l.program = R.id), (l.wireframe = K), (Y = !0));
    }
    F.isInstancedMesh === !0 && (Y = !0),
      V !== null && n.update(V, 34963),
      Y && (M(F, O, R, P), V !== null && t.bindBuffer(34963, n.get(V).buffer));
  }
  function h() {
    return i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES();
  }
  function d(F) {
    return i.isWebGL2 ? t.bindVertexArray(F) : s.bindVertexArrayOES(F);
  }
  function f(F) {
    return i.isWebGL2 ? t.deleteVertexArray(F) : s.deleteVertexArrayOES(F);
  }
  function p(F, O, R) {
    const P = R.wireframe === !0;
    let V = a[F.id];
    V === void 0 && ((V = {}), (a[F.id] = V));
    let Y = V[O.id];
    Y === void 0 && ((Y = {}), (V[O.id] = Y));
    let K = Y[P];
    return K === void 0 && ((K = _(h())), (Y[P] = K)), K;
  }
  function _(F) {
    const O = [],
      R = [],
      P = [];
    for (let V = 0; V < r; V++) (O[V] = 0), (R[V] = 0), (P[V] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: O,
      enabledAttributes: R,
      attributeDivisors: P,
      object: F,
      attributes: {},
    };
  }
  function y(F) {
    const O = l.attributes,
      R = F.attributes;
    if (Object.keys(O).length !== Object.keys(R).length) return !0;
    for (const P in R) {
      const V = O[P],
        Y = R[P];
      if (V.attribute !== Y || V.data !== Y.data) return !0;
    }
    return !1;
  }
  function m(F) {
    const O = {},
      R = F.attributes;
    for (const P in R) {
      const V = R[P],
        Y = {};
      (Y.attribute = V), V.data && (Y.data = V.data), (O[P] = Y);
    }
    l.attributes = O;
  }
  function g() {
    const F = l.newAttributes;
    for (let O = 0, R = F.length; O < R; O++) F[O] = 0;
  }
  function b(F) {
    x(F, 0);
  }
  function x(F, O) {
    const R = l.newAttributes,
      P = l.enabledAttributes,
      V = l.attributeDivisors;
    (R[F] = 1),
      P[F] === 0 && (t.enableVertexAttribArray(F), (P[F] = 1)),
      V[F] !== O &&
        ((i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
          i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](F, O),
        (V[F] = O));
  }
  function v() {
    const F = l.newAttributes,
      O = l.enabledAttributes;
    for (let R = 0, P = O.length; R < P; R++)
      O[R] !== F[R] && (t.disableVertexAttribArray(R), (O[R] = 0));
  }
  function w(F, O, R, P, V, Y) {
    i.isWebGL2 === !0 && (R === 5124 || R === 5125)
      ? t.vertexAttribIPointer(F, O, R, P, V, Y)
      : t.vertexAttribPointer(F, O, R, P, V, Y);
  }
  function M(F, O, R, P) {
    if (
      i.isWebGL2 === !1 &&
      (F.isInstancedMesh || P.isInstancedBufferGeometry) &&
      e.get("ANGLE_instanced_arrays") === null
    )
      return;
    g();
    const V = P.attributes,
      Y = R.getAttributes(),
      K = O.defaultAttributeValues;
    for (const it in Y) {
      const et = Y[it];
      if (et >= 0) {
        const Ct = V[it];
        if (Ct !== void 0) {
          const mt = Ct.normalized,
            Nt = Ct.itemSize,
            Ot = n.get(Ct);
          if (Ot === void 0) continue;
          const G = Ot.buffer,
            kt = Ot.type,
            vt = Ot.bytesPerElement;
          if (Ct.isInterleavedBufferAttribute) {
            const St = Ct.data,
              yt = St.stride,
              j = Ct.offset;
            St && St.isInstancedInterleavedBuffer
              ? (x(et, St.meshPerAttribute),
                P._maxInstanceCount === void 0 &&
                  (P._maxInstanceCount = St.meshPerAttribute * St.count))
              : b(et),
              t.bindBuffer(34962, G),
              w(et, Nt, kt, mt, yt * vt, j * vt);
          } else
            Ct.isInstancedBufferAttribute
              ? (x(et, Ct.meshPerAttribute),
                P._maxInstanceCount === void 0 &&
                  (P._maxInstanceCount = Ct.meshPerAttribute * Ct.count))
              : b(et),
              t.bindBuffer(34962, G),
              w(et, Nt, kt, mt, 0, 0);
        } else if (it === "instanceMatrix") {
          const mt = n.get(F.instanceMatrix);
          if (mt === void 0) continue;
          const Nt = mt.buffer,
            Ot = mt.type;
          x(et + 0, 1),
            x(et + 1, 1),
            x(et + 2, 1),
            x(et + 3, 1),
            t.bindBuffer(34962, Nt),
            t.vertexAttribPointer(et + 0, 4, Ot, !1, 64, 0),
            t.vertexAttribPointer(et + 1, 4, Ot, !1, 64, 16),
            t.vertexAttribPointer(et + 2, 4, Ot, !1, 64, 32),
            t.vertexAttribPointer(et + 3, 4, Ot, !1, 64, 48);
        } else if (K !== void 0) {
          const mt = K[it];
          if (mt !== void 0)
            switch (mt.length) {
              case 2:
                t.vertexAttrib2fv(et, mt);
                break;
              case 3:
                t.vertexAttrib3fv(et, mt);
                break;
              case 4:
                t.vertexAttrib4fv(et, mt);
                break;
              default:
                t.vertexAttrib1fv(et, mt);
            }
        }
      }
    }
    v();
  }
  function C() {
    I();
    for (const F in a) {
      const O = a[F];
      for (const R in O) {
        const P = O[R];
        for (const V in P) f(P[V].object), delete P[V];
        delete O[R];
      }
      delete a[F];
    }
  }
  function A(F) {
    if (a[F.id] === void 0) return;
    const O = a[F.id];
    for (const R in O) {
      const P = O[R];
      for (const V in P) f(P[V].object), delete P[V];
      delete O[R];
    }
    delete a[F.id];
  }
  function U(F) {
    for (const O in a) {
      const R = a[O];
      if (R[F.id] === void 0) continue;
      const P = R[F.id];
      for (const V in P) f(P[V].object), delete P[V];
      delete R[F.id];
    }
  }
  function I() {
    B(), l !== c && ((l = c), d(l.object));
  }
  function B() {
    (c.geometry = null), (c.program = null), (c.wireframe = !1);
  }
  return {
    setup: u,
    reset: I,
    resetDefaultState: B,
    dispose: C,
    releaseStatesOfGeometry: A,
    releaseStatesOfProgram: U,
    initAttributes: g,
    enableAttribute: b,
    disableUnusedAttributes: v,
  };
}
function Jb(t, e, n, i) {
  const r = i.isWebGL2;
  let s;
  function o(l) {
    s = l;
  }
  function a(l, u) {
    t.drawArrays(s, l, u), n.update(u, s);
  }
  function c(l, u, h, d) {
    if (d === 0) return;
    let f, p;
    if (r) (f = t), (p = "drawArraysInstanced");
    else if (
      ((f = e.get("ANGLE_instanced_arrays")),
      (p = "drawArraysInstancedANGLE"),
      f === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    f[p](s, u, h, d), n.update(h, s, d);
  }
  (this.setMode = o), (this.render = a), (this.renderInstances = c);
}
function $b(t, e, n) {
  let i;
  function r() {
    if (i !== void 0) return i;
    const w = e.get("EXT_texture_filter_anisotropic");
    return (
      w !== null
        ? (i = t.getParameter(w.MAX_TEXTURE_MAX_ANISOTROPY_EXT))
        : (i = 0),
      i
    );
  }
  function s(w) {
    if (w === "highp") {
      if (
        t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
        t.getShaderPrecisionFormat(35632, 36338).precision > 0
      )
        return "highp";
      w = "mediump";
    }
    return w === "mediump" &&
      t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
      t.getShaderPrecisionFormat(35632, 36337).precision > 0
      ? "mediump"
      : "lowp";
  }
  const o =
    (typeof WebGL2RenderingContext != "undefined" &&
      t instanceof WebGL2RenderingContext) ||
    (typeof WebGL2ComputeRenderingContext != "undefined" &&
      t instanceof WebGL2ComputeRenderingContext);
  let a = n.precision !== void 0 ? n.precision : "highp";
  const c = s(a);
  c !== a &&
    (console.warn(
      "THREE.WebGLRenderer:",
      a,
      "not supported, using",
      c,
      "instead."
    ),
    (a = c));
  const l = n.logarithmicDepthBuffer === !0,
    u = t.getParameter(34930),
    h = t.getParameter(35660),
    d = t.getParameter(3379),
    f = t.getParameter(34076),
    p = t.getParameter(34921),
    _ = t.getParameter(36347),
    y = t.getParameter(36348),
    m = t.getParameter(36349),
    g = h > 0,
    b = o || !!e.get("OES_texture_float"),
    x = g && b,
    v = o ? t.getParameter(36183) : 0;
  return {
    isWebGL2: o,
    getMaxAnisotropy: r,
    getMaxPrecision: s,
    precision: a,
    logarithmicDepthBuffer: l,
    maxTextures: u,
    maxVertexTextures: h,
    maxTextureSize: d,
    maxCubemapSize: f,
    maxAttributes: p,
    maxVertexUniforms: _,
    maxVaryings: y,
    maxFragmentUniforms: m,
    vertexTextures: g,
    floatFragmentTextures: b,
    floatVertexTextures: x,
    maxSamples: v,
  };
}
function Qb() {
  const t = this;
  let e = null,
    n = 0,
    i = !1,
    r = !1;
  const s = new Vn(),
    o = new Ge(),
    a = { value: null, needsUpdate: !1 };
  (this.uniform = a),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (u, h, d) {
      const f = u.length !== 0 || h || n !== 0 || i;
      return (i = h), (e = l(u, d, 0)), (n = u.length), f;
    }),
    (this.beginShadows = function () {
      (r = !0), l(null);
    }),
    (this.endShadows = function () {
      (r = !1), c();
    }),
    (this.setState = function (u, h, d, f, p, _) {
      if (!i || u === null || u.length === 0 || (r && !d)) r ? l(null) : c();
      else {
        const y = r ? 0 : n,
          m = y * 4;
        let g = p.clippingState || null;
        (a.value = g), (g = l(u, f, m, _));
        for (let b = 0; b !== m; ++b) g[b] = e[b];
        (p.clippingState = g),
          (this.numIntersection = h ? this.numPlanes : 0),
          (this.numPlanes += y);
      }
    });
  function c() {
    a.value !== e && ((a.value = e), (a.needsUpdate = n > 0)),
      (t.numPlanes = n),
      (t.numIntersection = 0);
  }
  function l(u, h, d, f) {
    let p = u !== null ? u.length : 0,
      _ = null;
    if (p !== 0) {
      if (((_ = a.value), f !== !0 || _ === null)) {
        const y = d + p * 4,
          m = h.matrixWorldInverse;
        o.getNormalMatrix(m),
          (_ === null || _.length < y) && (_ = new Float32Array(y));
        for (let g = 0, b = d; g !== p; ++g, b += 4)
          s.copy(u[g]).applyMatrix4(m, o),
            s.normal.toArray(_, b),
            (_[b + 3] = s.constant);
      }
      (a.value = _), (a.needsUpdate = !0);
    }
    return (t.numPlanes = p), (t.numIntersection = 0), _;
  }
}
function Kb(t) {
  const e = {};
  return {
    get: function (n) {
      if (e[n] !== void 0) return e[n];
      let i;
      switch (n) {
        case "WEBGL_depth_texture":
          i =
            t.getExtension("WEBGL_depth_texture") ||
            t.getExtension("MOZ_WEBGL_depth_texture") ||
            t.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          i =
            t.getExtension("EXT_texture_filter_anisotropic") ||
            t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
            t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          i =
            t.getExtension("WEBGL_compressed_texture_s3tc") ||
            t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
            t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          i =
            t.getExtension("WEBGL_compressed_texture_pvrtc") ||
            t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          i = t.getExtension(n);
      }
      return (
        i === null &&
          console.warn(
            "THREE.WebGLRenderer: " + n + " extension not supported."
          ),
        (e[n] = i),
        i
      );
    },
  };
}
function tw(t, e, n, i) {
  const r = new WeakMap(),
    s = new WeakMap();
  function o(h) {
    const d = h.target,
      f = r.get(d);
    f.index !== null && e.remove(f.index);
    for (const _ in f.attributes) e.remove(f.attributes[_]);
    d.removeEventListener("dispose", o), r.delete(d);
    const p = s.get(f);
    p && (e.remove(p), s.delete(f)),
      i.releaseStatesOfGeometry(d),
      d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount,
      n.memory.geometries--;
  }
  function a(h, d) {
    let f = r.get(d);
    return (
      f ||
      (d.addEventListener("dispose", o),
      d.isBufferGeometry
        ? (f = d)
        : d.isGeometry &&
          (d._bufferGeometry === void 0 &&
            (d._bufferGeometry = new ct().setFromObject(h)),
          (f = d._bufferGeometry)),
      r.set(d, f),
      n.memory.geometries++,
      f)
    );
  }
  function c(h) {
    const d = h.attributes;
    for (const p in d) e.update(d[p], 34962);
    const f = h.morphAttributes;
    for (const p in f) {
      const _ = f[p];
      for (let y = 0, m = _.length; y < m; y++) e.update(_[y], 34962);
    }
  }
  function l(h) {
    const d = [],
      f = h.index,
      p = h.attributes.position;
    let _ = 0;
    if (f !== null) {
      const g = f.array;
      _ = f.version;
      for (let b = 0, x = g.length; b < x; b += 3) {
        const v = g[b + 0],
          w = g[b + 1],
          M = g[b + 2];
        d.push(v, w, w, M, M, v);
      }
    } else {
      const g = p.array;
      _ = p.version;
      for (let b = 0, x = g.length / 3 - 1; b < x; b += 3) {
        const v = b + 0,
          w = b + 1,
          M = b + 2;
        d.push(v, w, w, M, M, v);
      }
    }
    const y = new (Jp(d) > 65535 ? Eo : To)(d, 1);
    y.version = _;
    const m = s.get(h);
    m && e.remove(m), s.set(h, y);
  }
  function u(h) {
    const d = s.get(h);
    if (d) {
      const f = h.index;
      f !== null && d.version < f.version && l(h);
    } else l(h);
    return s.get(h);
  }
  return { get: a, update: c, getWireframeAttribute: u };
}
function ew(t, e, n, i) {
  const r = i.isWebGL2;
  let s;
  function o(d) {
    s = d;
  }
  let a, c;
  function l(d) {
    (a = d.type), (c = d.bytesPerElement);
  }
  function u(d, f) {
    t.drawElements(s, f, a, d * c), n.update(f, s);
  }
  function h(d, f, p, _) {
    if (_ === 0) return;
    let y, m;
    if (r) (y = t), (m = "drawElementsInstanced");
    else if (
      ((y = e.get("ANGLE_instanced_arrays")),
      (m = "drawElementsInstancedANGLE"),
      y === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    y[m](s, p, a, f * c, _), n.update(p, s, _);
  }
  (this.setMode = o),
    (this.setIndex = l),
    (this.render = u),
    (this.renderInstances = h);
}
function nw(t) {
  const e = { geometries: 0, textures: 0 },
    n = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function i(s, o, a) {
    switch (((a = a || 1), n.calls++, o)) {
      case 4:
        n.triangles += a * (s / 3);
        break;
      case 1:
        n.lines += a * (s / 2);
        break;
      case 3:
        n.lines += a * (s - 1);
        break;
      case 2:
        n.lines += a * s;
        break;
      case 0:
        n.points += a * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function r() {
    n.frame++, (n.calls = 0), (n.triangles = 0), (n.points = 0), (n.lines = 0);
  }
  return {
    memory: e,
    render: n,
    programs: null,
    autoReset: !0,
    reset: r,
    update: i,
  };
}
function iw(t, e) {
  return t[0] - e[0];
}
function rw(t, e) {
  return Math.abs(e[1]) - Math.abs(t[1]);
}
function sw(t) {
  const e = {},
    n = new Float32Array(8),
    i = [];
  for (let s = 0; s < 8; s++) i[s] = [s, 0];
  function r(s, o, a, c) {
    const l = s.morphTargetInfluences,
      u = l === void 0 ? 0 : l.length;
    let h = e[o.id];
    if (h === void 0) {
      h = [];
      for (let y = 0; y < u; y++) h[y] = [y, 0];
      e[o.id] = h;
    }
    for (let y = 0; y < u; y++) {
      const m = h[y];
      (m[0] = y), (m[1] = l[y]);
    }
    h.sort(rw);
    for (let y = 0; y < 8; y++)
      y < u && h[y][1]
        ? ((i[y][0] = h[y][0]), (i[y][1] = h[y][1]))
        : ((i[y][0] = Number.MAX_SAFE_INTEGER), (i[y][1] = 0));
    i.sort(iw);
    const d = a.morphTargets && o.morphAttributes.position,
      f = a.morphNormals && o.morphAttributes.normal;
    let p = 0;
    for (let y = 0; y < 8; y++) {
      const m = i[y],
        g = m[0],
        b = m[1];
      g !== Number.MAX_SAFE_INTEGER && b
        ? (d &&
            o.getAttribute("morphTarget" + y) !== d[g] &&
            o.setAttribute("morphTarget" + y, d[g]),
          f &&
            o.getAttribute("morphNormal" + y) !== f[g] &&
            o.setAttribute("morphNormal" + y, f[g]),
          (n[y] = b),
          (p += b))
        : (d &&
            o.getAttribute("morphTarget" + y) !== void 0 &&
            o.deleteAttribute("morphTarget" + y),
          f &&
            o.getAttribute("morphNormal" + y) !== void 0 &&
            o.deleteAttribute("morphNormal" + y),
          (n[y] = 0));
    }
    const _ = o.morphTargetsRelative ? 1 : 1 - p;
    c.getUniforms().setValue(t, "morphTargetBaseInfluence", _),
      c.getUniforms().setValue(t, "morphTargetInfluences", n);
  }
  return { update: r };
}
function ow(t, e, n, i) {
  let r = new WeakMap();
  function s(a) {
    const c = i.render.frame,
      l = a.geometry,
      u = e.get(a, l);
    return (
      r.get(u) !== c &&
        (l.isGeometry && u.updateFromObject(a), e.update(u), r.set(u, c)),
      a.isInstancedMesh && n.update(a.instanceMatrix, 34962),
      u
    );
  }
  function o() {
    r = new WeakMap();
  }
  return { update: s, dispose: o };
}
function Bi(t, e, n, i, r, s, o, a, c, l) {
  (t = t !== void 0 ? t : []),
    (e = e !== void 0 ? e : Gu),
    (o = o !== void 0 ? o : ar),
    Jt.call(this, t, e, n, i, r, s, o, a, c, l),
    (this.flipY = !1);
}
Bi.prototype = Object.create(Jt.prototype);
Bi.prototype.constructor = Bi;
Bi.prototype.isCubeTexture = !0;
Object.defineProperty(Bi.prototype, "images", {
  get: function () {
    return this.image;
  },
  set: function (t) {
    this.image = t;
  },
});
function Oo(t, e, n, i) {
  Jt.call(this, null),
    (this.image = {
      data: t || null,
      width: e || 1,
      height: n || 1,
      depth: i || 1,
    }),
    (this.magFilter = De),
    (this.minFilter = De),
    (this.wrapR = Ze),
    (this.generateMipmaps = !1),
    (this.flipY = !1),
    (this.needsUpdate = !0);
}
Oo.prototype = Object.create(Jt.prototype);
Oo.prototype.constructor = Oo;
Oo.prototype.isDataTexture2DArray = !0;
function Do(t, e, n, i) {
  Jt.call(this, null),
    (this.image = {
      data: t || null,
      width: e || 1,
      height: n || 1,
      depth: i || 1,
    }),
    (this.magFilter = De),
    (this.minFilter = De),
    (this.wrapR = Ze),
    (this.generateMipmaps = !1),
    (this.flipY = !1),
    (this.needsUpdate = !0);
}
Do.prototype = Object.create(Jt.prototype);
Do.prototype.constructor = Do;
Do.prototype.isDataTexture3D = !0;
const tm = new Jt(),
  aw = new Oo(),
  cw = new Do(),
  em = new Bi(),
  nm = [],
  im = [],
  rm = new Float32Array(16),
  sm = new Float32Array(9),
  om = new Float32Array(4);
function Ss(t, e, n) {
  const i = t[0];
  if (i <= 0 || i > 0) return t;
  let r = e * n,
    s = nm[r];
  if ((s === void 0 && ((s = new Float32Array(r)), (nm[r] = s)), e !== 0)) {
    i.toArray(s, 0);
    for (let o = 1, a = 0; o !== e; ++o) (a += n), t[o].toArray(s, a);
  }
  return s;
}
function mn(t, e) {
  if (t.length !== e.length) return !1;
  for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;
  return !0;
}
function on(t, e) {
  for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
}
function am(t, e) {
  let n = im[e];
  n === void 0 && ((n = new Int32Array(e)), (im[e] = n));
  for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
  return n;
}
function lw(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
}
function uw(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) &&
      (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
  else {
    if (mn(n, e)) return;
    t.uniform2fv(this.addr, e), on(n, e);
  }
}
function hw(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) &&
      (t.uniform3f(this.addr, e.x, e.y, e.z),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z));
  else if (e.r !== void 0)
    (n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) &&
      (t.uniform3f(this.addr, e.r, e.g, e.b),
      (n[0] = e.r),
      (n[1] = e.g),
      (n[2] = e.b));
  else {
    if (mn(n, e)) return;
    t.uniform3fv(this.addr, e), on(n, e);
  }
}
function fw(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) &&
      (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z),
      (n[3] = e.w));
  else {
    if (mn(n, e)) return;
    t.uniform4fv(this.addr, e), on(n, e);
  }
}
function dw(t, e) {
  const n = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (mn(n, e)) return;
    t.uniformMatrix2fv(this.addr, !1, e), on(n, e);
  } else {
    if (mn(n, i)) return;
    om.set(i), t.uniformMatrix2fv(this.addr, !1, om), on(n, i);
  }
}
function pw(t, e) {
  const n = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (mn(n, e)) return;
    t.uniformMatrix3fv(this.addr, !1, e), on(n, e);
  } else {
    if (mn(n, i)) return;
    sm.set(i), t.uniformMatrix3fv(this.addr, !1, sm), on(n, i);
  }
}
function mw(t, e) {
  const n = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (mn(n, e)) return;
    t.uniformMatrix4fv(this.addr, !1, e), on(n, e);
  } else {
    if (mn(n, i)) return;
    rm.set(i), t.uniformMatrix4fv(this.addr, !1, rm), on(n, i);
  }
}
function gw(t, e, n) {
  const i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
    n.safeSetTexture2D(e || tm, r);
}
function yw(t, e, n) {
  const i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
    n.setTexture2DArray(e || aw, r);
}
function _w(t, e, n) {
  const i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
    n.setTexture3D(e || cw, r);
}
function xw(t, e, n) {
  const i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
    n.safeSetTextureCube(e || em, r);
}
function vw(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
}
function bw(t, e) {
  const n = this.cache;
  mn(n, e) || (t.uniform2iv(this.addr, e), on(n, e));
}
function ww(t, e) {
  const n = this.cache;
  mn(n, e) || (t.uniform3iv(this.addr, e), on(n, e));
}
function Mw(t, e) {
  const n = this.cache;
  mn(n, e) || (t.uniform4iv(this.addr, e), on(n, e));
}
function Sw(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
}
function Tw(t) {
  switch (t) {
    case 5126:
      return lw;
    case 35664:
      return uw;
    case 35665:
      return hw;
    case 35666:
      return fw;
    case 35674:
      return dw;
    case 35675:
      return pw;
    case 35676:
      return mw;
    case 5124:
    case 35670:
      return vw;
    case 35667:
    case 35671:
      return bw;
    case 35668:
    case 35672:
      return ww;
    case 35669:
    case 35673:
      return Mw;
    case 5125:
      return Sw;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return gw;
    case 35679:
    case 36299:
    case 36307:
      return _w;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return xw;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return yw;
  }
}
function Ew(t, e) {
  t.uniform1fv(this.addr, e);
}
function Aw(t, e) {
  t.uniform1iv(this.addr, e);
}
function Lw(t, e) {
  t.uniform2iv(this.addr, e);
}
function Pw(t, e) {
  t.uniform3iv(this.addr, e);
}
function Cw(t, e) {
  t.uniform4iv(this.addr, e);
}
function Rw(t, e) {
  const n = Ss(e, this.size, 2);
  t.uniform2fv(this.addr, n);
}
function Ow(t, e) {
  const n = Ss(e, this.size, 3);
  t.uniform3fv(this.addr, n);
}
function Dw(t, e) {
  const n = Ss(e, this.size, 4);
  t.uniform4fv(this.addr, n);
}
function Iw(t, e) {
  const n = Ss(e, this.size, 4);
  t.uniformMatrix2fv(this.addr, !1, n);
}
function Nw(t, e) {
  const n = Ss(e, this.size, 9);
  t.uniformMatrix3fv(this.addr, !1, n);
}
function Fw(t, e) {
  const n = Ss(e, this.size, 16);
  t.uniformMatrix4fv(this.addr, !1, n);
}
function Bw(t, e, n) {
  const i = e.length,
    r = am(n, i);
  t.uniform1iv(this.addr, r);
  for (let s = 0; s !== i; ++s) n.safeSetTexture2D(e[s] || tm, r[s]);
}
function zw(t, e, n) {
  const i = e.length,
    r = am(n, i);
  t.uniform1iv(this.addr, r);
  for (let s = 0; s !== i; ++s) n.safeSetTextureCube(e[s] || em, r[s]);
}
function Uw(t) {
  switch (t) {
    case 5126:
      return Ew;
    case 35664:
      return Rw;
    case 35665:
      return Ow;
    case 35666:
      return Dw;
    case 35674:
      return Iw;
    case 35675:
      return Nw;
    case 35676:
      return Fw;
    case 5124:
    case 35670:
      return Aw;
    case 35667:
    case 35671:
      return Lw;
    case 35668:
    case 35672:
      return Pw;
    case 35669:
    case 35673:
      return Cw;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Bw;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return zw;
  }
}
function kw(t, e, n) {
  (this.id = t),
    (this.addr = n),
    (this.cache = []),
    (this.setValue = Tw(e.type));
}
function cm(t, e, n) {
  (this.id = t),
    (this.addr = n),
    (this.cache = []),
    (this.size = e.size),
    (this.setValue = Uw(e.type));
}
cm.prototype.updateCache = function (t) {
  let e = this.cache;
  t instanceof Float32Array &&
    e.length !== t.length &&
    (this.cache = new Float32Array(t.length)),
    on(e, t);
};
function lm(t) {
  (this.id = t), (this.seq = []), (this.map = {});
}
lm.prototype.setValue = function (t, e, n) {
  const i = this.seq;
  for (let r = 0, s = i.length; r !== s; ++r) {
    const o = i[r];
    o.setValue(t, e[o.id], n);
  }
};
const Sh = /([\w\d_]+)(\])?(\[|\.)?/g;
function um(t, e) {
  t.seq.push(e), (t.map[e.id] = e);
}
function Gw(t, e, n) {
  const i = t.name,
    r = i.length;
  for (Sh.lastIndex = 0; ; ) {
    const s = Sh.exec(i),
      o = Sh.lastIndex;
    let a = s[1],
      c = s[2] === "]",
      l = s[3];
    if ((c && (a = a | 0), l === void 0 || (l === "[" && o + 2 === r))) {
      um(n, l === void 0 ? new kw(a, t, e) : new cm(a, t, e));
      break;
    } else {
      let h = n.map[a];
      h === void 0 && ((h = new lm(a)), um(n, h)), (n = h);
    }
  }
}
function zi(t, e) {
  (this.seq = []), (this.map = {});
  const n = t.getProgramParameter(e, 35718);
  for (let i = 0; i < n; ++i) {
    const r = t.getActiveUniform(e, i),
      s = t.getUniformLocation(e, r.name);
    Gw(r, s, this);
  }
}
zi.prototype.setValue = function (t, e, n, i) {
  const r = this.map[e];
  r !== void 0 && r.setValue(t, n, i);
};
zi.prototype.setOptional = function (t, e, n) {
  const i = e[n];
  i !== void 0 && this.setValue(t, n, i);
};
zi.upload = function (t, e, n, i) {
  for (let r = 0, s = e.length; r !== s; ++r) {
    const o = e[r],
      a = n[o.id];
    a.needsUpdate !== !1 && o.setValue(t, a.value, i);
  }
};
zi.seqWithValue = function (t, e) {
  const n = [];
  for (let i = 0, r = t.length; i !== r; ++i) {
    const s = t[i];
    s.id in e && n.push(s);
  }
  return n;
};
function hm(t, e, n) {
  const i = t.createShader(e);
  return t.shaderSource(i, n), t.compileShader(i), i;
}
let Hw = 0;
function Vw(t) {
  const e = t.split(`
`);
  for (let n = 0; n < e.length; n++) e[n] = n + 1 + ": " + e[n];
  return e.join(`
`);
}
function fm(t) {
  switch (t) {
    case vo:
      return ["Linear", "( value )"];
    case zp:
      return ["sRGB", "( value )"];
    case ex:
      return ["RGBE", "( value )"];
    case ix:
      return ["RGBM", "( value, 7.0 )"];
    case rx:
      return ["RGBM", "( value, 16.0 )"];
    case sx:
      return ["RGBD", "( value, 256.0 )"];
    case tx:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    case nx:
      return ["LogLuv", "( value )"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported encoding:", t),
        ["Linear", "( value )"]
      );
  }
}
function dm(t, e, n) {
  const i = t.getShaderParameter(e, 35713),
    r = t.getShaderInfoLog(e).trim();
  if (i && r === "") return "";
  const s = t.getShaderSource(e);
  return (
    "THREE.WebGLShader: gl.getShaderInfoLog() " +
    n +
    `
` +
    r +
    Vw(s)
  );
}
function Io(t, e) {
  const n = fm(e);
  return (
    "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
  );
}
function Ww(t, e) {
  const n = fm(e);
  return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }";
}
function jw(t, e) {
  let n;
  switch (e) {
    case t0:
      n = "Linear";
      break;
    case e0:
      n = "Reinhard";
      break;
    case n0:
      n = "OptimizedCineon";
      break;
    case i0:
      n = "ACESFilmic";
      break;
    case r0:
      n = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (n = "Linear");
  }
  return (
    "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
  );
}
function qw(t) {
  return [
    t.extensionDerivatives ||
    t.envMapCubeUV ||
    t.bumpMap ||
    t.tangentSpaceNormalMap ||
    t.clearcoatNormalMap ||
    t.flatShading ||
    t.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
    t.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (t.extensionShaderTextureLOD || t.envMap) &&
    t.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(No).join(`
`);
}
function Xw(t) {
  const e = [];
  for (const n in t) {
    const i = t[n];
    i !== !1 && e.push("#define " + n + " " + i);
  }
  return e.join(`
`);
}
function Yw(t, e) {
  const n = {},
    i = t.getProgramParameter(e, 35721);
  for (let r = 0; r < i; r++) {
    const o = t.getActiveAttrib(e, r).name;
    n[o] = t.getAttribLocation(e, o);
  }
  return n;
}
function No(t) {
  return t !== "";
}
function pm(t, e) {
  return t
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function mm(t, e) {
  return t
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const Zw = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Th(t) {
  return t.replace(Zw, Jw);
}
function Jw(t, e) {
  const n = It[e];
  if (n === void 0) throw new Error("Can not resolve #include <" + e + ">");
  return Th(n);
}
const $w =
    /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
  Qw =
    /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;
function gm(t) {
  return t.replace(Qw, ym).replace($w, Kw);
}
function Kw(t, e, n, i) {
  return (
    console.warn(
      "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
    ),
    ym(t, e, n, i)
  );
}
function ym(t, e, n, i) {
  let r = "";
  for (let s = parseInt(e); s < parseInt(n); s++)
    r += i
      .replace(/\[ i \]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function _m(t) {
  let e =
    "precision " +
    t.precision +
    ` float;
precision ` +
    t.precision +
    " int;";
  return (
    t.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : t.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : t.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function tM(t) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    t.shadowMapType === gp
      ? (e = "SHADOWMAP_TYPE_PCF")
      : t.shadowMapType === O_
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : t.shadowMapType === fo && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function eM(t) {
  let e = "ENVMAP_TYPE_CUBE";
  if (t.envMap)
    switch (t.envMapMode) {
      case Gu:
      case Hu:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case ec:
      case Wu:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
      case Tp:
      case Vu:
        e = "ENVMAP_TYPE_EQUIREC";
        break;
    }
  return e;
}
function nM(t) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (t.envMap)
    switch (t.envMapMode) {
      case Hu:
      case Vu:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function iM(t) {
  let e = "ENVMAP_BLENDING_NONE";
  if (t.envMap)
    switch (t.combine) {
      case tc:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case Q_:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case K_:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function rM(t, e, n, i) {
  const r = t.getContext(),
    s = n.defines;
  let o = n.vertexShader,
    a = n.fragmentShader;
  const c = tM(n),
    l = eM(n),
    u = nM(n),
    h = iM(n),
    d = t.gammaFactor > 0 ? t.gammaFactor : 1,
    f = n.isWebGL2 ? "" : qw(n),
    p = Xw(s),
    _ = r.createProgram();
  let y, m;
  if (
    (n.isRawShaderMaterial
      ? ((y = [p].filter(No).join(`
`)),
        y.length > 0 &&
          (y += `
`),
        (m = [f, p].filter(No).join(`
`)),
        m.length > 0 &&
          (m += `
`))
      : ((y = [
          _m(n),
          "#define SHADER_NAME " + n.shaderName,
          p,
          n.instancing ? "#define USE_INSTANCING" : "",
          n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
          "#define GAMMA_FACTOR " + d,
          "#define MAX_BONES " + n.maxBones,
          n.useFog && n.fog ? "#define USE_FOG" : "",
          n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
          n.map ? "#define USE_MAP" : "",
          n.envMap ? "#define USE_ENVMAP" : "",
          n.envMap ? "#define " + u : "",
          n.lightMap ? "#define USE_LIGHTMAP" : "",
          n.aoMap ? "#define USE_AOMAP" : "",
          n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          n.bumpMap ? "#define USE_BUMPMAP" : "",
          n.normalMap ? "#define USE_NORMALMAP" : "",
          n.normalMap && n.objectSpaceNormalMap
            ? "#define OBJECTSPACE_NORMALMAP"
            : "",
          n.normalMap && n.tangentSpaceNormalMap
            ? "#define TANGENTSPACE_NORMALMAP"
            : "",
          n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          n.displacementMap && n.supportsVertexTextures
            ? "#define USE_DISPLACEMENTMAP"
            : "",
          n.specularMap ? "#define USE_SPECULARMAP" : "",
          n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          n.metalnessMap ? "#define USE_METALNESSMAP" : "",
          n.alphaMap ? "#define USE_ALPHAMAP" : "",
          n.vertexTangents ? "#define USE_TANGENT" : "",
          n.vertexColors ? "#define USE_COLOR" : "",
          n.vertexUvs ? "#define USE_UV" : "",
          n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
          n.flatShading ? "#define FLAT_SHADED" : "",
          n.skinning ? "#define USE_SKINNING" : "",
          n.useVertexTexture ? "#define BONE_TEXTURE" : "",
          n.morphTargets ? "#define USE_MORPHTARGETS" : "",
          n.morphNormals && n.flatShading === !1
            ? "#define USE_MORPHNORMALS"
            : "",
          n.doubleSided ? "#define DOUBLE_SIDED" : "",
          n.flipSided ? "#define FLIP_SIDED" : "",
          n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          n.shadowMapEnabled ? "#define " + c : "",
          n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
          n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
            ? "#define USE_LOGDEPTHBUF_EXT"
            : "",
          "uniform mat4 modelMatrix;",
          "uniform mat4 modelViewMatrix;",
          "uniform mat4 projectionMatrix;",
          "uniform mat4 viewMatrix;",
          "uniform mat3 normalMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          "#ifdef USE_INSTANCING",
          " attribute mat4 instanceMatrix;",
          "#endif",
          "attribute vec3 position;",
          "attribute vec3 normal;",
          "attribute vec2 uv;",
          "#ifdef USE_TANGENT",
          "	attribute vec4 tangent;",
          "#endif",
          "#ifdef USE_COLOR",
          "	attribute vec3 color;",
          "#endif",
          "#ifdef USE_MORPHTARGETS",
          "	attribute vec3 morphTarget0;",
          "	attribute vec3 morphTarget1;",
          "	attribute vec3 morphTarget2;",
          "	attribute vec3 morphTarget3;",
          "	#ifdef USE_MORPHNORMALS",
          "		attribute vec3 morphNormal0;",
          "		attribute vec3 morphNormal1;",
          "		attribute vec3 morphNormal2;",
          "		attribute vec3 morphNormal3;",
          "	#else",
          "		attribute vec3 morphTarget4;",
          "		attribute vec3 morphTarget5;",
          "		attribute vec3 morphTarget6;",
          "		attribute vec3 morphTarget7;",
          "	#endif",
          "#endif",
          "#ifdef USE_SKINNING",
          "	attribute vec4 skinIndex;",
          "	attribute vec4 skinWeight;",
          "#endif",
          `
`,
        ].filter(No).join(`
`)),
        (m = [
          f,
          _m(n),
          "#define SHADER_NAME " + n.shaderName,
          p,
          n.alphaTest
            ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0")
            : "",
          "#define GAMMA_FACTOR " + d,
          n.useFog && n.fog ? "#define USE_FOG" : "",
          n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
          n.map ? "#define USE_MAP" : "",
          n.matcap ? "#define USE_MATCAP" : "",
          n.envMap ? "#define USE_ENVMAP" : "",
          n.envMap ? "#define " + l : "",
          n.envMap ? "#define " + u : "",
          n.envMap ? "#define " + h : "",
          n.lightMap ? "#define USE_LIGHTMAP" : "",
          n.aoMap ? "#define USE_AOMAP" : "",
          n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          n.bumpMap ? "#define USE_BUMPMAP" : "",
          n.normalMap ? "#define USE_NORMALMAP" : "",
          n.normalMap && n.objectSpaceNormalMap
            ? "#define OBJECTSPACE_NORMALMAP"
            : "",
          n.normalMap && n.tangentSpaceNormalMap
            ? "#define TANGENTSPACE_NORMALMAP"
            : "",
          n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          n.specularMap ? "#define USE_SPECULARMAP" : "",
          n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          n.metalnessMap ? "#define USE_METALNESSMAP" : "",
          n.alphaMap ? "#define USE_ALPHAMAP" : "",
          n.sheen ? "#define USE_SHEEN" : "",
          n.vertexTangents ? "#define USE_TANGENT" : "",
          n.vertexColors ? "#define USE_COLOR" : "",
          n.vertexUvs ? "#define USE_UV" : "",
          n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
          n.gradientMap ? "#define USE_GRADIENTMAP" : "",
          n.flatShading ? "#define FLAT_SHADED" : "",
          n.doubleSided ? "#define DOUBLE_SIDED" : "",
          n.flipSided ? "#define FLIP_SIDED" : "",
          n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          n.shadowMapEnabled ? "#define " + c : "",
          n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
          n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
          n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
            ? "#define USE_LOGDEPTHBUF_EXT"
            : "",
          (n.extensionShaderTextureLOD || n.envMap) &&
          n.rendererExtensionShaderTextureLod
            ? "#define TEXTURE_LOD_EXT"
            : "",
          "uniform mat4 viewMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          n.toneMapping !== yo ? "#define TONE_MAPPING" : "",
          n.toneMapping !== yo ? It.tonemapping_pars_fragment : "",
          n.toneMapping !== yo ? jw("toneMapping", n.toneMapping) : "",
          n.dithering ? "#define DITHERING" : "",
          It.encodings_pars_fragment,
          n.map ? Io("mapTexelToLinear", n.mapEncoding) : "",
          n.matcap ? Io("matcapTexelToLinear", n.matcapEncoding) : "",
          n.envMap ? Io("envMapTexelToLinear", n.envMapEncoding) : "",
          n.emissiveMap
            ? Io("emissiveMapTexelToLinear", n.emissiveMapEncoding)
            : "",
          n.lightMap ? Io("lightMapTexelToLinear", n.lightMapEncoding) : "",
          Ww("linearToOutputTexel", n.outputEncoding),
          n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
          `
`,
        ].filter(No).join(`
`))),
    (o = Th(o)),
    (o = pm(o, n)),
    (o = mm(o, n)),
    (a = Th(a)),
    (a = pm(a, n)),
    (a = mm(a, n)),
    (o = gm(o)),
    (a = gm(a)),
    n.isWebGL2 && !n.isRawShaderMaterial)
  ) {
    let C = !1;
    const A = /^\s*#version\s+300\s+es\s*\n/;
    n.isShaderMaterial &&
      o.match(A) !== null &&
      a.match(A) !== null &&
      ((C = !0), (o = o.replace(A, "")), (a = a.replace(A, ""))),
      (y =
        [
          `#version 300 es
`,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        y),
      (m =
        [
          `#version 300 es
`,
          "#define varying in",
          C ? "" : "out highp vec4 pc_fragColor;",
          C ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        m);
  }
  const g = y + o,
    b = m + a,
    x = hm(r, 35633, g),
    v = hm(r, 35632, b);
  if (
    (r.attachShader(_, x),
    r.attachShader(_, v),
    n.index0AttributeName !== void 0
      ? r.bindAttribLocation(_, 0, n.index0AttributeName)
      : n.morphTargets === !0 && r.bindAttribLocation(_, 0, "position"),
    r.linkProgram(_),
    t.debug.checkShaderErrors)
  ) {
    const C = r.getProgramInfoLog(_).trim(),
      A = r.getShaderInfoLog(x).trim(),
      U = r.getShaderInfoLog(v).trim();
    let I = !0,
      B = !0;
    if (r.getProgramParameter(_, 35714) === !1) {
      I = !1;
      const F = dm(r, x, "vertex"),
        O = dm(r, v, "fragment");
      console.error(
        "THREE.WebGLProgram: shader error: ",
        r.getError(),
        "35715",
        r.getProgramParameter(_, 35715),
        "gl.getProgramInfoLog",
        C,
        F,
        O
      );
    } else
      C !== ""
        ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", C)
        : (A === "" || U === "") && (B = !1);
    B &&
      (this.diagnostics = {
        runnable: I,
        programLog: C,
        vertexShader: { log: A, prefix: y },
        fragmentShader: { log: U, prefix: m },
      });
  }
  r.deleteShader(x), r.deleteShader(v);
  let w;
  this.getUniforms = function () {
    return w === void 0 && (w = new zi(r, _)), w;
  };
  let M;
  return (
    (this.getAttributes = function () {
      return M === void 0 && (M = Yw(r, _)), M;
    }),
    (this.destroy = function () {
      i.releaseStatesOfProgram(this),
        r.deleteProgram(_),
        (this.program = void 0);
    }),
    (this.name = n.shaderName),
    (this.id = Hw++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = _),
    (this.vertexShader = x),
    (this.fragmentShader = v),
    this
  );
}
function sM(t, e, n, i) {
  const r = [],
    s = n.isWebGL2,
    o = n.logarithmicDepthBuffer,
    a = n.floatVertexTextures,
    c = n.maxVertexUniforms,
    l = n.vertexTextures;
  let u = n.precision;
  const h = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite",
    },
    d = [
      "precision",
      "isWebGL2",
      "supportsVertexTextures",
      "outputEncoding",
      "instancing",
      "map",
      "mapEncoding",
      "matcap",
      "matcapEncoding",
      "envMap",
      "envMapMode",
      "envMapEncoding",
      "envMapCubeUV",
      "lightMap",
      "lightMapEncoding",
      "aoMap",
      "emissiveMap",
      "emissiveMapEncoding",
      "bumpMap",
      "normalMap",
      "objectSpaceNormalMap",
      "tangentSpaceNormalMap",
      "clearcoatMap",
      "clearcoatRoughnessMap",
      "clearcoatNormalMap",
      "displacementMap",
      "specularMap",
      "roughnessMap",
      "metalnessMap",
      "gradientMap",
      "alphaMap",
      "combine",
      "vertexColors",
      "vertexTangents",
      "vertexUvs",
      "uvsVertexOnly",
      "fog",
      "useFog",
      "fogExp2",
      "flatShading",
      "sizeAttenuation",
      "logarithmicDepthBuffer",
      "skinning",
      "maxBones",
      "useVertexTexture",
      "morphTargets",
      "morphNormals",
      "maxMorphTargets",
      "maxMorphNormals",
      "premultipliedAlpha",
      "numDirLights",
      "numPointLights",
      "numSpotLights",
      "numHemiLights",
      "numRectAreaLights",
      "numDirLightShadows",
      "numPointLightShadows",
      "numSpotLightShadows",
      "shadowMapEnabled",
      "shadowMapType",
      "toneMapping",
      "physicallyCorrectLights",
      "alphaTest",
      "doubleSided",
      "flipSided",
      "numClippingPlanes",
      "numClipIntersection",
      "depthPacking",
      "dithering",
      "sheen",
    ];
  function f(x, v) {
    let w;
    if (v) {
      const M = di[v];
      w = {
        name: x.name || x.type,
        uniforms: Tx.clone(M.uniforms),
        vertexShader: M.vertexShader,
        fragmentShader: M.fragmentShader,
      };
    } else
      w = {
        name: x.name || x.type,
        uniforms: x.uniforms,
        vertexShader: x.vertexShader,
        fragmentShader: x.fragmentShader,
      };
    return w;
  }
  function p(x) {
    const w = x.skeleton.bones;
    if (a) return 1024;
    {
      const C = Math.floor((c - 20) / 4),
        A = Math.min(C, w.length);
      return A < w.length
        ? (console.warn(
            "THREE.WebGLRenderer: Skeleton has " +
              w.length +
              " bones. This GPU supports " +
              A +
              "."
          ),
          0)
        : A;
    }
  }
  function _(x) {
    let v;
    return (
      x
        ? x.isTexture
          ? (v = x.encoding)
          : x.isWebGLRenderTarget &&
            (console.warn(
              "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
            ),
            (v = x.texture.encoding))
        : (v = vo),
      v
    );
  }
  function y(x, v, w, M, C, A, U) {
    const I = M.fog,
      B = x.isMeshStandardMaterial ? M.environment : null,
      F = x.envMap || B,
      O = h[x.type],
      R = U.isSkinnedMesh ? p(U) : 0;
    x.precision !== null &&
      ((u = n.getMaxPrecision(x.precision)),
      u !== x.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          x.precision,
          "not supported, using",
          u,
          "instead."
        ));
    const P = f(x, O);
    x.onBeforeCompile(P, t);
    const V = t.getRenderTarget();
    return {
      isWebGL2: s,
      shaderID: O,
      shaderName: P.name,
      uniforms: P.uniforms,
      vertexShader: P.vertexShader,
      fragmentShader: P.fragmentShader,
      defines: x.defines,
      isRawShaderMaterial: x.isRawShaderMaterial,
      isShaderMaterial: x.isShaderMaterial,
      precision: u,
      instancing: U.isInstancedMesh === !0,
      supportsVertexTextures: l,
      outputEncoding: V !== null ? _(V.texture) : t.outputEncoding,
      map: !!x.map,
      mapEncoding: _(x.map),
      matcap: !!x.matcap,
      matcapEncoding: _(x.matcap),
      envMap: !!F,
      envMapMode: F && F.mapping,
      envMapEncoding: _(F),
      envMapCubeUV: !!F && (F.mapping === ec || F.mapping === Wu),
      lightMap: !!x.lightMap,
      lightMapEncoding: _(x.lightMap),
      aoMap: !!x.aoMap,
      emissiveMap: !!x.emissiveMap,
      emissiveMapEncoding: _(x.emissiveMap),
      bumpMap: !!x.bumpMap,
      normalMap: !!x.normalMap,
      objectSpaceNormalMap: x.normalMapType === cx,
      tangentSpaceNormalMap: x.normalMapType === is,
      clearcoatMap: !!x.clearcoatMap,
      clearcoatRoughnessMap: !!x.clearcoatRoughnessMap,
      clearcoatNormalMap: !!x.clearcoatNormalMap,
      displacementMap: !!x.displacementMap,
      roughnessMap: !!x.roughnessMap,
      metalnessMap: !!x.metalnessMap,
      specularMap: !!x.specularMap,
      alphaMap: !!x.alphaMap,
      gradientMap: !!x.gradientMap,
      sheen: !!x.sheen,
      combine: x.combine,
      vertexTangents: x.normalMap && x.vertexTangents,
      vertexColors: x.vertexColors,
      vertexUvs:
        !!x.map ||
        !!x.bumpMap ||
        !!x.normalMap ||
        !!x.specularMap ||
        !!x.alphaMap ||
        !!x.emissiveMap ||
        !!x.roughnessMap ||
        !!x.metalnessMap ||
        !!x.clearcoatMap ||
        !!x.clearcoatRoughnessMap ||
        !!x.clearcoatNormalMap ||
        !!x.displacementMap,
      uvsVertexOnly:
        !(
          !!x.map ||
          !!x.bumpMap ||
          !!x.normalMap ||
          !!x.specularMap ||
          !!x.alphaMap ||
          !!x.emissiveMap ||
          !!x.roughnessMap ||
          !!x.metalnessMap ||
          !!x.clearcoatNormalMap
        ) && !!x.displacementMap,
      fog: !!I,
      useFog: x.fog,
      fogExp2: I && I.isFogExp2,
      flatShading: x.flatShading,
      sizeAttenuation: x.sizeAttenuation,
      logarithmicDepthBuffer: o,
      skinning: x.skinning && R > 0,
      maxBones: R,
      useVertexTexture: a,
      morphTargets: x.morphTargets,
      morphNormals: x.morphNormals,
      maxMorphTargets: t.maxMorphTargets,
      maxMorphNormals: t.maxMorphNormals,
      numDirLights: v.directional.length,
      numPointLights: v.point.length,
      numSpotLights: v.spot.length,
      numRectAreaLights: v.rectArea.length,
      numHemiLights: v.hemi.length,
      numDirLightShadows: v.directionalShadowMap.length,
      numPointLightShadows: v.pointShadowMap.length,
      numSpotLightShadows: v.spotShadowMap.length,
      numClippingPlanes: C,
      numClipIntersection: A,
      dithering: x.dithering,
      shadowMapEnabled: t.shadowMap.enabled && w.length > 0,
      shadowMapType: t.shadowMap.type,
      toneMapping: x.toneMapped ? t.toneMapping : yo,
      physicallyCorrectLights: t.physicallyCorrectLights,
      premultipliedAlpha: x.premultipliedAlpha,
      alphaTest: x.alphaTest,
      doubleSided: x.side === Ka,
      flipSided: x.side === Ee,
      depthPacking: x.depthPacking !== void 0 ? x.depthPacking : !1,
      index0AttributeName: x.index0AttributeName,
      extensionDerivatives: x.extensions && x.extensions.derivatives,
      extensionFragDepth: x.extensions && x.extensions.fragDepth,
      extensionDrawBuffers: x.extensions && x.extensions.drawBuffers,
      extensionShaderTextureLOD: x.extensions && x.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: s || e.get("EXT_frag_depth") !== null,
      rendererExtensionDrawBuffers: s || e.get("WEBGL_draw_buffers") !== null,
      rendererExtensionShaderTextureLod:
        s || e.get("EXT_shader_texture_lod") !== null,
      customProgramCacheKey: x.customProgramCacheKey(),
    };
  }
  function m(x) {
    const v = [];
    if (
      (x.shaderID
        ? v.push(x.shaderID)
        : (v.push(x.fragmentShader), v.push(x.vertexShader)),
      x.defines !== void 0)
    )
      for (const w in x.defines) v.push(w), v.push(x.defines[w]);
    if (x.isRawShaderMaterial === void 0) {
      for (let w = 0; w < d.length; w++) v.push(x[d[w]]);
      v.push(t.outputEncoding), v.push(t.gammaFactor);
    }
    return v.push(x.customProgramCacheKey), v.join();
  }
  function g(x, v) {
    let w;
    for (let M = 0, C = r.length; M < C; M++) {
      const A = r[M];
      if (A.cacheKey === v) {
        (w = A), ++w.usedTimes;
        break;
      }
    }
    return w === void 0 && ((w = new rM(t, v, x, i)), r.push(w)), w;
  }
  function b(x) {
    if (--x.usedTimes == 0) {
      const v = r.indexOf(x);
      (r[v] = r[r.length - 1]), r.pop(), x.destroy();
    }
  }
  return {
    getParameters: y,
    getProgramCacheKey: m,
    acquireProgram: g,
    releaseProgram: b,
    programs: r,
  };
}
function oM() {
  let t = new WeakMap();
  function e(s) {
    let o = t.get(s);
    return o === void 0 && ((o = {}), t.set(s, o)), o;
  }
  function n(s) {
    t.delete(s);
  }
  function i(s, o, a) {
    t.get(s)[o] = a;
  }
  function r() {
    t = new WeakMap();
  }
  return { get: e, remove: n, update: i, dispose: r };
}
function aM(t, e) {
  return t.groupOrder !== e.groupOrder
    ? t.groupOrder - e.groupOrder
    : t.renderOrder !== e.renderOrder
    ? t.renderOrder - e.renderOrder
    : t.program !== e.program
    ? t.program.id - e.program.id
    : t.material.id !== e.material.id
    ? t.material.id - e.material.id
    : t.z !== e.z
    ? t.z - e.z
    : t.id - e.id;
}
function cM(t, e) {
  return t.groupOrder !== e.groupOrder
    ? t.groupOrder - e.groupOrder
    : t.renderOrder !== e.renderOrder
    ? t.renderOrder - e.renderOrder
    : t.z !== e.z
    ? e.z - t.z
    : t.id - e.id;
}
function xm() {
  const t = [];
  let e = 0;
  const n = [],
    i = [],
    r = { id: -1 };
  function s() {
    (e = 0), (n.length = 0), (i.length = 0);
  }
  function o(h, d, f, p, _, y) {
    let m = t[e];
    return (
      m === void 0
        ? ((m = {
            id: h.id,
            object: h,
            geometry: d,
            material: f,
            program: f.program || r,
            groupOrder: p,
            renderOrder: h.renderOrder,
            z: _,
            group: y,
          }),
          (t[e] = m))
        : ((m.id = h.id),
          (m.object = h),
          (m.geometry = d),
          (m.material = f),
          (m.program = f.program || r),
          (m.groupOrder = p),
          (m.renderOrder = h.renderOrder),
          (m.z = _),
          (m.group = y)),
      e++,
      m
    );
  }
  function a(h, d, f, p, _, y) {
    const m = o(h, d, f, p, _, y);
    (f.transparent === !0 ? i : n).push(m);
  }
  function c(h, d, f, p, _, y) {
    const m = o(h, d, f, p, _, y);
    (f.transparent === !0 ? i : n).unshift(m);
  }
  function l(h, d) {
    n.length > 1 && n.sort(h || aM), i.length > 1 && i.sort(d || cM);
  }
  function u() {
    for (let h = e, d = t.length; h < d; h++) {
      const f = t[h];
      if (f.id === null) break;
      (f.id = null),
        (f.object = null),
        (f.geometry = null),
        (f.material = null),
        (f.program = null),
        (f.group = null);
    }
  }
  return {
    opaque: n,
    transparent: i,
    init: s,
    push: a,
    unshift: c,
    finish: u,
    sort: l,
  };
}
function lM() {
  let t = new WeakMap();
  function e(r) {
    const s = r.target;
    s.removeEventListener("dispose", e), t.delete(s);
  }
  function n(r, s) {
    const o = t.get(r);
    let a;
    return (
      o === void 0
        ? ((a = new xm()),
          t.set(r, new WeakMap()),
          t.get(r).set(s, a),
          r.addEventListener("dispose", e))
        : ((a = o.get(s)), a === void 0 && ((a = new xm()), o.set(s, a))),
      a
    );
  }
  function i() {
    t = new WeakMap();
  }
  return { get: n, dispose: i };
}
function uM() {
  const t = {};
  return {
    get: function (e) {
      if (t[e.id] !== void 0) return t[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = { direction: new S(), color: new lt() };
          break;
        case "SpotLight":
          n = {
            position: new S(),
            direction: new S(),
            color: new lt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          n = { position: new S(), color: new lt(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          n = { direction: new S(), skyColor: new lt(), groundColor: new lt() };
          break;
        case "RectAreaLight":
          n = {
            color: new lt(),
            position: new S(),
            halfWidth: new S(),
            halfHeight: new S(),
          };
          break;
      }
      return (t[e.id] = n), n;
    },
  };
}
function hM() {
  const t = {};
  return {
    get: function (e) {
      if (t[e.id] !== void 0) return t[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new H(),
          };
          break;
        case "SpotLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new H(),
          };
          break;
        case "PointLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new H(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (t[e.id] = n), n;
    },
  };
}
let fM = 0;
function dM(t, e) {
  return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
}
function pM() {
  const t = new uM(),
    e = hM(),
    n = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadow: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      rectArea: [],
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
    };
  for (let a = 0; a < 9; a++) n.probe.push(new S());
  const i = new S(),
    r = new Rt(),
    s = new Rt();
  function o(a, c, l) {
    let u = 0,
      h = 0,
      d = 0;
    for (let M = 0; M < 9; M++) n.probe[M].set(0, 0, 0);
    let f = 0,
      p = 0,
      _ = 0,
      y = 0,
      m = 0,
      g = 0,
      b = 0,
      x = 0;
    const v = l.matrixWorldInverse;
    a.sort(dM);
    for (let M = 0, C = a.length; M < C; M++) {
      const A = a[M],
        U = A.color,
        I = A.intensity,
        B = A.distance,
        F = A.shadow && A.shadow.map ? A.shadow.map.texture : null;
      if (A.isAmbientLight) (u += U.r * I), (h += U.g * I), (d += U.b * I);
      else if (A.isLightProbe)
        for (let O = 0; O < 9; O++)
          n.probe[O].addScaledVector(A.sh.coefficients[O], I);
      else if (A.isDirectionalLight) {
        const O = t.get(A);
        if (
          (O.color.copy(A.color).multiplyScalar(A.intensity),
          O.direction.setFromMatrixPosition(A.matrixWorld),
          i.setFromMatrixPosition(A.target.matrixWorld),
          O.direction.sub(i),
          O.direction.transformDirection(v),
          A.castShadow)
        ) {
          const R = A.shadow,
            P = e.get(A);
          (P.shadowBias = R.bias),
            (P.shadowNormalBias = R.normalBias),
            (P.shadowRadius = R.radius),
            (P.shadowMapSize = R.mapSize),
            (n.directionalShadow[f] = P),
            (n.directionalShadowMap[f] = F),
            (n.directionalShadowMatrix[f] = A.shadow.matrix),
            g++;
        }
        (n.directional[f] = O), f++;
      } else if (A.isSpotLight) {
        const O = t.get(A);
        if (
          (O.position.setFromMatrixPosition(A.matrixWorld),
          O.position.applyMatrix4(v),
          O.color.copy(U).multiplyScalar(I),
          (O.distance = B),
          O.direction.setFromMatrixPosition(A.matrixWorld),
          i.setFromMatrixPosition(A.target.matrixWorld),
          O.direction.sub(i),
          O.direction.transformDirection(v),
          (O.coneCos = Math.cos(A.angle)),
          (O.penumbraCos = Math.cos(A.angle * (1 - A.penumbra))),
          (O.decay = A.decay),
          A.castShadow)
        ) {
          const R = A.shadow,
            P = e.get(A);
          (P.shadowBias = R.bias),
            (P.shadowNormalBias = R.normalBias),
            (P.shadowRadius = R.radius),
            (P.shadowMapSize = R.mapSize),
            (n.spotShadow[_] = P),
            (n.spotShadowMap[_] = F),
            (n.spotShadowMatrix[_] = A.shadow.matrix),
            x++;
        }
        (n.spot[_] = O), _++;
      } else if (A.isRectAreaLight) {
        const O = t.get(A);
        O.color.copy(U).multiplyScalar(I),
          O.position.setFromMatrixPosition(A.matrixWorld),
          O.position.applyMatrix4(v),
          s.identity(),
          r.copy(A.matrixWorld),
          r.premultiply(v),
          s.extractRotation(r),
          O.halfWidth.set(A.width * 0.5, 0, 0),
          O.halfHeight.set(0, A.height * 0.5, 0),
          O.halfWidth.applyMatrix4(s),
          O.halfHeight.applyMatrix4(s),
          (n.rectArea[y] = O),
          y++;
      } else if (A.isPointLight) {
        const O = t.get(A);
        if (
          (O.position.setFromMatrixPosition(A.matrixWorld),
          O.position.applyMatrix4(v),
          O.color.copy(A.color).multiplyScalar(A.intensity),
          (O.distance = A.distance),
          (O.decay = A.decay),
          A.castShadow)
        ) {
          const R = A.shadow,
            P = e.get(A);
          (P.shadowBias = R.bias),
            (P.shadowNormalBias = R.normalBias),
            (P.shadowRadius = R.radius),
            (P.shadowMapSize = R.mapSize),
            (P.shadowCameraNear = R.camera.near),
            (P.shadowCameraFar = R.camera.far),
            (n.pointShadow[p] = P),
            (n.pointShadowMap[p] = F),
            (n.pointShadowMatrix[p] = A.shadow.matrix),
            b++;
        }
        (n.point[p] = O), p++;
      } else if (A.isHemisphereLight) {
        const O = t.get(A);
        O.direction.setFromMatrixPosition(A.matrixWorld),
          O.direction.transformDirection(v),
          O.direction.normalize(),
          O.skyColor.copy(A.color).multiplyScalar(I),
          O.groundColor.copy(A.groundColor).multiplyScalar(I),
          (n.hemi[m] = O),
          m++;
      }
    }
    (n.ambient[0] = u), (n.ambient[1] = h), (n.ambient[2] = d);
    const w = n.hash;
    (w.directionalLength !== f ||
      w.pointLength !== p ||
      w.spotLength !== _ ||
      w.rectAreaLength !== y ||
      w.hemiLength !== m ||
      w.numDirectionalShadows !== g ||
      w.numPointShadows !== b ||
      w.numSpotShadows !== x) &&
      ((n.directional.length = f),
      (n.spot.length = _),
      (n.rectArea.length = y),
      (n.point.length = p),
      (n.hemi.length = m),
      (n.directionalShadow.length = g),
      (n.directionalShadowMap.length = g),
      (n.pointShadow.length = b),
      (n.pointShadowMap.length = b),
      (n.spotShadow.length = x),
      (n.spotShadowMap.length = x),
      (n.directionalShadowMatrix.length = g),
      (n.pointShadowMatrix.length = b),
      (n.spotShadowMatrix.length = x),
      (w.directionalLength = f),
      (w.pointLength = p),
      (w.spotLength = _),
      (w.rectAreaLength = y),
      (w.hemiLength = m),
      (w.numDirectionalShadows = g),
      (w.numPointShadows = b),
      (w.numSpotShadows = x),
      (n.version = fM++));
  }
  return { setup: o, state: n };
}
function vm() {
  const t = new pM(),
    e = [],
    n = [];
  function i() {
    (e.length = 0), (n.length = 0);
  }
  function r(c) {
    e.push(c);
  }
  function s(c) {
    n.push(c);
  }
  function o(c) {
    t.setup(e, n, c);
  }
  return {
    init: i,
    state: { lightsArray: e, shadowsArray: n, lights: t },
    setupLights: o,
    pushLight: r,
    pushShadow: s,
  };
}
function mM() {
  let t = new WeakMap();
  function e(r) {
    const s = r.target;
    s.removeEventListener("dispose", e), t.delete(s);
  }
  function n(r, s) {
    let o;
    return (
      t.has(r) === !1
        ? ((o = new vm()),
          t.set(r, new WeakMap()),
          t.get(r).set(s, o),
          r.addEventListener("dispose", e))
        : t.get(r).has(s) === !1
        ? ((o = new vm()), t.get(r).set(s, o))
        : (o = t.get(r).get(s)),
      o
    );
  }
  function i() {
    t = new WeakMap();
  }
  return { get: n, dispose: i };
}
function fr(t) {
  bt.call(this),
    (this.type = "MeshDepthMaterial"),
    (this.depthPacking = ox),
    (this.skinning = !1),
    (this.morphTargets = !1),
    (this.map = null),
    (this.alphaMap = null),
    (this.displacementMap = null),
    (this.displacementScale = 1),
    (this.displacementBias = 0),
    (this.wireframe = !1),
    (this.wireframeLinewidth = 1),
    (this.fog = !1),
    this.setValues(t);
}
fr.prototype = Object.create(bt.prototype);
fr.prototype.constructor = fr;
fr.prototype.isMeshDepthMaterial = !0;
fr.prototype.copy = function (t) {
  return (
    bt.prototype.copy.call(this, t),
    (this.depthPacking = t.depthPacking),
    (this.skinning = t.skinning),
    (this.morphTargets = t.morphTargets),
    (this.map = t.map),
    (this.alphaMap = t.alphaMap),
    (this.displacementMap = t.displacementMap),
    (this.displacementScale = t.displacementScale),
    (this.displacementBias = t.displacementBias),
    (this.wireframe = t.wireframe),
    (this.wireframeLinewidth = t.wireframeLinewidth),
    this
  );
};
function dr(t) {
  bt.call(this),
    (this.type = "MeshDistanceMaterial"),
    (this.referencePosition = new S()),
    (this.nearDistance = 1),
    (this.farDistance = 1e3),
    (this.skinning = !1),
    (this.morphTargets = !1),
    (this.map = null),
    (this.alphaMap = null),
    (this.displacementMap = null),
    (this.displacementScale = 1),
    (this.displacementBias = 0),
    (this.fog = !1),
    this.setValues(t);
}
dr.prototype = Object.create(bt.prototype);
dr.prototype.constructor = dr;
dr.prototype.isMeshDistanceMaterial = !0;
dr.prototype.copy = function (t) {
  return (
    bt.prototype.copy.call(this, t),
    this.referencePosition.copy(t.referencePosition),
    (this.nearDistance = t.nearDistance),
    (this.farDistance = t.farDistance),
    (this.skinning = t.skinning),
    (this.morphTargets = t.morphTargets),
    (this.map = t.map),
    (this.alphaMap = t.alphaMap),
    (this.displacementMap = t.displacementMap),
    (this.displacementScale = t.displacementScale),
    (this.displacementBias = t.displacementBias),
    this
  );
};
var gM = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
  float mean = 0.0;
  float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );
  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
    #ifdef HORIZONAL_PASS
      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
      mean += distribution.x;
      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
    #else
      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );
      mean += depth;
      squared_mean += depth * depth;
    #endif
  }
  mean = mean * HALF_SAMPLE_RATE;
  squared_mean = squared_mean * HALF_SAMPLE_RATE;
  float std_dev = sqrt( squared_mean - mean * mean );
  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`,
  yM = `void main() {
	gl_Position = vec4( position, 1.0 );
}`;
function bm(t, e, n) {
  let i = new Ro();
  const r = new H(),
    s = new H(),
    o = new Vt(),
    a = [],
    c = [],
    l = {},
    u = { 0: Ee, 1: po, 2: Ka },
    h = new Je({
      defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new H() },
        radius: { value: 4 },
      },
      vertexShader: yM,
      fragmentShader: gM,
    }),
    d = h.clone();
  d.defines.HORIZONAL_PASS = 1;
  const f = new ct();
  f.setAttribute(
    "position",
    new wt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const p = new he(f, h),
    _ = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = gp),
    (this.render = function (v, w, M) {
      if (
        _.enabled === !1 ||
        (_.autoUpdate === !1 && _.needsUpdate === !1) ||
        v.length === 0
      )
        return;
      const C = t.getRenderTarget(),
        A = t.getActiveCubeFace(),
        U = t.getActiveMipmapLevel(),
        I = t.state;
      I.setBlending(mo),
        I.buffers.color.setClear(1, 1, 1, 1),
        I.buffers.depth.setTest(!0),
        I.setScissorTest(!1);
      for (let B = 0, F = v.length; B < F; B++) {
        const O = v[B],
          R = O.shadow;
        if (R.autoUpdate === !1 && R.needsUpdate === !1) continue;
        if (R === void 0) {
          console.warn("THREE.WebGLShadowMap:", O, "has no shadow.");
          continue;
        }
        r.copy(R.mapSize);
        const P = R.getFrameExtents();
        if (
          (r.multiply(P),
          s.copy(R.mapSize),
          (r.x > n || r.y > n) &&
            (r.x > n &&
              ((s.x = Math.floor(n / P.x)),
              (r.x = s.x * P.x),
              (R.mapSize.x = s.x)),
            r.y > n &&
              ((s.y = Math.floor(n / P.y)),
              (r.y = s.y * P.y),
              (R.mapSize.y = s.y))),
          R.map === null && !R.isPointLightShadow && this.type === fo)
        ) {
          const Y = { minFilter: Ie, magFilter: Ie, format: Gn };
          (R.map = new Sn(r.x, r.y, Y)),
            (R.map.texture.name = O.name + ".shadowMap"),
            (R.mapPass = new Sn(r.x, r.y, Y)),
            R.camera.updateProjectionMatrix();
        }
        if (R.map === null) {
          const Y = { minFilter: De, magFilter: De, format: Gn };
          (R.map = new Sn(r.x, r.y, Y)),
            (R.map.texture.name = O.name + ".shadowMap"),
            R.camera.updateProjectionMatrix();
        }
        t.setRenderTarget(R.map), t.clear();
        const V = R.getViewportCount();
        for (let Y = 0; Y < V; Y++) {
          const K = R.getViewport(Y);
          o.set(s.x * K.x, s.y * K.y, s.x * K.z, s.y * K.w),
            I.viewport(o),
            R.updateMatrices(O, Y),
            (i = R.getFrustum()),
            x(w, M, R.camera, O, this.type);
        }
        !R.isPointLightShadow && this.type === fo && y(R, M),
          (R.needsUpdate = !1);
      }
      (_.needsUpdate = !1), t.setRenderTarget(C, A, U);
    });
  function y(v, w) {
    const M = e.update(p);
    (h.uniforms.shadow_pass.value = v.map.texture),
      (h.uniforms.resolution.value = v.mapSize),
      (h.uniforms.radius.value = v.radius),
      t.setRenderTarget(v.mapPass),
      t.clear(),
      t.renderBufferDirect(w, null, M, h, p, null),
      (d.uniforms.shadow_pass.value = v.mapPass.texture),
      (d.uniforms.resolution.value = v.mapSize),
      (d.uniforms.radius.value = v.radius),
      t.setRenderTarget(v.map),
      t.clear(),
      t.renderBufferDirect(w, null, M, d, p, null);
  }
  function m(v, w, M) {
    const C = (v << 0) | (w << 1) | (M << 2);
    let A = a[C];
    return (
      A === void 0 &&
        ((A = new fr({ depthPacking: ax, morphTargets: v, skinning: w })),
        (a[C] = A)),
      A
    );
  }
  function g(v, w, M) {
    const C = (v << 0) | (w << 1) | (M << 2);
    let A = c[C];
    return (
      A === void 0 &&
        ((A = new dr({ morphTargets: v, skinning: w })), (c[C] = A)),
      A
    );
  }
  function b(v, w, M, C, A, U, I) {
    let B = null,
      F = m,
      O = v.customDepthMaterial;
    if (
      (C.isPointLight === !0 && ((F = g), (O = v.customDistanceMaterial)),
      O === void 0)
    ) {
      let R = !1;
      M.morphTargets === !0 &&
        (R =
          w.morphAttributes &&
          w.morphAttributes.position &&
          w.morphAttributes.position.length > 0);
      let P = !1;
      v.isSkinnedMesh === !0 &&
        (M.skinning === !0
          ? (P = !0)
          : console.warn(
              "THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
              v
            ));
      const V = v.isInstancedMesh === !0;
      B = F(R, P, V);
    } else B = O;
    if (
      t.localClippingEnabled &&
      M.clipShadows === !0 &&
      M.clippingPlanes.length !== 0
    ) {
      const R = B.uuid,
        P = M.uuid;
      let V = l[R];
      V === void 0 && ((V = {}), (l[R] = V));
      let Y = V[P];
      Y === void 0 && ((Y = B.clone()), (V[P] = Y)), (B = Y);
    }
    return (
      (B.visible = M.visible),
      (B.wireframe = M.wireframe),
      I === fo
        ? (B.side = M.shadowSide !== null ? M.shadowSide : M.side)
        : (B.side = M.shadowSide !== null ? M.shadowSide : u[M.side]),
      (B.clipShadows = M.clipShadows),
      (B.clippingPlanes = M.clippingPlanes),
      (B.clipIntersection = M.clipIntersection),
      (B.wireframeLinewidth = M.wireframeLinewidth),
      (B.linewidth = M.linewidth),
      C.isPointLight === !0 &&
        B.isMeshDistanceMaterial === !0 &&
        (B.referencePosition.setFromMatrixPosition(C.matrixWorld),
        (B.nearDistance = A),
        (B.farDistance = U)),
      B
    );
  }
  function x(v, w, M, C, A) {
    if (v.visible === !1) return;
    if (
      v.layers.test(w.layers) &&
      (v.isMesh || v.isLine || v.isPoints) &&
      (v.castShadow || (v.receiveShadow && A === fo)) &&
      (!v.frustumCulled || i.intersectsObject(v))
    ) {
      v.modelViewMatrix.multiplyMatrices(M.matrixWorldInverse, v.matrixWorld);
      const B = e.update(v),
        F = v.material;
      if (Array.isArray(F)) {
        const O = B.groups;
        for (let R = 0, P = O.length; R < P; R++) {
          const V = O[R],
            Y = F[V.materialIndex];
          if (Y && Y.visible) {
            const K = b(v, B, Y, C, M.near, M.far, A);
            t.renderBufferDirect(M, null, B, K, v, V);
          }
        }
      } else if (F.visible) {
        const O = b(v, B, F, C, M.near, M.far, A);
        t.renderBufferDirect(M, null, B, O, v, null);
      }
    }
    const I = v.children;
    for (let B = 0, F = I.length; B < F; B++) x(I[B], w, M, C, A);
  }
}
function _M(t, e, n) {
  const i = n.isWebGL2;
  function r() {
    let D = !1;
    const J = new Vt();
    let Q = null;
    const gt = new Vt(0, 0, 0, 0);
    return {
      setMask: function ($) {
        Q !== $ && !D && (t.colorMask($, $, $, $), (Q = $));
      },
      setLocked: function ($) {
        D = $;
      },
      setClear: function ($, at, Et, xt, ft) {
        ft === !0 && (($ *= xt), (at *= xt), (Et *= xt)),
          J.set($, at, Et, xt),
          gt.equals(J) === !1 && (t.clearColor($, at, Et, xt), gt.copy(J));
      },
      reset: function () {
        (D = !1), (Q = null), gt.set(-1, 0, 0, 0);
      },
    };
  }
  function s() {
    let D = !1,
      J = null,
      Q = null,
      gt = null;
    return {
      setTest: function ($) {
        $ ? it(2929) : et(2929);
      },
      setMask: function ($) {
        J !== $ && !D && (t.depthMask($), (J = $));
      },
      setFunc: function ($) {
        if (Q !== $) {
          if ($)
            switch ($) {
              case j_:
                t.depthFunc(512);
                break;
              case q_:
                t.depthFunc(519);
                break;
              case X_:
                t.depthFunc(513);
                break;
              case Uu:
                t.depthFunc(515);
                break;
              case Y_:
                t.depthFunc(514);
                break;
              case Z_:
                t.depthFunc(518);
                break;
              case J_:
                t.depthFunc(516);
                break;
              case $_:
                t.depthFunc(517);
                break;
              default:
                t.depthFunc(515);
            }
          else t.depthFunc(515);
          Q = $;
        }
      },
      setLocked: function ($) {
        D = $;
      },
      setClear: function ($) {
        gt !== $ && (t.clearDepth($), (gt = $));
      },
      reset: function () {
        (D = !1), (J = null), (Q = null), (gt = null);
      },
    };
  }
  function o() {
    let D = !1,
      J = null,
      Q = null,
      gt = null,
      $ = null,
      at = null,
      Et = null,
      xt = null,
      ft = null;
    return {
      setTest: function (dt) {
        D || (dt ? it(2960) : et(2960));
      },
      setMask: function (dt) {
        J !== dt && !D && (t.stencilMask(dt), (J = dt));
      },
      setFunc: function (dt, Qt, ie) {
        (Q !== dt || gt !== Qt || $ !== ie) &&
          (t.stencilFunc(dt, Qt, ie), (Q = dt), (gt = Qt), ($ = ie));
      },
      setOp: function (dt, Qt, ie) {
        (at !== dt || Et !== Qt || xt !== ie) &&
          (t.stencilOp(dt, Qt, ie), (at = dt), (Et = Qt), (xt = ie));
      },
      setLocked: function (dt) {
        D = dt;
      },
      setClear: function (dt) {
        ft !== dt && (t.clearStencil(dt), (ft = dt));
      },
      reset: function () {
        (D = !1),
          (J = null),
          (Q = null),
          (gt = null),
          ($ = null),
          (at = null),
          (Et = null),
          (xt = null),
          (ft = null);
      },
    };
  }
  const a = new r(),
    c = new s(),
    l = new o();
  let u = {},
    h = null,
    d = null,
    f = null,
    p = null,
    _ = null,
    y = null,
    m = null,
    g = null,
    b = null,
    x = !1,
    v = null,
    w = null,
    M = null,
    C = null,
    A = null;
  const U = t.getParameter(35661);
  let I = !1,
    B = 0;
  const F = t.getParameter(7938);
  F.indexOf("WebGL") !== -1
    ? ((B = parseFloat(/^WebGL\ ([0-9])/.exec(F)[1])), (I = B >= 1))
    : F.indexOf("OpenGL ES") !== -1 &&
      ((B = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(F)[1])), (I = B >= 2));
  let O = null,
    R = {};
  const P = new Vt(),
    V = new Vt();
  function Y(D, J, Q) {
    const gt = new Uint8Array(4),
      $ = t.createTexture();
    t.bindTexture(D, $),
      t.texParameteri(D, 10241, 9728),
      t.texParameteri(D, 10240, 9728);
    for (let at = 0; at < Q; at++)
      t.texImage2D(J + at, 0, 6408, 1, 1, 0, 6408, 5121, gt);
    return $;
  }
  const K = {};
  (K[3553] = Y(3553, 3553, 1)),
    (K[34067] = Y(34067, 34069, 6)),
    a.setClear(0, 0, 0, 1),
    c.setClear(1),
    l.setClear(0),
    it(2929),
    c.setFunc(Uu),
    kt(!1),
    vt(mp),
    it(2884),
    Ot(mo);
  function it(D) {
    u[D] !== !0 && (t.enable(D), (u[D] = !0));
  }
  function et(D) {
    u[D] !== !1 && (t.disable(D), (u[D] = !1));
  }
  function Ct(D) {
    return h !== D ? (t.useProgram(D), (h = D), !0) : !1;
  }
  const mt = { [Kr]: 32774, [I_]: 32778, [N_]: 32779 };
  if (i) (mt[bp] = 32775), (mt[wp] = 32776);
  else {
    const D = e.get("EXT_blend_minmax");
    D !== null && ((mt[bp] = D.MIN_EXT), (mt[wp] = D.MAX_EXT));
  }
  const Nt = {
    [F_]: 0,
    [B_]: 1,
    [z_]: 768,
    [Mp]: 770,
    [W_]: 776,
    [H_]: 774,
    [k_]: 772,
    [U_]: 769,
    [Sp]: 771,
    [V_]: 775,
    [G_]: 773,
  };
  function Ot(D, J, Q, gt, $, at, Et, xt) {
    if (D === mo) {
      d && (et(3042), (d = !1));
      return;
    }
    if ((d || (it(3042), (d = !0)), D !== D_)) {
      if (D !== f || xt !== x) {
        if (
          ((p !== Kr || m !== Kr) &&
            (t.blendEquation(32774), (p = Kr), (m = Kr)),
          xt)
        )
          switch (D) {
            case go:
              t.blendFuncSeparate(1, 771, 1, 771);
              break;
            case _p:
              t.blendFunc(1, 1);
              break;
            case xp:
              t.blendFuncSeparate(0, 0, 769, 771);
              break;
            case vp:
              t.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", D);
              break;
          }
        else
          switch (D) {
            case go:
              t.blendFuncSeparate(770, 771, 1, 771);
              break;
            case _p:
              t.blendFunc(770, 1);
              break;
            case xp:
              t.blendFunc(0, 769);
              break;
            case vp:
              t.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", D);
              break;
          }
        (_ = null), (y = null), (g = null), (b = null), (f = D), (x = xt);
      }
      return;
    }
    ($ = $ || J),
      (at = at || Q),
      (Et = Et || gt),
      (J !== p || $ !== m) &&
        (t.blendEquationSeparate(mt[J], mt[$]), (p = J), (m = $)),
      (Q !== _ || gt !== y || at !== g || Et !== b) &&
        (t.blendFuncSeparate(Nt[Q], Nt[gt], Nt[at], Nt[Et]),
        (_ = Q),
        (y = gt),
        (g = at),
        (b = Et)),
      (f = D),
      (x = null);
  }
  function G(D, J) {
    D.side === Ka ? et(2884) : it(2884);
    let Q = D.side === Ee;
    J && (Q = !Q),
      kt(Q),
      D.blending === go && D.transparent === !1
        ? Ot(mo)
        : Ot(
            D.blending,
            D.blendEquation,
            D.blendSrc,
            D.blendDst,
            D.blendEquationAlpha,
            D.blendSrcAlpha,
            D.blendDstAlpha,
            D.premultipliedAlpha
          ),
      c.setFunc(D.depthFunc),
      c.setTest(D.depthTest),
      c.setMask(D.depthWrite),
      a.setMask(D.colorWrite);
    const gt = D.stencilWrite;
    l.setTest(gt),
      gt &&
        (l.setMask(D.stencilWriteMask),
        l.setFunc(D.stencilFunc, D.stencilRef, D.stencilFuncMask),
        l.setOp(D.stencilFail, D.stencilZFail, D.stencilZPass)),
      yt(D.polygonOffset, D.polygonOffsetFactor, D.polygonOffsetUnits);
  }
  function kt(D) {
    v !== D && (D ? t.frontFace(2304) : t.frontFace(2305), (v = D));
  }
  function vt(D) {
    D !== C_
      ? (it(2884),
        D !== w &&
          (D === mp
            ? t.cullFace(1029)
            : D === R_
            ? t.cullFace(1028)
            : t.cullFace(1032)))
      : et(2884),
      (w = D);
  }
  function St(D) {
    D !== M && (I && t.lineWidth(D), (M = D));
  }
  function yt(D, J, Q) {
    D
      ? (it(32823),
        (C !== J || A !== Q) && (t.polygonOffset(J, Q), (C = J), (A = Q)))
      : et(32823);
  }
  function j(D) {
    D ? it(3089) : et(3089);
  }
  function q(D) {
    D === void 0 && (D = 33984 + U - 1),
      O !== D && (t.activeTexture(D), (O = D));
  }
  function X(D, J) {
    O === null && q();
    let Q = R[O];
    Q === void 0 && ((Q = { type: void 0, texture: void 0 }), (R[O] = Q)),
      (Q.type !== D || Q.texture !== J) &&
        (t.bindTexture(D, J || K[D]), (Q.type = D), (Q.texture = J));
  }
  function ht() {
    const D = R[O];
    D !== void 0 &&
      D.type !== void 0 &&
      (t.bindTexture(D.type, null), (D.type = void 0), (D.texture = void 0));
  }
  function ot() {
    try {
      t.compressedTexImage2D.apply(t, arguments);
    } catch (D) {
      console.error("THREE.WebGLState:", D);
    }
  }
  function Tt() {
    try {
      t.texImage2D.apply(t, arguments);
    } catch (D) {
      console.error("THREE.WebGLState:", D);
    }
  }
  function T() {
    try {
      t.texImage3D.apply(t, arguments);
    } catch (D) {
      console.error("THREE.WebGLState:", D);
    }
  }
  function L(D) {
    P.equals(D) === !1 && (t.scissor(D.x, D.y, D.z, D.w), P.copy(D));
  }
  function Z(D) {
    V.equals(D) === !1 && (t.viewport(D.x, D.y, D.z, D.w), V.copy(D));
  }
  function W() {
    (u = {}),
      (O = null),
      (R = {}),
      (h = null),
      (f = null),
      (v = null),
      (w = null),
      a.reset(),
      c.reset(),
      l.reset();
  }
  return {
    buffers: { color: a, depth: c, stencil: l },
    enable: it,
    disable: et,
    useProgram: Ct,
    setBlending: Ot,
    setMaterial: G,
    setFlipSided: kt,
    setCullFace: vt,
    setLineWidth: St,
    setPolygonOffset: yt,
    setScissorTest: j,
    activeTexture: q,
    bindTexture: X,
    unbindTexture: ht,
    compressedTexImage2D: ot,
    texImage2D: Tt,
    texImage3D: T,
    scissor: L,
    viewport: Z,
    reset: W,
  };
}
function xM(t, e, n, i, r, s, o) {
  const a = r.isWebGL2,
    c = r.maxTextures,
    l = r.maxCubemapSize,
    u = r.maxTextureSize,
    h = r.maxSamples,
    d = new WeakMap();
  let f,
    p = !1;
  try {
    p =
      typeof OffscreenCanvas != "undefined" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function _(T, L) {
    return p
      ? new OffscreenCanvas(T, L)
      : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  }
  function y(T, L, Z, W) {
    let D = 1;
    if (
      ((T.width > W || T.height > W) && (D = W / Math.max(T.width, T.height)),
      D < 1 || L === !0)
    )
      if (
        (typeof HTMLImageElement != "undefined" &&
          T instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement != "undefined" &&
          T instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap != "undefined" && T instanceof ImageBitmap)
      ) {
        const J = L ? Pt.floorPowerOfTwo : Math.floor,
          Q = J(D * T.width),
          gt = J(D * T.height);
        f === void 0 && (f = _(Q, gt));
        const $ = Z ? _(Q, gt) : f;
        return (
          ($.width = Q),
          ($.height = gt),
          $.getContext("2d").drawImage(T, 0, 0, Q, gt),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              T.width +
              "x" +
              T.height +
              ") to (" +
              Q +
              "x" +
              gt +
              ")."
          ),
          $
        );
      } else
        return (
          "data" in T &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                T.width +
                "x" +
                T.height +
                ")."
            ),
          T
        );
    return T;
  }
  function m(T) {
    return Pt.isPowerOfTwo(T.width) && Pt.isPowerOfTwo(T.height);
  }
  function g(T) {
    return a
      ? !1
      : T.wrapS !== Ze ||
          T.wrapT !== Ze ||
          (T.minFilter !== De && T.minFilter !== Ie);
  }
  function b(T, L) {
    return T.generateMipmaps && L && T.minFilter !== De && T.minFilter !== Ie;
  }
  function x(T, L, Z, W) {
    t.generateMipmap(T);
    const D = i.get(L);
    D.__maxMipLevel = Math.log(Math.max(Z, W)) * Math.LOG2E;
  }
  function v(T, L, Z) {
    if (a === !1) return L;
    if (T !== null) {
      if (t[T] !== void 0) return t[T];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          T +
          "'"
      );
    }
    let W = L;
    return (
      L === 6403 &&
        (Z === 5126 && (W = 33326),
        Z === 5131 && (W = 33325),
        Z === 5121 && (W = 33321)),
      L === 6407 &&
        (Z === 5126 && (W = 34837),
        Z === 5131 && (W = 34843),
        Z === 5121 && (W = 32849)),
      L === 6408 &&
        (Z === 5126 && (W = 34836),
        Z === 5131 && (W = 34842),
        Z === 5121 && (W = 32856)),
      (W === 33325 || W === 33326 || W === 34842 || W === 34836) &&
        e.get("EXT_color_buffer_float"),
      W
    );
  }
  function w(T) {
    return T === De || T === ju || T === qu ? 9728 : 9729;
  }
  function M(T) {
    const L = T.target;
    L.removeEventListener("dispose", M),
      A(L),
      L.isVideoTexture && d.delete(L),
      o.memory.textures--;
  }
  function C(T) {
    const L = T.target;
    L.removeEventListener("dispose", C), U(L), o.memory.textures--;
  }
  function A(T) {
    const L = i.get(T);
    L.__webglInit !== void 0 &&
      (t.deleteTexture(L.__webglTexture), i.remove(T));
  }
  function U(T) {
    const L = i.get(T),
      Z = i.get(T.texture);
    if (!!T) {
      if (
        (Z.__webglTexture !== void 0 && t.deleteTexture(Z.__webglTexture),
        T.depthTexture && T.depthTexture.dispose(),
        T.isWebGLCubeRenderTarget)
      )
        for (let W = 0; W < 6; W++)
          t.deleteFramebuffer(L.__webglFramebuffer[W]),
            L.__webglDepthbuffer &&
              t.deleteRenderbuffer(L.__webglDepthbuffer[W]);
      else
        t.deleteFramebuffer(L.__webglFramebuffer),
          L.__webglDepthbuffer && t.deleteRenderbuffer(L.__webglDepthbuffer),
          L.__webglMultisampledFramebuffer &&
            t.deleteFramebuffer(L.__webglMultisampledFramebuffer),
          L.__webglColorRenderbuffer &&
            t.deleteRenderbuffer(L.__webglColorRenderbuffer),
          L.__webglDepthRenderbuffer &&
            t.deleteRenderbuffer(L.__webglDepthRenderbuffer);
      i.remove(T.texture), i.remove(T);
    }
  }
  let I = 0;
  function B() {
    I = 0;
  }
  function F() {
    const T = I;
    return (
      T >= c &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            T +
            " texture units while this GPU supports only " +
            c
        ),
      (I += 1),
      T
    );
  }
  function O(T, L) {
    const Z = i.get(T);
    if (
      (T.isVideoTexture && q(T), T.version > 0 && Z.__version !== T.version)
    ) {
      const W = T.image;
      if (W === void 0)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is undefined"
        );
      else if (W.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        mt(Z, T, L);
        return;
      }
    }
    n.activeTexture(33984 + L), n.bindTexture(3553, Z.__webglTexture);
  }
  function R(T, L) {
    const Z = i.get(T);
    if (T.version > 0 && Z.__version !== T.version) {
      mt(Z, T, L);
      return;
    }
    n.activeTexture(33984 + L), n.bindTexture(35866, Z.__webglTexture);
  }
  function P(T, L) {
    const Z = i.get(T);
    if (T.version > 0 && Z.__version !== T.version) {
      mt(Z, T, L);
      return;
    }
    n.activeTexture(33984 + L), n.bindTexture(32879, Z.__webglTexture);
  }
  function V(T, L) {
    if (T.image.length !== 6) return;
    const Z = i.get(T);
    if (T.version > 0 && Z.__version !== T.version) {
      Ct(Z, T),
        n.activeTexture(33984 + L),
        n.bindTexture(34067, Z.__webglTexture),
        t.pixelStorei(37440, T.flipY);
      const W = T && (T.isCompressedTexture || T.image[0].isCompressedTexture),
        D = T.image[0] && T.image[0].isDataTexture,
        J = [];
      for (let ft = 0; ft < 6; ft++)
        !W && !D
          ? (J[ft] = y(T.image[ft], !1, !0, l))
          : (J[ft] = D ? T.image[ft].image : T.image[ft]);
      const Q = J[0],
        gt = m(Q) || a,
        $ = s.convert(T.format),
        at = s.convert(T.type),
        Et = v(T.internalFormat, $, at);
      et(34067, T, gt);
      let xt;
      if (W) {
        for (let ft = 0; ft < 6; ft++) {
          xt = J[ft].mipmaps;
          for (let dt = 0; dt < xt.length; dt++) {
            const Qt = xt[dt];
            T.format !== Gn && T.format !== ar
              ? $ !== null
                ? n.compressedTexImage2D(
                    34069 + ft,
                    dt,
                    Et,
                    Qt.width,
                    Qt.height,
                    0,
                    Qt.data
                  )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : n.texImage2D(
                  34069 + ft,
                  dt,
                  Et,
                  Qt.width,
                  Qt.height,
                  0,
                  $,
                  at,
                  Qt.data
                );
          }
        }
        Z.__maxMipLevel = xt.length - 1;
      } else {
        xt = T.mipmaps;
        for (let ft = 0; ft < 6; ft++)
          if (D) {
            n.texImage2D(
              34069 + ft,
              0,
              Et,
              J[ft].width,
              J[ft].height,
              0,
              $,
              at,
              J[ft].data
            );
            for (let dt = 0; dt < xt.length; dt++) {
              const ie = xt[dt].image[ft].image;
              n.texImage2D(
                34069 + ft,
                dt + 1,
                Et,
                ie.width,
                ie.height,
                0,
                $,
                at,
                ie.data
              );
            }
          } else {
            n.texImage2D(34069 + ft, 0, Et, $, at, J[ft]);
            for (let dt = 0; dt < xt.length; dt++) {
              const Qt = xt[dt];
              n.texImage2D(34069 + ft, dt + 1, Et, $, at, Qt.image[ft]);
            }
          }
        Z.__maxMipLevel = xt.length;
      }
      b(T, gt) && x(34067, T, Q.width, Q.height),
        (Z.__version = T.version),
        T.onUpdate && T.onUpdate(T);
    } else n.activeTexture(33984 + L), n.bindTexture(34067, Z.__webglTexture);
  }
  function Y(T, L) {
    n.activeTexture(33984 + L), n.bindTexture(34067, i.get(T).__webglTexture);
  }
  const K = { [nc]: 10497, [Ze]: 33071, [ic]: 33648 },
    it = {
      [De]: 9728,
      [ju]: 9984,
      [qu]: 9986,
      [Ie]: 9729,
      [Ep]: 9985,
      [rc]: 9987,
    };
  function et(T, L, Z) {
    Z
      ? (t.texParameteri(T, 10242, K[L.wrapS]),
        t.texParameteri(T, 10243, K[L.wrapT]),
        (T === 32879 || T === 35866) && t.texParameteri(T, 32882, K[L.wrapR]),
        t.texParameteri(T, 10240, it[L.magFilter]),
        t.texParameteri(T, 10241, it[L.minFilter]))
      : (t.texParameteri(T, 10242, 33071),
        t.texParameteri(T, 10243, 33071),
        (T === 32879 || T === 35866) && t.texParameteri(T, 32882, 33071),
        (L.wrapS !== Ze || L.wrapT !== Ze) &&
          console.warn(
            "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
          ),
        t.texParameteri(T, 10240, w(L.magFilter)),
        t.texParameteri(T, 10241, w(L.minFilter)),
        L.minFilter !== De &&
          L.minFilter !== Ie &&
          console.warn(
            "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
          ));
    const W = e.get("EXT_texture_filter_anisotropic");
    if (W) {
      if (
        (L.type === Pi && e.get("OES_texture_float_linear") === null) ||
        (L.type === ac &&
          (a || e.get("OES_texture_half_float_linear")) === null)
      )
        return;
      (L.anisotropy > 1 || i.get(L).__currentAnisotropy) &&
        (t.texParameterf(
          T,
          W.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(L.anisotropy, r.getMaxAnisotropy())
        ),
        (i.get(L).__currentAnisotropy = L.anisotropy));
    }
  }
  function Ct(T, L) {
    T.__webglInit === void 0 &&
      ((T.__webglInit = !0),
      L.addEventListener("dispose", M),
      (T.__webglTexture = t.createTexture()),
      o.memory.textures++);
  }
  function mt(T, L, Z) {
    let W = 3553;
    L.isDataTexture2DArray && (W = 35866),
      L.isDataTexture3D && (W = 32879),
      Ct(T, L),
      n.activeTexture(33984 + Z),
      n.bindTexture(W, T.__webglTexture),
      t.pixelStorei(37440, L.flipY),
      t.pixelStorei(37441, L.premultiplyAlpha),
      t.pixelStorei(3317, L.unpackAlignment);
    const D = g(L) && m(L.image) === !1,
      J = y(L.image, D, !1, u),
      Q = m(J) || a,
      gt = s.convert(L.format);
    let $ = s.convert(L.type),
      at = v(L.internalFormat, gt, $);
    et(W, L, Q);
    let Et;
    const xt = L.mipmaps;
    if (L.isDepthTexture)
      (at = 6402),
        a
          ? L.type === Pi
            ? (at = 36012)
            : L.type === oc
            ? (at = 33190)
            : L.type === _o
            ? (at = 35056)
            : (at = 33189)
          : L.type === Pi &&
            console.error(
              "WebGLRenderer: Floating point depth texture requires WebGL2."
            ),
        L.format === ts &&
          at === 6402 &&
          L.type !== sc &&
          L.type !== oc &&
          (console.warn(
            "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
          ),
          (L.type = sc),
          ($ = s.convert(L.type))),
        L.format === xo &&
          at === 6402 &&
          ((at = 34041),
          L.type !== _o &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
            ),
            (L.type = _o),
            ($ = s.convert(L.type)))),
        n.texImage2D(3553, 0, at, J.width, J.height, 0, gt, $, null);
    else if (L.isDataTexture)
      if (xt.length > 0 && Q) {
        for (let ft = 0, dt = xt.length; ft < dt; ft++)
          (Et = xt[ft]),
            n.texImage2D(3553, ft, at, Et.width, Et.height, 0, gt, $, Et.data);
        (L.generateMipmaps = !1), (T.__maxMipLevel = xt.length - 1);
      } else
        n.texImage2D(3553, 0, at, J.width, J.height, 0, gt, $, J.data),
          (T.__maxMipLevel = 0);
    else if (L.isCompressedTexture) {
      for (let ft = 0, dt = xt.length; ft < dt; ft++)
        (Et = xt[ft]),
          L.format !== Gn && L.format !== ar
            ? gt !== null
              ? n.compressedTexImage2D(
                  3553,
                  ft,
                  at,
                  Et.width,
                  Et.height,
                  0,
                  Et.data
                )
              : console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                )
            : n.texImage2D(
                3553,
                ft,
                at,
                Et.width,
                Et.height,
                0,
                gt,
                $,
                Et.data
              );
      T.__maxMipLevel = xt.length - 1;
    } else if (L.isDataTexture2DArray)
      n.texImage3D(35866, 0, at, J.width, J.height, J.depth, 0, gt, $, J.data),
        (T.__maxMipLevel = 0);
    else if (L.isDataTexture3D)
      n.texImage3D(32879, 0, at, J.width, J.height, J.depth, 0, gt, $, J.data),
        (T.__maxMipLevel = 0);
    else if (xt.length > 0 && Q) {
      for (let ft = 0, dt = xt.length; ft < dt; ft++)
        (Et = xt[ft]), n.texImage2D(3553, ft, at, gt, $, Et);
      (L.generateMipmaps = !1), (T.__maxMipLevel = xt.length - 1);
    } else n.texImage2D(3553, 0, at, gt, $, J), (T.__maxMipLevel = 0);
    b(L, Q) && x(W, L, J.width, J.height),
      (T.__version = L.version),
      L.onUpdate && L.onUpdate(L);
  }
  function Nt(T, L, Z, W) {
    const D = s.convert(L.texture.format),
      J = s.convert(L.texture.type),
      Q = v(L.texture.internalFormat, D, J);
    n.texImage2D(W, 0, Q, L.width, L.height, 0, D, J, null),
      t.bindFramebuffer(36160, T),
      t.framebufferTexture2D(36160, Z, W, i.get(L.texture).__webglTexture, 0),
      t.bindFramebuffer(36160, null);
  }
  function Ot(T, L, Z) {
    if ((t.bindRenderbuffer(36161, T), L.depthBuffer && !L.stencilBuffer)) {
      let W = 33189;
      if (Z) {
        const D = L.depthTexture;
        D &&
          D.isDepthTexture &&
          (D.type === Pi ? (W = 36012) : D.type === oc && (W = 33190));
        const J = j(L);
        t.renderbufferStorageMultisample(36161, J, W, L.width, L.height);
      } else t.renderbufferStorage(36161, W, L.width, L.height);
      t.framebufferRenderbuffer(36160, 36096, 36161, T);
    } else if (L.depthBuffer && L.stencilBuffer) {
      if (Z) {
        const W = j(L);
        t.renderbufferStorageMultisample(36161, W, 35056, L.width, L.height);
      } else t.renderbufferStorage(36161, 34041, L.width, L.height);
      t.framebufferRenderbuffer(36160, 33306, 36161, T);
    } else {
      const W = s.convert(L.texture.format),
        D = s.convert(L.texture.type),
        J = v(L.texture.internalFormat, W, D);
      if (Z) {
        const Q = j(L);
        t.renderbufferStorageMultisample(36161, Q, J, L.width, L.height);
      } else t.renderbufferStorage(36161, J, L.width, L.height);
    }
    t.bindRenderbuffer(36161, null);
  }
  function G(T, L) {
    if (L && L.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (t.bindFramebuffer(36160, T),
      !(L.depthTexture && L.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!i.get(L.depthTexture).__webglTexture ||
      L.depthTexture.image.width !== L.width ||
      L.depthTexture.image.height !== L.height) &&
      ((L.depthTexture.image.width = L.width),
      (L.depthTexture.image.height = L.height),
      (L.depthTexture.needsUpdate = !0)),
      O(L.depthTexture, 0);
    const W = i.get(L.depthTexture).__webglTexture;
    if (L.depthTexture.format === ts)
      t.framebufferTexture2D(36160, 36096, 3553, W, 0);
    else if (L.depthTexture.format === xo)
      t.framebufferTexture2D(36160, 33306, 3553, W, 0);
    else throw new Error("Unknown depthTexture format");
  }
  function kt(T) {
    const L = i.get(T),
      Z = T.isWebGLCubeRenderTarget === !0;
    if (T.depthTexture) {
      if (Z)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      G(L.__webglFramebuffer, T);
    } else if (Z) {
      L.__webglDepthbuffer = [];
      for (let W = 0; W < 6; W++)
        t.bindFramebuffer(36160, L.__webglFramebuffer[W]),
          (L.__webglDepthbuffer[W] = t.createRenderbuffer()),
          Ot(L.__webglDepthbuffer[W], T, !1);
    } else
      t.bindFramebuffer(36160, L.__webglFramebuffer),
        (L.__webglDepthbuffer = t.createRenderbuffer()),
        Ot(L.__webglDepthbuffer, T, !1);
    t.bindFramebuffer(36160, null);
  }
  function vt(T) {
    const L = i.get(T),
      Z = i.get(T.texture);
    T.addEventListener("dispose", C),
      (Z.__webglTexture = t.createTexture()),
      o.memory.textures++;
    const W = T.isWebGLCubeRenderTarget === !0,
      D = T.isWebGLMultisampleRenderTarget === !0,
      J = m(T) || a;
    if (
      (a &&
        T.texture.format === ar &&
        (T.texture.type === Pi || T.texture.type === ac) &&
        ((T.texture.format = Gn),
        console.warn(
          "THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
        )),
      W)
    ) {
      L.__webglFramebuffer = [];
      for (let Q = 0; Q < 6; Q++)
        L.__webglFramebuffer[Q] = t.createFramebuffer();
    } else if (((L.__webglFramebuffer = t.createFramebuffer()), D))
      if (a) {
        (L.__webglMultisampledFramebuffer = t.createFramebuffer()),
          (L.__webglColorRenderbuffer = t.createRenderbuffer()),
          t.bindRenderbuffer(36161, L.__webglColorRenderbuffer);
        const Q = s.convert(T.texture.format),
          gt = s.convert(T.texture.type),
          $ = v(T.texture.internalFormat, Q, gt),
          at = j(T);
        t.renderbufferStorageMultisample(36161, at, $, T.width, T.height),
          t.bindFramebuffer(36160, L.__webglMultisampledFramebuffer),
          t.framebufferRenderbuffer(
            36160,
            36064,
            36161,
            L.__webglColorRenderbuffer
          ),
          t.bindRenderbuffer(36161, null),
          T.depthBuffer &&
            ((L.__webglDepthRenderbuffer = t.createRenderbuffer()),
            Ot(L.__webglDepthRenderbuffer, T, !0)),
          t.bindFramebuffer(36160, null);
      } else
        console.warn(
          "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
        );
    if (W) {
      n.bindTexture(34067, Z.__webglTexture), et(34067, T.texture, J);
      for (let Q = 0; Q < 6; Q++)
        Nt(L.__webglFramebuffer[Q], T, 36064, 34069 + Q);
      b(T.texture, J) && x(34067, T.texture, T.width, T.height),
        n.bindTexture(34067, null);
    } else
      n.bindTexture(3553, Z.__webglTexture),
        et(3553, T.texture, J),
        Nt(L.__webglFramebuffer, T, 36064, 3553),
        b(T.texture, J) && x(3553, T.texture, T.width, T.height),
        n.bindTexture(3553, null);
    T.depthBuffer && kt(T);
  }
  function St(T) {
    const L = T.texture,
      Z = m(T) || a;
    if (b(L, Z)) {
      const W = T.isWebGLCubeRenderTarget ? 34067 : 3553,
        D = i.get(L).__webglTexture;
      n.bindTexture(W, D), x(W, L, T.width, T.height), n.bindTexture(W, null);
    }
  }
  function yt(T) {
    if (T.isWebGLMultisampleRenderTarget)
      if (a) {
        const L = i.get(T);
        t.bindFramebuffer(36008, L.__webglMultisampledFramebuffer),
          t.bindFramebuffer(36009, L.__webglFramebuffer);
        const Z = T.width,
          W = T.height;
        let D = 16384;
        T.depthBuffer && (D |= 256),
          T.stencilBuffer && (D |= 1024),
          t.blitFramebuffer(0, 0, Z, W, 0, 0, Z, W, D, 9728),
          t.bindFramebuffer(36160, L.__webglMultisampledFramebuffer);
      } else
        console.warn(
          "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
        );
  }
  function j(T) {
    return a && T.isWebGLMultisampleRenderTarget ? Math.min(h, T.samples) : 0;
  }
  function q(T) {
    const L = o.render.frame;
    d.get(T) !== L && (d.set(T, L), T.update());
  }
  let X = !1,
    ht = !1;
  function ot(T, L) {
    T &&
      T.isWebGLRenderTarget &&
      (X === !1 &&
        (console.warn(
          "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
        ),
        (X = !0)),
      (T = T.texture)),
      O(T, L);
  }
  function Tt(T, L) {
    T &&
      T.isWebGLCubeRenderTarget &&
      (ht === !1 &&
        (console.warn(
          "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
        ),
        (ht = !0)),
      (T = T.texture)),
      (T && T.isCubeTexture) || (Array.isArray(T.image) && T.image.length === 6)
        ? V(T, L)
        : Y(T, L);
  }
  (this.allocateTextureUnit = F),
    (this.resetTextureUnits = B),
    (this.setTexture2D = O),
    (this.setTexture2DArray = R),
    (this.setTexture3D = P),
    (this.setTextureCube = V),
    (this.setTextureCubeDynamic = Y),
    (this.setupRenderTarget = vt),
    (this.updateRenderTargetMipmap = St),
    (this.updateMultisampleRenderTarget = yt),
    (this.safeSetTexture2D = ot),
    (this.safeSetTextureCube = Tt);
}
function vM(t, e, n) {
  const i = n.isWebGL2;
  function r(s) {
    let o;
    if (s === Xu) return 5121;
    if (s === c0) return 32819;
    if (s === l0) return 32820;
    if (s === u0) return 33635;
    if (s === s0) return 5120;
    if (s === o0) return 5122;
    if (s === sc) return 5123;
    if (s === a0) return 5124;
    if (s === oc) return 5125;
    if (s === Pi) return 5126;
    if (s === ac)
      return i
        ? 5131
        : ((o = e.get("OES_texture_half_float")),
          o !== null ? o.HALF_FLOAT_OES : null);
    if (s === h0) return 6406;
    if (s === ar) return 6407;
    if (s === Gn) return 6408;
    if (s === f0) return 6409;
    if (s === d0) return 6410;
    if (s === ts) return 6402;
    if (s === xo) return 34041;
    if (s === p0) return 6403;
    if (s === m0) return 36244;
    if (s === g0) return 33319;
    if (s === y0) return 33320;
    if (s === _0) return 36248;
    if (s === x0) return 36249;
    if (s === Ap || s === Lp || s === Pp || s === Cp)
      if (((o = e.get("WEBGL_compressed_texture_s3tc")), o !== null)) {
        if (s === Ap) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === Lp) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === Pp) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === Cp) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (s === Rp || s === Op || s === Dp || s === Ip)
      if (((o = e.get("WEBGL_compressed_texture_pvrtc")), o !== null)) {
        if (s === Rp) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === Op) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === Dp) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === Ip) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (s === v0)
      return (
        (o = e.get("WEBGL_compressed_texture_etc1")),
        o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (
      (s === Np || s === Fp) &&
      ((o = e.get("WEBGL_compressed_texture_etc")), o !== null)
    ) {
      if (s === Np) return o.COMPRESSED_RGB8_ETC2;
      if (s === Fp) return o.COMPRESSED_RGBA8_ETC2_EAC;
    }
    if (
      s === b0 ||
      s === w0 ||
      s === M0 ||
      s === S0 ||
      s === T0 ||
      s === E0 ||
      s === A0 ||
      s === L0 ||
      s === P0 ||
      s === C0 ||
      s === R0 ||
      s === O0 ||
      s === D0 ||
      s === I0 ||
      s === F0 ||
      s === B0 ||
      s === z0 ||
      s === U0 ||
      s === k0 ||
      s === G0 ||
      s === H0 ||
      s === V0 ||
      s === W0 ||
      s === j0 ||
      s === q0 ||
      s === X0 ||
      s === Y0 ||
      s === Z0
    )
      return (
        (o = e.get("WEBGL_compressed_texture_astc")), o !== null ? s : null
      );
    if (s === N0)
      return (o = e.get("EXT_texture_compression_bptc")), o !== null ? s : null;
    if (s === _o)
      return i
        ? 34042
        : ((o = e.get("WEBGL_depth_texture")),
          o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null);
  }
  return { convert: r };
}
function Eh(t) {
  Pe.call(this), (this.cameras = t || []);
}
Eh.prototype = Object.assign(Object.create(Pe.prototype), {
  constructor: Eh,
  isArrayCamera: !0,
});
function Fo() {
  nt.call(this), (this.type = "Group");
}
Fo.prototype = Object.assign(Object.create(nt.prototype), {
  constructor: Fo,
  isGroup: !0,
});
function Rc() {
  (this._targetRay = null), (this._grip = null);
}
Object.assign(Rc.prototype, {
  constructor: Rc,
  getTargetRaySpace: function () {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Fo()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1)),
      this._targetRay
    );
  },
  getGripSpace: function () {
    return (
      this._grip === null &&
        ((this._grip = new Fo()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1)),
      this._grip
    );
  },
  dispatchEvent: function (t) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(t),
      this._grip !== null && this._grip.dispatchEvent(t),
      this
    );
  },
  disconnect: function (t) {
    return (
      this.dispatchEvent({ type: "disconnected", data: t }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this
    );
  },
  update: function (t, e, n) {
    let i = null,
      r = null;
    const s = this._targetRay,
      o = this._grip;
    return (
      t &&
        (s !== null &&
          ((i = e.getPose(t.targetRaySpace, n)),
          i !== null &&
            (s.matrix.fromArray(i.transform.matrix),
            s.matrix.decompose(s.position, s.rotation, s.scale))),
        o !== null &&
          t.gripSpace &&
          ((r = e.getPose(t.gripSpace, n)),
          r !== null &&
            (o.matrix.fromArray(r.transform.matrix),
            o.matrix.decompose(o.position, o.rotation, o.scale)))),
      s !== null && (s.visible = i !== null),
      o !== null && (o.visible = r !== null),
      this
    );
  },
});
function wm(t, e) {
  const n = this;
  let i = null,
    r = 1,
    s = null,
    o = "local-floor",
    a = null;
  const c = [],
    l = new Map(),
    u = new Pe();
  u.layers.enable(1), (u.viewport = new Vt());
  const h = new Pe();
  h.layers.enable(2), (h.viewport = new Vt());
  const d = [u, h],
    f = new Eh();
  f.layers.enable(1), f.layers.enable(2);
  let p = null,
    _ = null;
  (this.enabled = !1),
    (this.isPresenting = !1),
    (this.getController = function (I) {
      let B = c[I];
      return (
        B === void 0 && ((B = new Rc()), (c[I] = B)), B.getTargetRaySpace()
      );
    }),
    (this.getControllerGrip = function (I) {
      let B = c[I];
      return B === void 0 && ((B = new Rc()), (c[I] = B)), B.getGripSpace();
    });
  function y(I) {
    const B = l.get(I.inputSource);
    B && B.dispatchEvent({ type: I.type });
  }
  function m() {
    l.forEach(function (I, B) {
      I.disconnect(B);
    }),
      l.clear(),
      t.setFramebuffer(null),
      t.setRenderTarget(t.getRenderTarget()),
      U.stop(),
      (n.isPresenting = !1),
      n.dispatchEvent({ type: "sessionend" });
  }
  function g(I) {
    (s = I),
      U.setContext(i),
      U.start(),
      (n.isPresenting = !0),
      n.dispatchEvent({ type: "sessionstart" });
  }
  (this.setFramebufferScaleFactor = function (I) {
    (r = I),
      n.isPresenting === !0 &&
        console.warn(
          "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
        );
  }),
    (this.setReferenceSpaceType = function (I) {
      (o = I),
        n.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change reference space type while presenting."
          );
    }),
    (this.getReferenceSpace = function () {
      return s;
    }),
    (this.getSession = function () {
      return i;
    }),
    (this.setSession = function (I) {
      if (((i = I), i !== null)) {
        i.addEventListener("select", y),
          i.addEventListener("selectstart", y),
          i.addEventListener("selectend", y),
          i.addEventListener("squeeze", y),
          i.addEventListener("squeezestart", y),
          i.addEventListener("squeezeend", y),
          i.addEventListener("end", m);
        const B = e.getContextAttributes();
        B.xrCompatible !== !0 && e.makeXRCompatible();
        const F = {
            antialias: B.antialias,
            alpha: B.alpha,
            depth: B.depth,
            stencil: B.stencil,
            framebufferScaleFactor: r,
          },
          O = new XRWebGLLayer(i, e, F);
        i.updateRenderState({ baseLayer: O }),
          i.requestReferenceSpace(o).then(g),
          i.addEventListener("inputsourceschange", b);
      }
    });
  function b(I) {
    const B = i.inputSources;
    for (let F = 0; F < c.length; F++) l.set(B[F], c[F]);
    for (let F = 0; F < I.removed.length; F++) {
      const O = I.removed[F],
        R = l.get(O);
      R && (R.dispatchEvent({ type: "disconnected", data: O }), l.delete(O));
    }
    for (let F = 0; F < I.added.length; F++) {
      const O = I.added[F],
        R = l.get(O);
      R && R.dispatchEvent({ type: "connected", data: O });
    }
  }
  const x = new S(),
    v = new S();
  function w(I, B, F) {
    x.setFromMatrixPosition(B.matrixWorld),
      v.setFromMatrixPosition(F.matrixWorld);
    const O = x.distanceTo(v),
      R = B.projectionMatrix.elements,
      P = F.projectionMatrix.elements,
      V = R[14] / (R[10] - 1),
      Y = R[14] / (R[10] + 1),
      K = (R[9] + 1) / R[5],
      it = (R[9] - 1) / R[5],
      et = (R[8] - 1) / R[0],
      Ct = (P[8] + 1) / P[0],
      mt = V * et,
      Nt = V * Ct,
      Ot = O / (-et + Ct),
      G = Ot * -et;
    B.matrixWorld.decompose(I.position, I.quaternion, I.scale),
      I.translateX(G),
      I.translateZ(Ot),
      I.matrixWorld.compose(I.position, I.quaternion, I.scale),
      I.matrixWorldInverse.getInverse(I.matrixWorld);
    const kt = V + Ot,
      vt = Y + Ot,
      St = mt - G,
      yt = Nt + (O - G),
      j = ((K * Y) / vt) * kt,
      q = ((it * Y) / vt) * kt;
    I.projectionMatrix.makePerspective(St, yt, j, q, kt, vt);
  }
  function M(I, B) {
    B === null
      ? I.matrixWorld.copy(I.matrix)
      : I.matrixWorld.multiplyMatrices(B.matrixWorld, I.matrix),
      I.matrixWorldInverse.getInverse(I.matrixWorld);
  }
  this.getCamera = function (I) {
    (f.near = h.near = u.near = I.near),
      (f.far = h.far = u.far = I.far),
      (p !== f.near || _ !== f.far) &&
        (i.updateRenderState({ depthNear: f.near, depthFar: f.far }),
        (p = f.near),
        (_ = f.far));
    const B = I.parent,
      F = f.cameras;
    M(f, B);
    for (let R = 0; R < F.length; R++) M(F[R], B);
    I.matrixWorld.copy(f.matrixWorld);
    const O = I.children;
    for (let R = 0, P = O.length; R < P; R++) O[R].updateMatrixWorld(!0);
    return (
      F.length === 2 ? w(f, u, h) : f.projectionMatrix.copy(u.projectionMatrix),
      f
    );
  };
  let C = null;
  function A(I, B) {
    if (((a = B.getViewerPose(s)), a !== null)) {
      const O = a.views,
        R = i.renderState.baseLayer;
      t.setFramebuffer(R.framebuffer);
      let P = !1;
      O.length !== f.cameras.length && ((f.cameras.length = 0), (P = !0));
      for (let V = 0; V < O.length; V++) {
        const Y = O[V],
          K = R.getViewport(Y),
          it = d[V];
        it.matrix.fromArray(Y.transform.matrix),
          it.projectionMatrix.fromArray(Y.projectionMatrix),
          it.viewport.set(K.x, K.y, K.width, K.height),
          V === 0 && f.matrix.copy(it.matrix),
          P === !0 && f.cameras.push(it);
      }
    }
    const F = i.inputSources;
    for (let O = 0; O < c.length; O++) {
      const R = c[O],
        P = F[O];
      R.update(P, B, s);
    }
    C && C(I, B);
  }
  const U = new Kp();
  U.setAnimationLoop(A),
    (this.setAnimationLoop = function (I) {
      C = I;
    }),
    (this.dispose = function () {});
}
Object.assign(wm.prototype, si.prototype);
function bM(t) {
  function e(m, g) {
    m.fogColor.value.copy(g.color),
      g.isFog
        ? ((m.fogNear.value = g.near), (m.fogFar.value = g.far))
        : g.isFogExp2 && (m.fogDensity.value = g.density);
  }
  function n(m, g, b, x, v) {
    g.isMeshBasicMaterial
      ? i(m, g)
      : g.isMeshLambertMaterial
      ? (i(m, g), c(m, g))
      : g.isMeshToonMaterial
      ? (i(m, g), u(m, g))
      : g.isMeshPhongMaterial
      ? (i(m, g), l(m, g))
      : g.isMeshStandardMaterial
      ? (i(m, g, b), g.isMeshPhysicalMaterial ? d(m, g, b) : h(m, g, b))
      : g.isMeshMatcapMaterial
      ? (i(m, g), f(m, g))
      : g.isMeshDepthMaterial
      ? (i(m, g), p(m, g))
      : g.isMeshDistanceMaterial
      ? (i(m, g), _(m, g))
      : g.isMeshNormalMaterial
      ? (i(m, g), y(m, g))
      : g.isLineBasicMaterial
      ? (r(m, g), g.isLineDashedMaterial && s(m, g))
      : g.isPointsMaterial
      ? o(m, g, x, v)
      : g.isSpriteMaterial
      ? a(m, g)
      : g.isShadowMaterial
      ? (m.color.value.copy(g.color), (m.opacity.value = g.opacity))
      : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
  }
  function i(m, g, b) {
    (m.opacity.value = g.opacity),
      g.color && m.diffuse.value.copy(g.color),
      g.emissive &&
        m.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity),
      g.map && (m.map.value = g.map),
      g.alphaMap && (m.alphaMap.value = g.alphaMap),
      g.specularMap && (m.specularMap.value = g.specularMap);
    const x = g.envMap || b;
    x &&
      ((m.envMap.value = x),
      (m.flipEnvMap.value = x.isCubeTexture ? -1 : 1),
      (m.reflectivity.value = g.reflectivity),
      (m.refractionRatio.value = g.refractionRatio),
      (m.maxMipLevel.value = t.get(x).__maxMipLevel)),
      g.lightMap &&
        ((m.lightMap.value = g.lightMap),
        (m.lightMapIntensity.value = g.lightMapIntensity)),
      g.aoMap &&
        ((m.aoMap.value = g.aoMap),
        (m.aoMapIntensity.value = g.aoMapIntensity));
    let v;
    g.map
      ? (v = g.map)
      : g.specularMap
      ? (v = g.specularMap)
      : g.displacementMap
      ? (v = g.displacementMap)
      : g.normalMap
      ? (v = g.normalMap)
      : g.bumpMap
      ? (v = g.bumpMap)
      : g.roughnessMap
      ? (v = g.roughnessMap)
      : g.metalnessMap
      ? (v = g.metalnessMap)
      : g.alphaMap
      ? (v = g.alphaMap)
      : g.emissiveMap && (v = g.emissiveMap),
      v !== void 0 &&
        (v.isWebGLRenderTarget && (v = v.texture),
        v.matrixAutoUpdate === !0 && v.updateMatrix(),
        m.uvTransform.value.copy(v.matrix));
    let w;
    g.aoMap ? (w = g.aoMap) : g.lightMap && (w = g.lightMap),
      w !== void 0 &&
        (w.isWebGLRenderTarget && (w = w.texture),
        w.matrixAutoUpdate === !0 && w.updateMatrix(),
        m.uv2Transform.value.copy(w.matrix));
  }
  function r(m, g) {
    m.diffuse.value.copy(g.color), (m.opacity.value = g.opacity);
  }
  function s(m, g) {
    (m.dashSize.value = g.dashSize),
      (m.totalSize.value = g.dashSize + g.gapSize),
      (m.scale.value = g.scale);
  }
  function o(m, g, b, x) {
    m.diffuse.value.copy(g.color),
      (m.opacity.value = g.opacity),
      (m.size.value = g.size * b),
      (m.scale.value = x * 0.5),
      g.map && (m.map.value = g.map),
      g.alphaMap && (m.alphaMap.value = g.alphaMap);
    let v;
    g.map ? (v = g.map) : g.alphaMap && (v = g.alphaMap),
      v !== void 0 &&
        (v.matrixAutoUpdate === !0 && v.updateMatrix(),
        m.uvTransform.value.copy(v.matrix));
  }
  function a(m, g) {
    m.diffuse.value.copy(g.color),
      (m.opacity.value = g.opacity),
      (m.rotation.value = g.rotation),
      g.map && (m.map.value = g.map),
      g.alphaMap && (m.alphaMap.value = g.alphaMap);
    let b;
    g.map ? (b = g.map) : g.alphaMap && (b = g.alphaMap),
      b !== void 0 &&
        (b.matrixAutoUpdate === !0 && b.updateMatrix(),
        m.uvTransform.value.copy(b.matrix));
  }
  function c(m, g) {
    g.emissiveMap && (m.emissiveMap.value = g.emissiveMap);
  }
  function l(m, g) {
    m.specular.value.copy(g.specular),
      (m.shininess.value = Math.max(g.shininess, 1e-4)),
      g.emissiveMap && (m.emissiveMap.value = g.emissiveMap),
      g.bumpMap &&
        ((m.bumpMap.value = g.bumpMap),
        (m.bumpScale.value = g.bumpScale),
        g.side === Ee && (m.bumpScale.value *= -1)),
      g.normalMap &&
        ((m.normalMap.value = g.normalMap),
        m.normalScale.value.copy(g.normalScale),
        g.side === Ee && m.normalScale.value.negate()),
      g.displacementMap &&
        ((m.displacementMap.value = g.displacementMap),
        (m.displacementScale.value = g.displacementScale),
        (m.displacementBias.value = g.displacementBias));
  }
  function u(m, g) {
    g.gradientMap && (m.gradientMap.value = g.gradientMap),
      g.emissiveMap && (m.emissiveMap.value = g.emissiveMap),
      g.bumpMap &&
        ((m.bumpMap.value = g.bumpMap),
        (m.bumpScale.value = g.bumpScale),
        g.side === Ee && (m.bumpScale.value *= -1)),
      g.normalMap &&
        ((m.normalMap.value = g.normalMap),
        m.normalScale.value.copy(g.normalScale),
        g.side === Ee && m.normalScale.value.negate()),
      g.displacementMap &&
        ((m.displacementMap.value = g.displacementMap),
        (m.displacementScale.value = g.displacementScale),
        (m.displacementBias.value = g.displacementBias));
  }
  function h(m, g, b) {
    (m.roughness.value = g.roughness),
      (m.metalness.value = g.metalness),
      g.roughnessMap && (m.roughnessMap.value = g.roughnessMap),
      g.metalnessMap && (m.metalnessMap.value = g.metalnessMap),
      g.emissiveMap && (m.emissiveMap.value = g.emissiveMap),
      g.bumpMap &&
        ((m.bumpMap.value = g.bumpMap),
        (m.bumpScale.value = g.bumpScale),
        g.side === Ee && (m.bumpScale.value *= -1)),
      g.normalMap &&
        ((m.normalMap.value = g.normalMap),
        m.normalScale.value.copy(g.normalScale),
        g.side === Ee && m.normalScale.value.negate()),
      g.displacementMap &&
        ((m.displacementMap.value = g.displacementMap),
        (m.displacementScale.value = g.displacementScale),
        (m.displacementBias.value = g.displacementBias)),
      (g.envMap || b) && (m.envMapIntensity.value = g.envMapIntensity);
  }
  function d(m, g, b) {
    h(m, g, b),
      (m.reflectivity.value = g.reflectivity),
      (m.clearcoat.value = g.clearcoat),
      (m.clearcoatRoughness.value = g.clearcoatRoughness),
      g.sheen && m.sheen.value.copy(g.sheen),
      g.clearcoatMap && (m.clearcoatMap.value = g.clearcoatMap),
      g.clearcoatRoughnessMap &&
        (m.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap),
      g.clearcoatNormalMap &&
        (m.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),
        (m.clearcoatNormalMap.value = g.clearcoatNormalMap),
        g.side === Ee && m.clearcoatNormalScale.value.negate()),
      (m.transparency.value = g.transparency);
  }
  function f(m, g) {
    g.matcap && (m.matcap.value = g.matcap),
      g.bumpMap &&
        ((m.bumpMap.value = g.bumpMap),
        (m.bumpScale.value = g.bumpScale),
        g.side === Ee && (m.bumpScale.value *= -1)),
      g.normalMap &&
        ((m.normalMap.value = g.normalMap),
        m.normalScale.value.copy(g.normalScale),
        g.side === Ee && m.normalScale.value.negate()),
      g.displacementMap &&
        ((m.displacementMap.value = g.displacementMap),
        (m.displacementScale.value = g.displacementScale),
        (m.displacementBias.value = g.displacementBias));
  }
  function p(m, g) {
    g.displacementMap &&
      ((m.displacementMap.value = g.displacementMap),
      (m.displacementScale.value = g.displacementScale),
      (m.displacementBias.value = g.displacementBias));
  }
  function _(m, g) {
    g.displacementMap &&
      ((m.displacementMap.value = g.displacementMap),
      (m.displacementScale.value = g.displacementScale),
      (m.displacementBias.value = g.displacementBias)),
      m.referencePosition.value.copy(g.referencePosition),
      (m.nearDistance.value = g.nearDistance),
      (m.farDistance.value = g.farDistance);
  }
  function y(m, g) {
    g.bumpMap &&
      ((m.bumpMap.value = g.bumpMap),
      (m.bumpScale.value = g.bumpScale),
      g.side === Ee && (m.bumpScale.value *= -1)),
      g.normalMap &&
        ((m.normalMap.value = g.normalMap),
        m.normalScale.value.copy(g.normalScale),
        g.side === Ee && m.normalScale.value.negate()),
      g.displacementMap &&
        ((m.displacementMap.value = g.displacementMap),
        (m.displacementScale.value = g.displacementScale),
        (m.displacementBias.value = g.displacementBias));
  }
  return { refreshFogUniforms: e, refreshMaterialUniforms: n };
}
function Oc(t) {
  t = t || {};
  const e =
      t.canvas !== void 0
        ? t.canvas
        : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
    n = t.context !== void 0 ? t.context : null,
    i = t.alpha !== void 0 ? t.alpha : !1,
    r = t.depth !== void 0 ? t.depth : !0,
    s = t.stencil !== void 0 ? t.stencil : !0,
    o = t.antialias !== void 0 ? t.antialias : !1,
    a = t.premultipliedAlpha !== void 0 ? t.premultipliedAlpha : !0,
    c = t.preserveDrawingBuffer !== void 0 ? t.preserveDrawingBuffer : !1,
    l = t.powerPreference !== void 0 ? t.powerPreference : "default",
    u =
      t.failIfMajorPerformanceCaveat !== void 0
        ? t.failIfMajorPerformanceCaveat
        : !1;
  let h = null,
    d = null;
  (this.domElement = e),
    (this.debug = { checkShaderErrors: !0 }),
    (this.autoClear = !0),
    (this.autoClearColor = !0),
    (this.autoClearDepth = !0),
    (this.autoClearStencil = !0),
    (this.sortObjects = !0),
    (this.clippingPlanes = []),
    (this.localClippingEnabled = !1),
    (this.gammaFactor = 2),
    (this.outputEncoding = vo),
    (this.physicallyCorrectLights = !1),
    (this.toneMapping = yo),
    (this.toneMappingExposure = 1),
    (this.maxMorphTargets = 8),
    (this.maxMorphNormals = 4);
  const f = this;
  let p = !1,
    _ = null,
    y = 0,
    m = 0,
    g = null,
    b = null,
    x = -1,
    v = null,
    w = null;
  const M = new Vt(),
    C = new Vt();
  let A = null,
    U = e.width,
    I = e.height,
    B = 1,
    F = null,
    O = null;
  const R = new Vt(0, 0, U, I),
    P = new Vt(0, 0, U, I);
  let V = !1;
  const Y = new Ro(),
    K = new Qb();
  let it = !1,
    et = !1;
  const Ct = new Rt(),
    mt = new S(),
    Nt = {
      background: null,
      fog: null,
      environment: null,
      overrideMaterial: null,
      isScene: !0,
    };
  function Ot() {
    return g === null ? B : 1;
  }
  let G = n;
  function kt(E, z) {
    for (let N = 0; N < E.length; N++) {
      const k = E[N],
        tt = e.getContext(k, z);
      if (tt !== null) return tt;
    }
    return null;
  }
  try {
    const E = {
      alpha: i,
      depth: r,
      stencil: s,
      antialias: o,
      premultipliedAlpha: a,
      preserveDrawingBuffer: c,
      powerPreference: l,
      failIfMajorPerformanceCaveat: u,
    };
    if (
      (e.addEventListener("webglcontextlost", dt, !1),
      e.addEventListener("webglcontextrestored", Qt, !1),
      G === null)
    ) {
      const z = ["webgl2", "webgl", "experimental-webgl"];
      if ((f.isWebGL1Renderer === !0 && z.shift(), (G = kt(z, E)), G === null))
        throw kt(z)
          ? new Error(
              "Error creating WebGL context with your selected attributes."
            )
          : new Error("Error creating WebGL context.");
    }
    G.getShaderPrecisionFormat === void 0 &&
      (G.getShaderPrecisionFormat = function () {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
  } catch (E) {
    throw (console.error("THREE.WebGLRenderer: " + E.message), E);
  }
  let vt, St, yt, j, q, X, ht, ot, Tt, T, L, Z, W, D, J, Q, gt, $, at;
  function Et() {
    (vt = new Kb(G)),
      (St = new $b(G, vt, t)),
      St.isWebGL2 === !1 &&
        (vt.get("WEBGL_depth_texture"),
        vt.get("OES_texture_float"),
        vt.get("OES_texture_half_float"),
        vt.get("OES_texture_half_float_linear"),
        vt.get("OES_standard_derivatives"),
        vt.get("OES_element_index_uint"),
        vt.get("OES_vertex_array_object"),
        vt.get("ANGLE_instanced_arrays")),
      vt.get("OES_texture_float_linear"),
      ($ = new vM(G, vt, St)),
      (yt = new _M(G, vt, St)),
      yt.scissor(C.copy(P).multiplyScalar(B).floor()),
      yt.viewport(M.copy(R).multiplyScalar(B).floor()),
      (j = new nw(G)),
      (q = new oM()),
      (X = new xM(G, vt, yt, q, St, $, j)),
      (ht = new Lx(G, St)),
      (at = new Zb(G, vt, ht, St)),
      (ot = new tw(G, ht, j, at)),
      (Tt = new ow(G, ot, ht, j)),
      (J = new sw(G)),
      (T = new sM(f, vt, St, at)),
      (L = new bM(q)),
      (Z = new lM()),
      (W = new mM()),
      (D = new Yb(f, yt, Tt, a)),
      (Q = new Jb(G, vt, j, St)),
      (gt = new ew(G, vt, j, St)),
      (j.programs = T.programs),
      (f.capabilities = St),
      (f.extensions = vt),
      (f.properties = q),
      (f.renderLists = Z),
      (f.state = yt),
      (f.info = j);
  }
  Et();
  const xt = new wm(f, G);
  this.xr = xt;
  const ft = new bm(f, Tt, St.maxTextureSize);
  (this.shadowMap = ft),
    (this.getContext = function () {
      return G;
    }),
    (this.getContextAttributes = function () {
      return G.getContextAttributes();
    }),
    (this.forceContextLoss = function () {
      const E = vt.get("WEBGL_lose_context");
      E && E.loseContext();
    }),
    (this.forceContextRestore = function () {
      const E = vt.get("WEBGL_lose_context");
      E && E.restoreContext();
    }),
    (this.getPixelRatio = function () {
      return B;
    }),
    (this.setPixelRatio = function (E) {
      E !== void 0 && ((B = E), this.setSize(U, I, !1));
    }),
    (this.getSize = function (E) {
      return (
        E === void 0 &&
          (console.warn(
            "WebGLRenderer: .getsize() now requires a Vector2 as an argument"
          ),
          (E = new H())),
        E.set(U, I)
      );
    }),
    (this.setSize = function (E, z, N) {
      if (xt.isPresenting) {
        console.warn(
          "THREE.WebGLRenderer: Can't change size while VR device is presenting."
        );
        return;
      }
      (U = E),
        (I = z),
        (e.width = Math.floor(E * B)),
        (e.height = Math.floor(z * B)),
        N !== !1 && ((e.style.width = E + "px"), (e.style.height = z + "px")),
        this.setViewport(0, 0, E, z);
    }),
    (this.getDrawingBufferSize = function (E) {
      return (
        E === void 0 &&
          (console.warn(
            "WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"
          ),
          (E = new H())),
        E.set(U * B, I * B).floor()
      );
    }),
    (this.setDrawingBufferSize = function (E, z, N) {
      (U = E),
        (I = z),
        (B = N),
        (e.width = Math.floor(E * N)),
        (e.height = Math.floor(z * N)),
        this.setViewport(0, 0, E, z);
    }),
    (this.getCurrentViewport = function (E) {
      return (
        E === void 0 &&
          (console.warn(
            "WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"
          ),
          (E = new Vt())),
        E.copy(M)
      );
    }),
    (this.getViewport = function (E) {
      return E.copy(R);
    }),
    (this.setViewport = function (E, z, N, k) {
      E.isVector4 ? R.set(E.x, E.y, E.z, E.w) : R.set(E, z, N, k),
        yt.viewport(M.copy(R).multiplyScalar(B).floor());
    }),
    (this.getScissor = function (E) {
      return E.copy(P);
    }),
    (this.setScissor = function (E, z, N, k) {
      E.isVector4 ? P.set(E.x, E.y, E.z, E.w) : P.set(E, z, N, k),
        yt.scissor(C.copy(P).multiplyScalar(B).floor());
    }),
    (this.getScissorTest = function () {
      return V;
    }),
    (this.setScissorTest = function (E) {
      yt.setScissorTest((V = E));
    }),
    (this.setOpaqueSort = function (E) {
      F = E;
    }),
    (this.setTransparentSort = function (E) {
      O = E;
    }),
    (this.getClearColor = function () {
      return D.getClearColor();
    }),
    (this.setClearColor = function () {
      D.setClearColor.apply(D, arguments);
    }),
    (this.getClearAlpha = function () {
      return D.getClearAlpha();
    }),
    (this.setClearAlpha = function () {
      D.setClearAlpha.apply(D, arguments);
    }),
    (this.clear = function (E, z, N) {
      let k = 0;
      (E === void 0 || E) && (k |= 16384),
        (z === void 0 || z) && (k |= 256),
        (N === void 0 || N) && (k |= 1024),
        G.clear(k);
    }),
    (this.clearColor = function () {
      this.clear(!0, !1, !1);
    }),
    (this.clearDepth = function () {
      this.clear(!1, !0, !1);
    }),
    (this.clearStencil = function () {
      this.clear(!1, !1, !0);
    }),
    (this.dispose = function () {
      e.removeEventListener("webglcontextlost", dt, !1),
        e.removeEventListener("webglcontextrestored", Qt, !1),
        Z.dispose(),
        W.dispose(),
        q.dispose(),
        Tt.dispose(),
        at.dispose(),
        xt.dispose(),
        jt.stop();
    });
  function dt(E) {
    E.preventDefault(),
      console.log("THREE.WebGLRenderer: Context Lost."),
      (p = !0);
  }
  function Qt() {
    console.log("THREE.WebGLRenderer: Context Restored."), (p = !1), Et();
  }
  function ie(E) {
    const z = E.target;
    z.removeEventListener("dispose", ie), ji(z);
  }
  function ji(E) {
    qi(E), q.remove(E);
  }
  function qi(E) {
    const z = q.get(E).program;
    (E.program = void 0), z !== void 0 && T.releaseProgram(z);
  }
  function Xi(E, z) {
    E.render(function (N) {
      f.renderBufferImmediate(N, z);
    });
  }
  (this.renderBufferImmediate = function (E, z) {
    at.initAttributes();
    const N = q.get(E);
    E.hasPositions && !N.position && (N.position = G.createBuffer()),
      E.hasNormals && !N.normal && (N.normal = G.createBuffer()),
      E.hasUvs && !N.uv && (N.uv = G.createBuffer()),
      E.hasColors && !N.color && (N.color = G.createBuffer());
    const k = z.getAttributes();
    E.hasPositions &&
      (G.bindBuffer(34962, N.position),
      G.bufferData(34962, E.positionArray, 35048),
      at.enableAttribute(k.position),
      G.vertexAttribPointer(k.position, 3, 5126, !1, 0, 0)),
      E.hasNormals &&
        (G.bindBuffer(34962, N.normal),
        G.bufferData(34962, E.normalArray, 35048),
        at.enableAttribute(k.normal),
        G.vertexAttribPointer(k.normal, 3, 5126, !1, 0, 0)),
      E.hasUvs &&
        (G.bindBuffer(34962, N.uv),
        G.bufferData(34962, E.uvArray, 35048),
        at.enableAttribute(k.uv),
        G.vertexAttribPointer(k.uv, 2, 5126, !1, 0, 0)),
      E.hasColors &&
        (G.bindBuffer(34962, N.color),
        G.bufferData(34962, E.colorArray, 35048),
        at.enableAttribute(k.color),
        G.vertexAttribPointer(k.color, 3, 5126, !1, 0, 0)),
      at.disableUnusedAttributes(),
      G.drawArrays(4, 0, E.count),
      (E.count = 0);
  }),
    (this.renderBufferDirect = function (E, z, N, k, tt, At) {
      z === null && (z = Nt);
      const pt = tt.isMesh && tt.matrixWorld.determinant() < 0,
        ut = Xt(E, z, k, tt);
      yt.setMaterial(k, pt);
      let Gt = N.index;
      const Yt = N.attributes.position;
      if (Gt === null) {
        if (Yt === void 0 || Yt.count === 0) return;
      } else if (Gt.count === 0) return;
      let ne = 1;
      k.wireframe === !0 && ((Gt = ot.getWireframeAttribute(N)), (ne = 2)),
        (k.morphTargets || k.morphNormals) && J.update(tt, N, k, ut),
        at.setup(tt, k, ut, N, Gt);
      let de,
        Lt = Q;
      Gt !== null && ((de = ht.get(Gt)), (Lt = gt), Lt.setIndex(de));
      const ae = Gt !== null ? Gt.count : Yt.count,
        Me = N.drawRange.start * ne,
        Kt = N.drawRange.count * ne,
        pa = At !== null ? At.start * ne : 0,
        vn = At !== null ? At.count * ne : 1 / 0,
        xi = Math.max(Me, pa),
        Ol = Math.min(ae, Me + Kt, pa + vn) - 1,
        ma = Math.max(0, Ol - xi + 1);
      if (ma !== 0) {
        if (tt.isMesh)
          k.wireframe === !0
            ? (yt.setLineWidth(k.wireframeLinewidth * Ot()), Lt.setMode(1))
            : Lt.setMode(4);
        else if (tt.isLine) {
          let Xs = k.linewidth;
          Xs === void 0 && (Xs = 1),
            yt.setLineWidth(Xs * Ot()),
            tt.isLineSegments
              ? Lt.setMode(1)
              : tt.isLineLoop
              ? Lt.setMode(2)
              : Lt.setMode(3);
        } else tt.isPoints ? Lt.setMode(0) : tt.isSprite && Lt.setMode(4);
        if (tt.isInstancedMesh) Lt.renderInstances(N, xi, ma, tt.count);
        else if (N.isInstancedBufferGeometry) {
          const Xs = Math.min(N.instanceCount, N._maxInstanceCount);
          Lt.renderInstances(N, xi, ma, Xs);
        } else Lt.render(xi, ma);
      }
    }),
    (this.compile = function (E, z) {
      (d = W.get(E, z)),
        d.init(),
        E.traverse(function (k) {
          k.isLight && (d.pushLight(k), k.castShadow && d.pushShadow(k));
        }),
        d.setupLights(z);
      const N = new WeakMap();
      E.traverse(function (k) {
        let tt = k.material;
        if (tt)
          if (Array.isArray(tt))
            for (let At = 0; At < tt.length; At++) {
              let pt = tt[At];
              N.has(pt) === !1 && (Ut(pt, E, k), N.set(pt));
            }
          else N.has(tt) === !1 && (Ut(tt, E, k), N.set(tt));
      });
    });
  let Yi = null;
  function oe(E) {
    xt.isPresenting || (Yi && Yi(E));
  }
  const jt = new Kp();
  jt.setAnimationLoop(oe),
    typeof window != "undefined" && jt.setContext(window),
    (this.setAnimationLoop = function (E) {
      (Yi = E), xt.setAnimationLoop(E), E === null ? jt.stop() : jt.start();
    }),
    (this.render = function (E, z) {
      let N, k;
      if (
        (arguments[2] !== void 0 &&
          (console.warn(
            "THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."
          ),
          (N = arguments[2])),
        arguments[3] !== void 0 &&
          (console.warn(
            "THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."
          ),
          (k = arguments[3])),
        z !== void 0 && z.isCamera !== !0)
      ) {
        console.error(
          "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
        );
        return;
      }
      if (p === !0) return;
      at.resetDefaultState(),
        (x = -1),
        (v = null),
        E.autoUpdate === !0 && E.updateMatrixWorld(),
        z.parent === null && z.updateMatrixWorld(),
        xt.enabled === !0 && xt.isPresenting === !0 && (z = xt.getCamera(z)),
        E.isScene === !0 && E.onBeforeRender(f, E, z, N || g),
        (d = W.get(E, z)),
        d.init(),
        Ct.multiplyMatrices(z.projectionMatrix, z.matrixWorldInverse),
        Y.setFromProjectionMatrix(Ct),
        (et = this.localClippingEnabled),
        (it = K.init(this.clippingPlanes, et, z)),
        (h = Z.get(E, z)),
        h.init(),
        qt(E, z, 0, f.sortObjects),
        h.finish(),
        f.sortObjects === !0 && h.sort(F, O),
        it === !0 && K.beginShadows();
      const tt = d.state.shadowsArray;
      ft.render(tt, E, z),
        d.setupLights(z),
        it === !0 && K.endShadows(),
        this.info.autoReset === !0 && this.info.reset(),
        N !== void 0 && this.setRenderTarget(N),
        D.render(h, E, z, k);
      const At = h.opaque,
        pt = h.transparent;
      At.length > 0 && be(At, E, z),
        pt.length > 0 && be(pt, E, z),
        E.isScene === !0 && E.onAfterRender(f, E, z),
        g !== null &&
          (X.updateRenderTargetMipmap(g), X.updateMultisampleRenderTarget(g)),
        yt.buffers.depth.setTest(!0),
        yt.buffers.depth.setMask(!0),
        yt.buffers.color.setMask(!0),
        yt.setPolygonOffset(!1),
        (h = null),
        (d = null);
    });
  function qt(E, z, N, k) {
    if (E.visible === !1) return;
    if (E.layers.test(z.layers)) {
      if (E.isGroup) N = E.renderOrder;
      else if (E.isLOD) E.autoUpdate === !0 && E.update(z);
      else if (E.isLight) d.pushLight(E), E.castShadow && d.pushShadow(E);
      else if (E.isSprite) {
        if (!E.frustumCulled || Y.intersectsSprite(E)) {
          k && mt.setFromMatrixPosition(E.matrixWorld).applyMatrix4(Ct);
          const pt = Tt.update(E),
            ut = E.material;
          ut.visible && h.push(E, pt, ut, N, mt.z, null);
        }
      } else if (E.isImmediateRenderObject)
        k && mt.setFromMatrixPosition(E.matrixWorld).applyMatrix4(Ct),
          h.push(E, null, E.material, N, mt.z, null);
      else if (
        (E.isMesh || E.isLine || E.isPoints) &&
        (E.isSkinnedMesh &&
          E.skeleton.frame !== j.render.frame &&
          (E.skeleton.update(), (E.skeleton.frame = j.render.frame)),
        !E.frustumCulled || Y.intersectsObject(E))
      ) {
        k && mt.setFromMatrixPosition(E.matrixWorld).applyMatrix4(Ct);
        const pt = Tt.update(E),
          ut = E.material;
        if (Array.isArray(ut)) {
          const Gt = pt.groups;
          for (let Yt = 0, ne = Gt.length; Yt < ne; Yt++) {
            const de = Gt[Yt],
              Lt = ut[de.materialIndex];
            Lt && Lt.visible && h.push(E, pt, Lt, N, mt.z, de);
          }
        } else ut.visible && h.push(E, pt, ut, N, mt.z, null);
      }
    }
    const At = E.children;
    for (let pt = 0, ut = At.length; pt < ut; pt++) qt(At[pt], z, N, k);
  }
  function be(E, z, N) {
    const k = z.isScene === !0 ? z.overrideMaterial : null;
    for (let tt = 0, At = E.length; tt < At; tt++) {
      const pt = E[tt],
        ut = pt.object,
        Gt = pt.geometry,
        Yt = k === null ? pt.material : k,
        ne = pt.group;
      if (N.isArrayCamera) {
        w = N;
        const de = N.cameras;
        for (let Lt = 0, ae = de.length; Lt < ae; Lt++) {
          const Me = de[Lt];
          ut.layers.test(Me.layers) &&
            (yt.viewport(M.copy(Me.viewport)),
            d.setupLights(Me),
            Dt(ut, z, Me, Gt, Yt, ne));
        }
      } else (w = null), Dt(ut, z, N, Gt, Yt, ne);
    }
  }
  function Dt(E, z, N, k, tt, At) {
    if (
      (E.onBeforeRender(f, z, N, k, tt, At),
      (d = W.get(z, w || N)),
      E.modelViewMatrix.multiplyMatrices(N.matrixWorldInverse, E.matrixWorld),
      E.normalMatrix.getNormalMatrix(E.modelViewMatrix),
      E.isImmediateRenderObject)
    ) {
      const pt = Xt(N, z, tt, E);
      yt.setMaterial(tt), at.reset(), Xi(E, pt);
    } else f.renderBufferDirect(N, z, k, tt, E, At);
    E.onAfterRender(f, z, N, k, tt, At), (d = W.get(z, w || N));
  }
  function Ut(E, z, N) {
    z.isScene !== !0 && (z = Nt);
    const k = q.get(E),
      tt = d.state.lights,
      At = d.state.shadowsArray,
      pt = tt.state.version,
      ut = T.getParameters(
        E,
        tt.state,
        At,
        z,
        K.numPlanes,
        K.numIntersection,
        N
      ),
      Gt = T.getProgramCacheKey(ut);
    let Yt = k.program,
      ne = !0;
    if (Yt === void 0) E.addEventListener("dispose", ie);
    else if (Yt.cacheKey !== Gt) qi(E);
    else if (k.lightsStateVersion !== pt)
      (k.lightsStateVersion = pt), (ne = !1);
    else {
      if (ut.shaderID !== void 0) return;
      ne = !1;
    }
    ne &&
      ((Yt = T.acquireProgram(ut, Gt)),
      (k.program = Yt),
      (k.uniforms = ut.uniforms),
      (k.outputEncoding = ut.outputEncoding),
      (E.program = Yt));
    const de = Yt.getAttributes();
    if (E.morphTargets) {
      E.numSupportedMorphTargets = 0;
      for (let Kt = 0; Kt < f.maxMorphTargets; Kt++)
        de["morphTarget" + Kt] >= 0 && E.numSupportedMorphTargets++;
    }
    if (E.morphNormals) {
      E.numSupportedMorphNormals = 0;
      for (let Kt = 0; Kt < f.maxMorphNormals; Kt++)
        de["morphNormal" + Kt] >= 0 && E.numSupportedMorphNormals++;
    }
    const Lt = k.uniforms;
    ((!E.isShaderMaterial && !E.isRawShaderMaterial) || E.clipping === !0) &&
      ((k.numClippingPlanes = K.numPlanes),
      (k.numIntersection = K.numIntersection),
      (Lt.clippingPlanes = K.uniform)),
      (k.environment = E.isMeshStandardMaterial ? z.environment : null),
      (k.fog = z.fog),
      (k.needsLights = we(E)),
      (k.lightsStateVersion = pt),
      k.needsLights &&
        ((Lt.ambientLightColor.value = tt.state.ambient),
        (Lt.lightProbe.value = tt.state.probe),
        (Lt.directionalLights.value = tt.state.directional),
        (Lt.directionalLightShadows.value = tt.state.directionalShadow),
        (Lt.spotLights.value = tt.state.spot),
        (Lt.spotLightShadows.value = tt.state.spotShadow),
        (Lt.rectAreaLights.value = tt.state.rectArea),
        (Lt.pointLights.value = tt.state.point),
        (Lt.pointLightShadows.value = tt.state.pointShadow),
        (Lt.hemisphereLights.value = tt.state.hemi),
        (Lt.directionalShadowMap.value = tt.state.directionalShadowMap),
        (Lt.directionalShadowMatrix.value = tt.state.directionalShadowMatrix),
        (Lt.spotShadowMap.value = tt.state.spotShadowMap),
        (Lt.spotShadowMatrix.value = tt.state.spotShadowMatrix),
        (Lt.pointShadowMap.value = tt.state.pointShadowMap),
        (Lt.pointShadowMatrix.value = tt.state.pointShadowMatrix));
    const ae = k.program.getUniforms(),
      Me = zi.seqWithValue(ae.seq, Lt);
    k.uniformsList = Me;
  }
  function Xt(E, z, N, k) {
    z.isScene !== !0 && (z = Nt), X.resetTextureUnits();
    const tt = z.fog,
      At = N.isMeshStandardMaterial ? z.environment : null,
      pt = g === null ? f.outputEncoding : g.texture.encoding,
      ut = q.get(N),
      Gt = d.state.lights;
    if (it === !0 && (et === !0 || E !== v)) {
      const Kt = E === v && N.id === x;
      K.setState(
        N.clippingPlanes,
        N.clipIntersection,
        N.clipShadows,
        E,
        ut,
        Kt
      );
    }
    N.version === ut.__version
      ? (ut.program === void 0 ||
          (N.fog && ut.fog !== tt) ||
          ut.environment !== At ||
          (ut.needsLights && ut.lightsStateVersion !== Gt.state.version) ||
          (ut.numClippingPlanes !== void 0 &&
            (ut.numClippingPlanes !== K.numPlanes ||
              ut.numIntersection !== K.numIntersection)) ||
          ut.outputEncoding !== pt) &&
        Ut(N, z, k)
      : (Ut(N, z, k), (ut.__version = N.version));
    let Yt = !1,
      ne = !1,
      de = !1;
    const Lt = ut.program,
      ae = Lt.getUniforms(),
      Me = ut.uniforms;
    if (
      (yt.useProgram(Lt.program) && ((Yt = !0), (ne = !0), (de = !0)),
      N.id !== x && ((x = N.id), (ne = !0)),
      Yt || v !== E)
    ) {
      if (
        (ae.setValue(G, "projectionMatrix", E.projectionMatrix),
        St.logarithmicDepthBuffer &&
          ae.setValue(G, "logDepthBufFC", 2 / (Math.log(E.far + 1) / Math.LN2)),
        v !== E && ((v = E), (ne = !0), (de = !0)),
        N.isShaderMaterial ||
          N.isMeshPhongMaterial ||
          N.isMeshToonMaterial ||
          N.isMeshStandardMaterial ||
          N.envMap)
      ) {
        const Kt = ae.map.cameraPosition;
        Kt !== void 0 &&
          Kt.setValue(G, mt.setFromMatrixPosition(E.matrixWorld));
      }
      (N.isMeshPhongMaterial ||
        N.isMeshToonMaterial ||
        N.isMeshLambertMaterial ||
        N.isMeshBasicMaterial ||
        N.isMeshStandardMaterial ||
        N.isShaderMaterial) &&
        ae.setValue(G, "isOrthographic", E.isOrthographicCamera === !0),
        (N.isMeshPhongMaterial ||
          N.isMeshToonMaterial ||
          N.isMeshLambertMaterial ||
          N.isMeshBasicMaterial ||
          N.isMeshStandardMaterial ||
          N.isShaderMaterial ||
          N.isShadowMaterial ||
          N.skinning) &&
          ae.setValue(G, "viewMatrix", E.matrixWorldInverse);
    }
    if (N.skinning) {
      ae.setOptional(G, k, "bindMatrix"),
        ae.setOptional(G, k, "bindMatrixInverse");
      const Kt = k.skeleton;
      if (Kt) {
        const pa = Kt.bones;
        if (St.floatVertexTextures) {
          if (Kt.boneTexture === void 0) {
            let vn = Math.sqrt(pa.length * 4);
            (vn = Pt.ceilPowerOfTwo(vn)), (vn = Math.max(vn, 4));
            const xi = new Float32Array(vn * vn * 4);
            xi.set(Kt.boneMatrices);
            const Ol = new bs(xi, vn, vn, Gn, Pi);
            (Kt.boneMatrices = xi),
              (Kt.boneTexture = Ol),
              (Kt.boneTextureSize = vn);
          }
          ae.setValue(G, "boneTexture", Kt.boneTexture, X),
            ae.setValue(G, "boneTextureSize", Kt.boneTextureSize);
        } else ae.setOptional(G, Kt, "boneMatrices");
      }
    }
    return (
      (ne || ut.receiveShadow !== k.receiveShadow) &&
        ((ut.receiveShadow = k.receiveShadow),
        ae.setValue(G, "receiveShadow", k.receiveShadow)),
      ne &&
        (ae.setValue(G, "toneMappingExposure", f.toneMappingExposure),
        ut.needsLights && ln(Me, de),
        tt && N.fog && L.refreshFogUniforms(Me, tt),
        L.refreshMaterialUniforms(Me, N, At, B, I),
        Me.ltc_1 !== void 0 && (Me.ltc_1.value = st.LTC_1),
        Me.ltc_2 !== void 0 && (Me.ltc_2.value = st.LTC_2),
        zi.upload(G, ut.uniformsList, Me, X)),
      N.isShaderMaterial &&
        N.uniformsNeedUpdate === !0 &&
        (zi.upload(G, ut.uniformsList, Me, X), (N.uniformsNeedUpdate = !1)),
      N.isSpriteMaterial && ae.setValue(G, "center", k.center),
      ae.setValue(G, "modelViewMatrix", k.modelViewMatrix),
      ae.setValue(G, "normalMatrix", k.normalMatrix),
      ae.setValue(G, "modelMatrix", k.matrixWorld),
      Lt
    );
  }
  function ln(E, z) {
    (E.ambientLightColor.needsUpdate = z),
      (E.lightProbe.needsUpdate = z),
      (E.directionalLights.needsUpdate = z),
      (E.directionalLightShadows.needsUpdate = z),
      (E.pointLights.needsUpdate = z),
      (E.pointLightShadows.needsUpdate = z),
      (E.spotLights.needsUpdate = z),
      (E.spotLightShadows.needsUpdate = z),
      (E.rectAreaLights.needsUpdate = z),
      (E.hemisphereLights.needsUpdate = z);
  }
  function we(E) {
    return (
      E.isMeshLambertMaterial ||
      E.isMeshToonMaterial ||
      E.isMeshPhongMaterial ||
      E.isMeshStandardMaterial ||
      E.isShadowMaterial ||
      (E.isShaderMaterial && E.lights === !0)
    );
  }
  (this.setFramebuffer = function (E) {
    _ !== E && g === null && G.bindFramebuffer(36160, E), (_ = E);
  }),
    (this.getActiveCubeFace = function () {
      return y;
    }),
    (this.getActiveMipmapLevel = function () {
      return m;
    }),
    (this.getRenderTarget = function () {
      return g;
    }),
    (this.setRenderTarget = function (E, z, N) {
      (g = E),
        (y = z),
        (m = N),
        E && q.get(E).__webglFramebuffer === void 0 && X.setupRenderTarget(E);
      let k = _,
        tt = !1;
      if (E) {
        const At = q.get(E).__webglFramebuffer;
        E.isWebGLCubeRenderTarget
          ? ((k = At[z || 0]), (tt = !0))
          : E.isWebGLMultisampleRenderTarget
          ? (k = q.get(E).__webglMultisampledFramebuffer)
          : (k = At),
          M.copy(E.viewport),
          C.copy(E.scissor),
          (A = E.scissorTest);
      } else
        M.copy(R).multiplyScalar(B).floor(),
          C.copy(P).multiplyScalar(B).floor(),
          (A = V);
      if (
        (b !== k && (G.bindFramebuffer(36160, k), (b = k)),
        yt.viewport(M),
        yt.scissor(C),
        yt.setScissorTest(A),
        tt)
      ) {
        const At = q.get(E.texture);
        G.framebufferTexture2D(
          36160,
          36064,
          34069 + (z || 0),
          At.__webglTexture,
          N || 0
        );
      }
    }),
    (this.readRenderTargetPixels = function (E, z, N, k, tt, At, pt) {
      if (!(E && E.isWebGLRenderTarget)) {
        console.error(
          "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
        );
        return;
      }
      let ut = q.get(E).__webglFramebuffer;
      if ((E.isWebGLCubeRenderTarget && pt !== void 0 && (ut = ut[pt]), ut)) {
        let Gt = !1;
        ut !== b && (G.bindFramebuffer(36160, ut), (Gt = !0));
        try {
          const Yt = E.texture,
            ne = Yt.format,
            de = Yt.type;
          if (ne !== Gn && $.convert(ne) !== G.getParameter(35739)) {
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
            );
            return;
          }
          if (
            de !== Xu &&
            $.convert(de) !== G.getParameter(35738) &&
            !(
              de === Pi &&
              (St.isWebGL2 ||
                vt.get("OES_texture_float") ||
                vt.get("WEBGL_color_buffer_float"))
            ) &&
            !(
              de === ac &&
              (St.isWebGL2
                ? vt.get("EXT_color_buffer_float")
                : vt.get("EXT_color_buffer_half_float"))
            )
          ) {
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
            );
            return;
          }
          G.checkFramebufferStatus(36160) === 36053
            ? z >= 0 &&
              z <= E.width - k &&
              N >= 0 &&
              N <= E.height - tt &&
              G.readPixels(z, N, k, tt, $.convert(ne), $.convert(de), At)
            : console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
              );
        } finally {
          Gt && G.bindFramebuffer(36160, b);
        }
      }
    }),
    (this.copyFramebufferToTexture = function (E, z, N) {
      N === void 0 && (N = 0);
      const k = Math.pow(2, -N),
        tt = Math.floor(z.image.width * k),
        At = Math.floor(z.image.height * k),
        pt = $.convert(z.format);
      X.setTexture2D(z, 0),
        G.copyTexImage2D(3553, N, pt, E.x, E.y, tt, At, 0),
        yt.unbindTexture();
    }),
    (this.copyTextureToTexture = function (E, z, N, k) {
      k === void 0 && (k = 0);
      const tt = z.image.width,
        At = z.image.height,
        pt = $.convert(N.format),
        ut = $.convert(N.type);
      X.setTexture2D(N, 0),
        G.pixelStorei(37440, N.flipY),
        G.pixelStorei(37441, N.premultiplyAlpha),
        G.pixelStorei(3317, N.unpackAlignment),
        z.isDataTexture
          ? G.texSubImage2D(3553, k, E.x, E.y, tt, At, pt, ut, z.image.data)
          : z.isCompressedTexture
          ? G.compressedTexSubImage2D(
              3553,
              k,
              E.x,
              E.y,
              z.mipmaps[0].width,
              z.mipmaps[0].height,
              pt,
              z.mipmaps[0].data
            )
          : G.texSubImage2D(3553, k, E.x, E.y, pt, ut, z.image),
        k === 0 && N.generateMipmaps && G.generateMipmap(3553),
        yt.unbindTexture();
    }),
    (this.initTexture = function (E) {
      X.setTexture2D(E, 0), yt.unbindTexture();
    }),
    typeof __THREE_DEVTOOLS__ != "undefined" &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("observe", { detail: this })
      );
}
function Mm(t) {
  Oc.call(this, t);
}
Mm.prototype = Object.assign(Object.create(Oc.prototype), {
  constructor: Mm,
  isWebGL1Renderer: !0,
});
function Ah(t, e) {
  (this.name = ""),
    (this.color = new lt(t)),
    (this.density = e !== void 0 ? e : 25e-5);
}
Object.assign(Ah.prototype, {
  isFogExp2: !0,
  clone: function () {
    return new Ah(this.color, this.density);
  },
  toJSON: function () {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density,
    };
  },
});
function Lh(t, e, n) {
  (this.name = ""),
    (this.color = new lt(t)),
    (this.near = e !== void 0 ? e : 1),
    (this.far = n !== void 0 ? n : 1e3);
}
Object.assign(Lh.prototype, {
  isFog: !0,
  clone: function () {
    return new Lh(this.color, this.near, this.far);
  },
  toJSON: function () {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  },
});
function gn(t, e) {
  (this.array = t),
    (this.stride = e),
    (this.count = t !== void 0 ? t.length / e : 0),
    (this.usage = hc),
    (this.updateRange = { offset: 0, count: -1 }),
    (this.version = 0),
    (this.uuid = Pt.generateUUID());
}
Object.defineProperty(gn.prototype, "needsUpdate", {
  set: function (t) {
    t === !0 && this.version++;
  },
});
Object.assign(gn.prototype, {
  isInterleavedBuffer: !0,
  onUploadCallback: function () {},
  setUsage: function (t) {
    return (this.usage = t), this;
  },
  copy: function (t) {
    return (
      (this.array = new t.array.constructor(t.array)),
      (this.count = t.count),
      (this.stride = t.stride),
      (this.usage = t.usage),
      this
    );
  },
  copyAt: function (t, e, n) {
    (t *= this.stride), (n *= e.stride);
    for (let i = 0, r = this.stride; i < r; i++)
      this.array[t + i] = e.array[n + i];
    return this;
  },
  set: function (t, e) {
    return e === void 0 && (e = 0), this.array.set(t, e), this;
  },
  clone: function (t) {
    t.arrayBuffers === void 0 && (t.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 &&
        (this.array.buffer._uuid = Pt.generateUUID()),
      t.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const e = new this.array.constructor(
        t.arrayBuffers[this.array.buffer._uuid]
      ),
      n = new gn(e, this.stride);
    return n.setUsage(this.usage), n;
  },
  onUpload: function (t) {
    return (this.onUploadCallback = t), this;
  },
  toJSON: function (t) {
    return (
      t.arrayBuffers === void 0 && (t.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 &&
        (this.array.buffer._uuid = Pt.generateUUID()),
      t.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  },
});
const pr = new S();
function mr(t, e, n, i) {
  (this.name = ""),
    (this.data = t),
    (this.itemSize = e),
    (this.offset = n),
    (this.normalized = i === !0);
}
Object.defineProperties(mr.prototype, {
  count: {
    get: function () {
      return this.data.count;
    },
  },
  array: {
    get: function () {
      return this.data.array;
    },
  },
});
Object.assign(mr.prototype, {
  isInterleavedBufferAttribute: !0,
  applyMatrix4: function (t) {
    for (let e = 0, n = this.data.count; e < n; e++)
      (pr.x = this.getX(e)),
        (pr.y = this.getY(e)),
        (pr.z = this.getZ(e)),
        pr.applyMatrix4(t),
        this.setXYZ(e, pr.x, pr.y, pr.z);
    return this;
  },
  setX: function (t, e) {
    return (this.data.array[t * this.data.stride + this.offset] = e), this;
  },
  setY: function (t, e) {
    return (this.data.array[t * this.data.stride + this.offset + 1] = e), this;
  },
  setZ: function (t, e) {
    return (this.data.array[t * this.data.stride + this.offset + 2] = e), this;
  },
  setW: function (t, e) {
    return (this.data.array[t * this.data.stride + this.offset + 3] = e), this;
  },
  getX: function (t) {
    return this.data.array[t * this.data.stride + this.offset];
  },
  getY: function (t) {
    return this.data.array[t * this.data.stride + this.offset + 1];
  },
  getZ: function (t) {
    return this.data.array[t * this.data.stride + this.offset + 2];
  },
  getW: function (t) {
    return this.data.array[t * this.data.stride + this.offset + 3];
  },
  setXY: function (t, e, n) {
    return (
      (t = t * this.data.stride + this.offset),
      (this.data.array[t + 0] = e),
      (this.data.array[t + 1] = n),
      this
    );
  },
  setXYZ: function (t, e, n, i) {
    return (
      (t = t * this.data.stride + this.offset),
      (this.data.array[t + 0] = e),
      (this.data.array[t + 1] = n),
      (this.data.array[t + 2] = i),
      this
    );
  },
  setXYZW: function (t, e, n, i, r) {
    return (
      (t = t * this.data.stride + this.offset),
      (this.data.array[t + 0] = e),
      (this.data.array[t + 1] = n),
      (this.data.array[t + 2] = i),
      (this.data.array[t + 3] = r),
      this
    );
  },
  clone: function (t) {
    if (t === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
      );
      const e = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++) e.push(this.data.array[i + r]);
      }
      return new wt(
        new this.array.constructor(e),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}),
        t.interleavedBuffers[this.data.uuid] === void 0 &&
          (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
        new mr(
          t.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  },
  toJSON: function (t) {
    if (t === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
      );
      const e = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++) e.push(this.data.array[i + r]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: e,
        normalized: this.normalized,
      };
    } else
      return (
        t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}),
        t.interleavedBuffers[this.data.uuid] === void 0 &&
          (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  },
});
function gr(t) {
  bt.call(this),
    (this.type = "SpriteMaterial"),
    (this.color = new lt(16777215)),
    (this.map = null),
    (this.alphaMap = null),
    (this.rotation = 0),
    (this.sizeAttenuation = !0),
    (this.transparent = !0),
    this.setValues(t);
}
gr.prototype = Object.create(bt.prototype);
gr.prototype.constructor = gr;
gr.prototype.isSpriteMaterial = !0;
gr.prototype.copy = function (t) {
  return (
    bt.prototype.copy.call(this, t),
    this.color.copy(t.color),
    (this.map = t.map),
    (this.alphaMap = t.alphaMap),
    (this.rotation = t.rotation),
    (this.sizeAttenuation = t.sizeAttenuation),
    this
  );
};
let Ts;
const Bo = new S(),
  Es = new S(),
  As = new S(),
  Ls = new H(),
  zo = new H(),
  Sm = new Rt(),
  Dc = new S(),
  Uo = new S(),
  Ic = new S(),
  Tm = new H(),
  Ph = new H(),
  Em = new H();
function Ch(t) {
  if ((nt.call(this), (this.type = "Sprite"), Ts === void 0)) {
    Ts = new ct();
    const e = new Float32Array([
        -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
        0, 0, 1,
      ]),
      n = new gn(e, 5);
    Ts.setIndex([0, 1, 2, 0, 2, 3]),
      Ts.setAttribute("position", new mr(n, 3, 0, !1)),
      Ts.setAttribute("uv", new mr(n, 2, 3, !1));
  }
  (this.geometry = Ts),
    (this.material = t !== void 0 ? t : new gr()),
    (this.center = new H(0.5, 0.5));
}
Ch.prototype = Object.assign(Object.create(nt.prototype), {
  constructor: Ch,
  isSprite: !0,
  raycast: function (t, e) {
    t.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      Es.setFromMatrixScale(this.matrixWorld),
      Sm.copy(t.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        t.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      As.setFromMatrixPosition(this.modelViewMatrix),
      t.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        Es.multiplyScalar(-As.z);
    const n = this.material.rotation;
    let i, r;
    n !== 0 && ((r = Math.cos(n)), (i = Math.sin(n)));
    const s = this.center;
    Nc(Dc.set(-0.5, -0.5, 0), As, s, Es, i, r),
      Nc(Uo.set(0.5, -0.5, 0), As, s, Es, i, r),
      Nc(Ic.set(0.5, 0.5, 0), As, s, Es, i, r),
      Tm.set(0, 0),
      Ph.set(1, 0),
      Em.set(1, 1);
    let o = t.ray.intersectTriangle(Dc, Uo, Ic, !1, Bo);
    if (
      o === null &&
      (Nc(Uo.set(-0.5, 0.5, 0), As, s, Es, i, r),
      Ph.set(0, 1),
      (o = t.ray.intersectTriangle(Dc, Ic, Uo, !1, Bo)),
      o === null)
    )
      return;
    const a = t.ray.origin.distanceTo(Bo);
    a < t.near ||
      a > t.far ||
      e.push({
        distance: a,
        point: Bo.clone(),
        uv: Re.getUV(Bo, Dc, Uo, Ic, Tm, Ph, Em, new H()),
        face: null,
        object: this,
      });
  },
  copy: function (t) {
    return (
      nt.prototype.copy.call(this, t),
      t.center !== void 0 && this.center.copy(t.center),
      (this.material = t.material),
      this
    );
  },
});
function Nc(t, e, n, i, r, s) {
  Ls.subVectors(t, n).addScalar(0.5).multiply(i),
    r !== void 0
      ? ((zo.x = s * Ls.x - r * Ls.y), (zo.y = r * Ls.x + s * Ls.y))
      : zo.copy(Ls),
    t.copy(e),
    (t.x += zo.x),
    (t.y += zo.y),
    t.applyMatrix4(Sm);
}
const Fc = new S(),
  Am = new S();
function Bc() {
  nt.call(this),
    (this._currentLevel = 0),
    (this.type = "LOD"),
    Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }),
    (this.autoUpdate = !0);
}
Bc.prototype = Object.assign(Object.create(nt.prototype), {
  constructor: Bc,
  isLOD: !0,
  copy: function (t) {
    nt.prototype.copy.call(this, t, !1);
    const e = t.levels;
    for (let n = 0, i = e.length; n < i; n++) {
      const r = e[n];
      this.addLevel(r.object.clone(), r.distance);
    }
    return (this.autoUpdate = t.autoUpdate), this;
  },
  addLevel: function (t, e) {
    e === void 0 && (e = 0), (e = Math.abs(e));
    const n = this.levels;
    let i;
    for (i = 0; i < n.length && !(e < n[i].distance); i++);
    return n.splice(i, 0, { distance: e, object: t }), this.add(t), this;
  },
  getCurrentLevel: function () {
    return this._currentLevel;
  },
  getObjectForDistance: function (t) {
    const e = this.levels;
    if (e.length > 0) {
      let n, i;
      for (n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
      return e[n - 1].object;
    }
    return null;
  },
  raycast: function (t, e) {
    if (this.levels.length > 0) {
      Fc.setFromMatrixPosition(this.matrixWorld);
      const i = t.ray.origin.distanceTo(Fc);
      this.getObjectForDistance(i).raycast(t, e);
    }
  },
  update: function (t) {
    const e = this.levels;
    if (e.length > 1) {
      Fc.setFromMatrixPosition(t.matrixWorld),
        Am.setFromMatrixPosition(this.matrixWorld);
      const n = Fc.distanceTo(Am) / t.zoom;
      e[0].object.visible = !0;
      let i, r;
      for (i = 1, r = e.length; i < r && n >= e[i].distance; i++)
        (e[i - 1].object.visible = !1), (e[i].object.visible = !0);
      for (this._currentLevel = i - 1; i < r; i++) e[i].object.visible = !1;
    }
  },
  toJSON: function (t) {
    const e = nt.prototype.toJSON.call(this, t);
    this.autoUpdate === !1 && (e.object.autoUpdate = !1),
      (e.object.levels = []);
    const n = this.levels;
    for (let i = 0, r = n.length; i < r; i++) {
      const s = n[i];
      e.object.levels.push({ object: s.object.uuid, distance: s.distance });
    }
    return e;
  },
});
function Rh(t, e) {
  t &&
    t.isGeometry &&
    console.error(
      "THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
    ),
    he.call(this, t, e),
    (this.type = "SkinnedMesh"),
    (this.bindMode = "attached"),
    (this.bindMatrix = new Rt()),
    (this.bindMatrixInverse = new Rt());
}
Rh.prototype = Object.assign(Object.create(he.prototype), {
  constructor: Rh,
  isSkinnedMesh: !0,
  copy: function (t) {
    return (
      he.prototype.copy.call(this, t),
      (this.bindMode = t.bindMode),
      this.bindMatrix.copy(t.bindMatrix),
      this.bindMatrixInverse.copy(t.bindMatrixInverse),
      (this.skeleton = t.skeleton),
      this
    );
  },
  bind: function (t, e) {
    (this.skeleton = t),
      e === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (e = this.matrixWorld)),
      this.bindMatrix.copy(e),
      this.bindMatrixInverse.getInverse(e);
  },
  pose: function () {
    this.skeleton.pose();
  },
  normalizeSkinWeights: function () {
    const t = new Vt(),
      e = this.geometry.attributes.skinWeight;
    for (let n = 0, i = e.count; n < i; n++) {
      (t.x = e.getX(n)),
        (t.y = e.getY(n)),
        (t.z = e.getZ(n)),
        (t.w = e.getW(n));
      const r = 1 / t.manhattanLength();
      r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0),
        e.setXYZW(n, t.x, t.y, t.z, t.w);
    }
  },
  updateMatrixWorld: function (t) {
    he.prototype.updateMatrixWorld.call(this, t),
      this.bindMode === "attached"
        ? this.bindMatrixInverse.getInverse(this.matrixWorld)
        : this.bindMode === "detached"
        ? this.bindMatrixInverse.getInverse(this.bindMatrix)
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  },
  boneTransform: (function () {
    const t = new S(),
      e = new Vt(),
      n = new Vt(),
      i = new S(),
      r = new Rt();
    return function (s, o) {
      const a = this.skeleton,
        c = this.geometry;
      e.fromBufferAttribute(c.attributes.skinIndex, s),
        n.fromBufferAttribute(c.attributes.skinWeight, s),
        t
          .fromBufferAttribute(c.attributes.position, s)
          .applyMatrix4(this.bindMatrix),
        o.set(0, 0, 0);
      for (let l = 0; l < 4; l++) {
        const u = n.getComponent(l);
        if (u !== 0) {
          const h = e.getComponent(l);
          r.multiplyMatrices(a.bones[h].matrixWorld, a.boneInverses[h]),
            o.addScaledVector(i.copy(t).applyMatrix4(r), u);
        }
      }
      return o.applyMatrix4(this.bindMatrixInverse);
    };
  })(),
});
const Lm = new Rt(),
  wM = new Rt();
function Oh(t, e) {
  if (
    ((t = t || []),
    (this.bones = t.slice(0)),
    (this.boneMatrices = new Float32Array(this.bones.length * 16)),
    (this.frame = -1),
    e === void 0)
  )
    this.calculateInverses();
  else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
  else {
    console.warn("THREE.Skeleton boneInverses is the wrong length."),
      (this.boneInverses = []);
    for (let n = 0, i = this.bones.length; n < i; n++)
      this.boneInverses.push(new Rt());
  }
}
Object.assign(Oh.prototype, {
  calculateInverses: function () {
    this.boneInverses = [];
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const n = new Rt();
      this.bones[t] && n.getInverse(this.bones[t].matrixWorld),
        this.boneInverses.push(n);
    }
  },
  pose: function () {
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const n = this.bones[t];
      n && n.matrixWorld.getInverse(this.boneInverses[t]);
    }
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const n = this.bones[t];
      n &&
        (n.parent && n.parent.isBone
          ? (n.matrix.getInverse(n.parent.matrixWorld),
            n.matrix.multiply(n.matrixWorld))
          : n.matrix.copy(n.matrixWorld),
        n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  },
  update: function () {
    const t = this.bones,
      e = this.boneInverses,
      n = this.boneMatrices,
      i = this.boneTexture;
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r] ? t[r].matrixWorld : wM;
      Lm.multiplyMatrices(o, e[r]), Lm.toArray(n, r * 16);
    }
    i !== void 0 && (i.needsUpdate = !0);
  },
  clone: function () {
    return new Oh(this.bones, this.boneInverses);
  },
  getBoneByName: function (t) {
    for (let e = 0, n = this.bones.length; e < n; e++) {
      const i = this.bones[e];
      if (i.name === t) return i;
    }
  },
  dispose: function () {
    this.boneTexture &&
      (this.boneTexture.dispose(), (this.boneTexture = void 0));
  },
});
function Pm() {
  nt.call(this), (this.type = "Bone");
}
Pm.prototype = Object.assign(Object.create(nt.prototype), {
  constructor: Pm,
  isBone: !0,
});
const Cm = new Rt(),
  Rm = new Rt(),
  zc = [],
  ko = new he();
function Dh(t, e, n) {
  he.call(this, t, e),
    (this.instanceMatrix = new wt(new Float32Array(n * 16), 16)),
    (this.count = n),
    (this.frustumCulled = !1);
}
Dh.prototype = Object.assign(Object.create(he.prototype), {
  constructor: Dh,
  isInstancedMesh: !0,
  copy: function (t) {
    return (
      he.prototype.copy.call(this, t),
      this.instanceMatrix.copy(t.instanceMatrix),
      (this.count = t.count),
      this
    );
  },
  getMatrixAt: function (t, e) {
    e.fromArray(this.instanceMatrix.array, t * 16);
  },
  raycast: function (t, e) {
    const n = this.matrixWorld,
      i = this.count;
    if (
      ((ko.geometry = this.geometry),
      (ko.material = this.material),
      ko.material !== void 0)
    )
      for (let r = 0; r < i; r++) {
        this.getMatrixAt(r, Cm),
          Rm.multiplyMatrices(n, Cm),
          (ko.matrixWorld = Rm),
          ko.raycast(t, zc);
        for (let s = 0, o = zc.length; s < o; s++) {
          const a = zc[s];
          (a.instanceId = r), (a.object = this), e.push(a);
        }
        zc.length = 0;
      }
  },
  setMatrixAt: function (t, e) {
    e.toArray(this.instanceMatrix.array, t * 16);
  },
  updateMorphTargets: function () {},
});
function me(t) {
  bt.call(this),
    (this.type = "LineBasicMaterial"),
    (this.color = new lt(16777215)),
    (this.linewidth = 1),
    (this.linecap = "round"),
    (this.linejoin = "round"),
    (this.morphTargets = !1),
    this.setValues(t);
}
me.prototype = Object.create(bt.prototype);
me.prototype.constructor = me;
me.prototype.isLineBasicMaterial = !0;
me.prototype.copy = function (t) {
  return (
    bt.prototype.copy.call(this, t),
    this.color.copy(t.color),
    (this.linewidth = t.linewidth),
    (this.linecap = t.linecap),
    (this.linejoin = t.linejoin),
    (this.morphTargets = t.morphTargets),
    this
  );
};
const Om = new S(),
  Dm = new S(),
  Im = new Rt(),
  Uc = new hs(),
  kc = new ci();
function yn(t, e, n) {
  n === 1 &&
    console.error(
      "THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."
    ),
    nt.call(this),
    (this.type = "Line"),
    (this.geometry = t !== void 0 ? t : new ct()),
    (this.material = e !== void 0 ? e : new me()),
    this.updateMorphTargets();
}
yn.prototype = Object.assign(Object.create(nt.prototype), {
  constructor: yn,
  isLine: !0,
  copy: function (t) {
    return (
      nt.prototype.copy.call(this, t),
      (this.material = t.material),
      (this.geometry = t.geometry),
      this
    );
  },
  computeLineDistances: function () {
    const t = this.geometry;
    if (t.isBufferGeometry)
      if (t.index === null) {
        const e = t.attributes.position,
          n = [0];
        for (let i = 1, r = e.count; i < r; i++)
          Om.fromBufferAttribute(e, i - 1),
            Dm.fromBufferAttribute(e, i),
            (n[i] = n[i - 1]),
            (n[i] += Om.distanceTo(Dm));
        t.setAttribute("lineDistance", new rt(n, 1));
      } else
        console.warn(
          "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
        );
    else if (t.isGeometry) {
      const e = t.vertices,
        n = t.lineDistances;
      n[0] = 0;
      for (let i = 1, r = e.length; i < r; i++)
        (n[i] = n[i - 1]), (n[i] += e[i - 1].distanceTo(e[i]));
    }
    return this;
  },
  raycast: function (t, e) {
    const n = this.geometry,
      i = this.matrixWorld,
      r = t.params.Line.threshold;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      kc.copy(n.boundingSphere),
      kc.applyMatrix4(i),
      (kc.radius += r),
      t.ray.intersectsSphere(kc) === !1)
    )
      return;
    Im.getInverse(i), Uc.copy(t.ray).applyMatrix4(Im);
    const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      o = s * s,
      a = new S(),
      c = new S(),
      l = new S(),
      u = new S(),
      h = this && this.isLineSegments ? 2 : 1;
    if (n.isBufferGeometry) {
      const d = n.index,
        p = n.attributes.position.array;
      if (d !== null) {
        const _ = d.array;
        for (let y = 0, m = _.length - 1; y < m; y += h) {
          const g = _[y],
            b = _[y + 1];
          if (
            (a.fromArray(p, g * 3),
            c.fromArray(p, b * 3),
            Uc.distanceSqToSegment(a, c, u, l) > o)
          )
            continue;
          u.applyMatrix4(this.matrixWorld);
          const v = t.ray.origin.distanceTo(u);
          v < t.near ||
            v > t.far ||
            e.push({
              distance: v,
              point: l.clone().applyMatrix4(this.matrixWorld),
              index: y,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
      } else
        for (let _ = 0, y = p.length / 3 - 1; _ < y; _ += h) {
          if (
            (a.fromArray(p, 3 * _),
            c.fromArray(p, 3 * _ + 3),
            Uc.distanceSqToSegment(a, c, u, l) > o)
          )
            continue;
          u.applyMatrix4(this.matrixWorld);
          const g = t.ray.origin.distanceTo(u);
          g < t.near ||
            g > t.far ||
            e.push({
              distance: g,
              point: l.clone().applyMatrix4(this.matrixWorld),
              index: _,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
    } else if (n.isGeometry) {
      const d = n.vertices,
        f = d.length;
      for (let p = 0; p < f - 1; p += h) {
        if (Uc.distanceSqToSegment(d[p], d[p + 1], u, l) > o) continue;
        u.applyMatrix4(this.matrixWorld);
        const y = t.ray.origin.distanceTo(u);
        y < t.near ||
          y > t.far ||
          e.push({
            distance: y,
            point: l.clone().applyMatrix4(this.matrixWorld),
            index: p,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    }
  },
  updateMorphTargets: function () {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      const e = t.morphAttributes,
        n = Object.keys(e);
      if (n.length > 0) {
        const i = e[n[0]];
        if (i !== void 0) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let r = 0, s = i.length; r < s; r++) {
            const o = i[r].name || String(r);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[o] = r);
          }
        }
      }
    } else {
      const e = t.morphTargets;
      e !== void 0 &&
        e.length > 0 &&
        console.error(
          "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
        );
    }
  },
});
const Gc = new S(),
  Hc = new S();
function ve(t, e) {
  yn.call(this, t, e), (this.type = "LineSegments");
}
ve.prototype = Object.assign(Object.create(yn.prototype), {
  constructor: ve,
  isLineSegments: !0,
  computeLineDistances: function () {
    const t = this.geometry;
    if (t.isBufferGeometry)
      if (t.index === null) {
        const e = t.attributes.position,
          n = [];
        for (let i = 0, r = e.count; i < r; i += 2)
          Gc.fromBufferAttribute(e, i),
            Hc.fromBufferAttribute(e, i + 1),
            (n[i] = i === 0 ? 0 : n[i - 1]),
            (n[i + 1] = n[i] + Gc.distanceTo(Hc));
        t.setAttribute("lineDistance", new rt(n, 1));
      } else
        console.warn(
          "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
        );
    else if (t.isGeometry) {
      const e = t.vertices,
        n = t.lineDistances;
      for (let i = 0, r = e.length; i < r; i += 2)
        Gc.copy(e[i]),
          Hc.copy(e[i + 1]),
          (n[i] = i === 0 ? 0 : n[i - 1]),
          (n[i + 1] = n[i] + Gc.distanceTo(Hc));
    }
    return this;
  },
});
function Ih(t, e) {
  yn.call(this, t, e), (this.type = "LineLoop");
}
Ih.prototype = Object.assign(Object.create(yn.prototype), {
  constructor: Ih,
  isLineLoop: !0,
});
function yr(t) {
  bt.call(this),
    (this.type = "PointsMaterial"),
    (this.color = new lt(16777215)),
    (this.map = null),
    (this.alphaMap = null),
    (this.size = 1),
    (this.sizeAttenuation = !0),
    (this.morphTargets = !1),
    this.setValues(t);
}
yr.prototype = Object.create(bt.prototype);
yr.prototype.constructor = yr;
yr.prototype.isPointsMaterial = !0;
yr.prototype.copy = function (t) {
  return (
    bt.prototype.copy.call(this, t),
    this.color.copy(t.color),
    (this.map = t.map),
    (this.alphaMap = t.alphaMap),
    (this.size = t.size),
    (this.sizeAttenuation = t.sizeAttenuation),
    (this.morphTargets = t.morphTargets),
    this
  );
};
const Nm = new Rt(),
  Nh = new hs(),
  Vc = new ci(),
  Wc = new S();
function Fh(t, e) {
  nt.call(this),
    (this.type = "Points"),
    (this.geometry = t !== void 0 ? t : new ct()),
    (this.material = e !== void 0 ? e : new yr()),
    this.updateMorphTargets();
}
Fh.prototype = Object.assign(Object.create(nt.prototype), {
  constructor: Fh,
  isPoints: !0,
  copy: function (t) {
    return (
      nt.prototype.copy.call(this, t),
      (this.material = t.material),
      (this.geometry = t.geometry),
      this
    );
  },
  raycast: function (t, e) {
    const n = this.geometry,
      i = this.matrixWorld,
      r = t.params.Points.threshold;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      Vc.copy(n.boundingSphere),
      Vc.applyMatrix4(i),
      (Vc.radius += r),
      t.ray.intersectsSphere(Vc) === !1)
    )
      return;
    Nm.getInverse(i), Nh.copy(t.ray).applyMatrix4(Nm);
    const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      o = s * s;
    if (n.isBufferGeometry) {
      const a = n.index,
        l = n.attributes.position.array;
      if (a !== null) {
        const u = a.array;
        for (let h = 0, d = u.length; h < d; h++) {
          const f = u[h];
          Wc.fromArray(l, f * 3), Bh(Wc, f, o, i, t, e, this);
        }
      } else
        for (let u = 0, h = l.length / 3; u < h; u++)
          Wc.fromArray(l, u * 3), Bh(Wc, u, o, i, t, e, this);
    } else {
      const a = n.vertices;
      for (let c = 0, l = a.length; c < l; c++) Bh(a[c], c, o, i, t, e, this);
    }
  },
  updateMorphTargets: function () {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      const e = t.morphAttributes,
        n = Object.keys(e);
      if (n.length > 0) {
        const i = e[n[0]];
        if (i !== void 0) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let r = 0, s = i.length; r < s; r++) {
            const o = i[r].name || String(r);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[o] = r);
          }
        }
      }
    } else {
      const e = t.morphTargets;
      e !== void 0 &&
        e.length > 0 &&
        console.error(
          "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
        );
    }
  },
});
function Bh(t, e, n, i, r, s, o) {
  const a = Nh.distanceSqToPoint(t);
  if (a < n) {
    const c = new S();
    Nh.closestPointToPoint(t, c), c.applyMatrix4(i);
    const l = r.ray.origin.distanceTo(c);
    if (l < r.near || l > r.far) return;
    s.push({
      distance: l,
      distanceToRay: Math.sqrt(a),
      point: c,
      index: e,
      face: null,
      object: o,
    });
  }
}
function Fm(t, e, n, i, r, s, o, a, c) {
  Jt.call(this, t, e, n, i, r, s, o, a, c),
    (this.format = o !== void 0 ? o : ar),
    (this.minFilter = s !== void 0 ? s : Ie),
    (this.magFilter = r !== void 0 ? r : Ie),
    (this.generateMipmaps = !1);
}
Fm.prototype = Object.assign(Object.create(Jt.prototype), {
  constructor: Fm,
  isVideoTexture: !0,
  update: function () {
    const t = this.image;
    t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  },
});
function Go(t, e, n, i, r, s, o, a, c, l, u, h) {
  Jt.call(this, null, s, o, a, c, l, i, r, u, h),
    (this.image = { width: e, height: n }),
    (this.mipmaps = t),
    (this.flipY = !1),
    (this.generateMipmaps = !1);
}
Go.prototype = Object.create(Jt.prototype);
Go.prototype.constructor = Go;
Go.prototype.isCompressedTexture = !0;
function jc(t, e, n, i, r, s, o, a, c) {
  Jt.call(this, t, e, n, i, r, s, o, a, c), (this.needsUpdate = !0);
}
jc.prototype = Object.create(Jt.prototype);
jc.prototype.constructor = jc;
jc.prototype.isCanvasTexture = !0;
function qc(t, e, n, i, r, s, o, a, c, l) {
  if (((l = l !== void 0 ? l : ts), l !== ts && l !== xo))
    throw new Error(
      "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
    );
  n === void 0 && l === ts && (n = sc),
    n === void 0 && l === xo && (n = _o),
    Jt.call(this, null, i, r, s, o, a, l, n, c),
    (this.image = { width: t, height: e }),
    (this.magFilter = o !== void 0 ? o : De),
    (this.minFilter = a !== void 0 ? a : De),
    (this.flipY = !1),
    (this.generateMipmaps = !1);
}
qc.prototype = Object.create(Jt.prototype);
qc.prototype.constructor = qc;
qc.prototype.isDepthTexture = !0;
function Xc(t) {
  ct.call(this), (this.type = "WireframeGeometry");
  const e = [],
    n = [0, 0],
    i = {},
    r = ["a", "b", "c"];
  if (t && t.isGeometry) {
    const s = t.faces;
    for (let o = 0, a = s.length; o < a; o++) {
      const c = s[o];
      for (let l = 0; l < 3; l++) {
        const u = c[r[l]],
          h = c[r[(l + 1) % 3]];
        (n[0] = Math.min(u, h)), (n[1] = Math.max(u, h));
        const d = n[0] + "," + n[1];
        i[d] === void 0 && (i[d] = { index1: n[0], index2: n[1] });
      }
    }
    for (const o in i) {
      const a = i[o];
      let c = t.vertices[a.index1];
      e.push(c.x, c.y, c.z), (c = t.vertices[a.index2]), e.push(c.x, c.y, c.z);
    }
  } else if (t && t.isBufferGeometry) {
    let s = new S();
    if (t.index !== null) {
      const o = t.attributes.position,
        a = t.index;
      let c = t.groups;
      c.length === 0 && (c = [{ start: 0, count: a.count, materialIndex: 0 }]);
      for (let l = 0, u = c.length; l < u; ++l) {
        const h = c[l],
          d = h.start,
          f = h.count;
        for (let p = d, _ = d + f; p < _; p += 3)
          for (let y = 0; y < 3; y++) {
            const m = a.getX(p + y),
              g = a.getX(p + ((y + 1) % 3));
            (n[0] = Math.min(m, g)), (n[1] = Math.max(m, g));
            const b = n[0] + "," + n[1];
            i[b] === void 0 && (i[b] = { index1: n[0], index2: n[1] });
          }
      }
      for (const l in i) {
        const u = i[l];
        s.fromBufferAttribute(o, u.index1),
          e.push(s.x, s.y, s.z),
          s.fromBufferAttribute(o, u.index2),
          e.push(s.x, s.y, s.z);
      }
    } else {
      const o = t.attributes.position;
      for (let a = 0, c = o.count / 3; a < c; a++)
        for (let l = 0; l < 3; l++) {
          const u = 3 * a + l;
          s.fromBufferAttribute(o, u), e.push(s.x, s.y, s.z);
          const h = 3 * a + ((l + 1) % 3);
          s.fromBufferAttribute(o, h), e.push(s.x, s.y, s.z);
        }
    }
  }
  this.setAttribute("position", new rt(e, 3));
}
Xc.prototype = Object.create(ct.prototype);
Xc.prototype.constructor = Xc;
function Yc(t, e, n) {
  Mt.call(this),
    (this.type = "ParametricGeometry"),
    (this.parameters = { func: t, slices: e, stacks: n }),
    this.fromBufferGeometry(new Ho(t, e, n)),
    this.mergeVertices();
}
Yc.prototype = Object.create(Mt.prototype);
Yc.prototype.constructor = Yc;
function Ho(t, e, n) {
  ct.call(this),
    (this.type = "ParametricBufferGeometry"),
    (this.parameters = { func: t, slices: e, stacks: n });
  const i = [],
    r = [],
    s = [],
    o = [],
    a = 1e-5,
    c = new S(),
    l = new S(),
    u = new S(),
    h = new S(),
    d = new S();
  t.length < 3 &&
    console.error(
      "THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
    );
  const f = e + 1;
  for (let p = 0; p <= n; p++) {
    const _ = p / n;
    for (let y = 0; y <= e; y++) {
      const m = y / e;
      t(m, _, l),
        r.push(l.x, l.y, l.z),
        m - a >= 0
          ? (t(m - a, _, u), h.subVectors(l, u))
          : (t(m + a, _, u), h.subVectors(u, l)),
        _ - a >= 0
          ? (t(m, _ - a, u), d.subVectors(l, u))
          : (t(m, _ + a, u), d.subVectors(u, l)),
        c.crossVectors(h, d).normalize(),
        s.push(c.x, c.y, c.z),
        o.push(m, _);
    }
  }
  for (let p = 0; p < n; p++)
    for (let _ = 0; _ < e; _++) {
      const y = p * f + _,
        m = p * f + _ + 1,
        g = (p + 1) * f + _ + 1,
        b = (p + 1) * f + _;
      i.push(y, m, b), i.push(m, g, b);
    }
  this.setIndex(i),
    this.setAttribute("position", new rt(r, 3)),
    this.setAttribute("normal", new rt(s, 3)),
    this.setAttribute("uv", new rt(o, 2));
}
Ho.prototype = Object.create(ct.prototype);
Ho.prototype.constructor = Ho;
function Zc(t, e, n, i) {
  Mt.call(this),
    (this.type = "PolyhedronGeometry"),
    (this.parameters = { vertices: t, indices: e, radius: n, detail: i }),
    this.fromBufferGeometry(new an(t, e, n, i)),
    this.mergeVertices();
}
Zc.prototype = Object.create(Mt.prototype);
Zc.prototype.constructor = Zc;
function an(t, e, n, i) {
  ct.call(this),
    (this.type = "PolyhedronBufferGeometry"),
    (this.parameters = { vertices: t, indices: e, radius: n, detail: i }),
    (n = n || 1),
    (i = i || 0);
  const r = [],
    s = [];
  o(i),
    c(n),
    l(),
    this.setAttribute("position", new rt(r, 3)),
    this.setAttribute("normal", new rt(r.slice(), 3)),
    this.setAttribute("uv", new rt(s, 2)),
    i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
  function o(m) {
    const g = new S(),
      b = new S(),
      x = new S();
    for (let v = 0; v < e.length; v += 3)
      d(e[v + 0], g), d(e[v + 1], b), d(e[v + 2], x), a(g, b, x, m);
  }
  function a(m, g, b, x) {
    const v = Math.pow(2, x),
      w = [];
    for (let M = 0; M <= v; M++) {
      w[M] = [];
      const C = m.clone().lerp(b, M / v),
        A = g.clone().lerp(b, M / v),
        U = v - M;
      for (let I = 0; I <= U; I++)
        I === 0 && M === v
          ? (w[M][I] = C)
          : (w[M][I] = C.clone().lerp(A, I / U));
    }
    for (let M = 0; M < v; M++)
      for (let C = 0; C < 2 * (v - M) - 1; C++) {
        const A = Math.floor(C / 2);
        C % 2 == 0
          ? (h(w[M][A + 1]), h(w[M + 1][A]), h(w[M][A]))
          : (h(w[M][A + 1]), h(w[M + 1][A + 1]), h(w[M + 1][A]));
      }
  }
  function c(m) {
    const g = new S();
    for (let b = 0; b < r.length; b += 3)
      (g.x = r[b + 0]),
        (g.y = r[b + 1]),
        (g.z = r[b + 2]),
        g.normalize().multiplyScalar(m),
        (r[b + 0] = g.x),
        (r[b + 1] = g.y),
        (r[b + 2] = g.z);
  }
  function l() {
    const m = new S();
    for (let g = 0; g < r.length; g += 3) {
      (m.x = r[g + 0]), (m.y = r[g + 1]), (m.z = r[g + 2]);
      const b = _(m) / 2 / Math.PI + 0.5,
        x = y(m) / Math.PI + 0.5;
      s.push(b, 1 - x);
    }
    f(), u();
  }
  function u() {
    for (let m = 0; m < s.length; m += 6) {
      const g = s[m + 0],
        b = s[m + 2],
        x = s[m + 4],
        v = Math.max(g, b, x),
        w = Math.min(g, b, x);
      v > 0.9 &&
        w < 0.1 &&
        (g < 0.2 && (s[m + 0] += 1),
        b < 0.2 && (s[m + 2] += 1),
        x < 0.2 && (s[m + 4] += 1));
    }
  }
  function h(m) {
    r.push(m.x, m.y, m.z);
  }
  function d(m, g) {
    const b = m * 3;
    (g.x = t[b + 0]), (g.y = t[b + 1]), (g.z = t[b + 2]);
  }
  function f() {
    const m = new S(),
      g = new S(),
      b = new S(),
      x = new S(),
      v = new H(),
      w = new H(),
      M = new H();
    for (let C = 0, A = 0; C < r.length; C += 9, A += 6) {
      m.set(r[C + 0], r[C + 1], r[C + 2]),
        g.set(r[C + 3], r[C + 4], r[C + 5]),
        b.set(r[C + 6], r[C + 7], r[C + 8]),
        v.set(s[A + 0], s[A + 1]),
        w.set(s[A + 2], s[A + 3]),
        M.set(s[A + 4], s[A + 5]),
        x.copy(m).add(g).add(b).divideScalar(3);
      const U = _(x);
      p(v, A + 0, m, U), p(w, A + 2, g, U), p(M, A + 4, b, U);
    }
  }
  function p(m, g, b, x) {
    x < 0 && m.x === 1 && (s[g] = m.x - 1),
      b.x === 0 && b.z === 0 && (s[g] = x / 2 / Math.PI + 0.5);
  }
  function _(m) {
    return Math.atan2(m.z, -m.x);
  }
  function y(m) {
    return Math.atan2(-m.y, Math.sqrt(m.x * m.x + m.z * m.z));
  }
}
an.prototype = Object.create(ct.prototype);
an.prototype.constructor = an;
function Jc(t, e) {
  Mt.call(this),
    (this.type = "TetrahedronGeometry"),
    (this.parameters = { radius: t, detail: e }),
    this.fromBufferGeometry(new Vo(t, e)),
    this.mergeVertices();
}
Jc.prototype = Object.create(Mt.prototype);
Jc.prototype.constructor = Jc;
function Vo(t, e) {
  const n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
    i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
  an.call(this, n, i, t, e),
    (this.type = "TetrahedronBufferGeometry"),
    (this.parameters = { radius: t, detail: e });
}
Vo.prototype = Object.create(an.prototype);
Vo.prototype.constructor = Vo;
function $c(t, e) {
  Mt.call(this),
    (this.type = "OctahedronGeometry"),
    (this.parameters = { radius: t, detail: e }),
    this.fromBufferGeometry(new Ps(t, e)),
    this.mergeVertices();
}
$c.prototype = Object.create(Mt.prototype);
$c.prototype.constructor = $c;
function Ps(t, e) {
  const n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
    i = [
      0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
    ];
  an.call(this, n, i, t, e),
    (this.type = "OctahedronBufferGeometry"),
    (this.parameters = { radius: t, detail: e });
}
Ps.prototype = Object.create(an.prototype);
Ps.prototype.constructor = Ps;
function Qc(t, e) {
  Mt.call(this),
    (this.type = "IcosahedronGeometry"),
    (this.parameters = { radius: t, detail: e }),
    this.fromBufferGeometry(new Wo(t, e)),
    this.mergeVertices();
}
Qc.prototype = Object.create(Mt.prototype);
Qc.prototype.constructor = Qc;
function Wo(t, e) {
  const n = (1 + Math.sqrt(5)) / 2,
    i = [
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      0,
      0,
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      n,
      0,
      -1,
      n,
      0,
      1,
      -n,
      0,
      -1,
      -n,
      0,
      1,
    ],
    r = [
      0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
      10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4,
      9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
    ];
  an.call(this, i, r, t, e),
    (this.type = "IcosahedronBufferGeometry"),
    (this.parameters = { radius: t, detail: e });
}
Wo.prototype = Object.create(an.prototype);
Wo.prototype.constructor = Wo;
function Kc(t, e) {
  Mt.call(this),
    (this.type = "DodecahedronGeometry"),
    (this.parameters = { radius: t, detail: e }),
    this.fromBufferGeometry(new jo(t, e)),
    this.mergeVertices();
}
Kc.prototype = Object.create(Mt.prototype);
Kc.prototype.constructor = Kc;
function jo(t, e) {
  const n = (1 + Math.sqrt(5)) / 2,
    i = 1 / n,
    r = [
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      0,
      -i,
      -n,
      0,
      -i,
      n,
      0,
      i,
      -n,
      0,
      i,
      n,
      -i,
      -n,
      0,
      -i,
      n,
      0,
      i,
      -n,
      0,
      i,
      n,
      0,
      -n,
      0,
      -i,
      n,
      0,
      -i,
      -n,
      0,
      i,
      n,
      0,
      i,
    ],
    s = [
      3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
      17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0,
      18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18,
      1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5,
      19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5,
      9,
    ];
  an.call(this, r, s, t, e),
    (this.type = "DodecahedronBufferGeometry"),
    (this.parameters = { radius: t, detail: e });
}
jo.prototype = Object.create(an.prototype);
jo.prototype.constructor = jo;
function tl(t, e, n, i, r, s) {
  Mt.call(this),
    (this.type = "TubeGeometry"),
    (this.parameters = {
      path: t,
      tubularSegments: e,
      radius: n,
      radialSegments: i,
      closed: r,
    }),
    s !== void 0 && console.warn("THREE.TubeGeometry: taper has been removed.");
  const o = new Cs(t, e, n, i, r);
  (this.tangents = o.tangents),
    (this.normals = o.normals),
    (this.binormals = o.binormals),
    this.fromBufferGeometry(o),
    this.mergeVertices();
}
tl.prototype = Object.create(Mt.prototype);
tl.prototype.constructor = tl;
function Cs(t, e, n, i, r) {
  ct.call(this),
    (this.type = "TubeBufferGeometry"),
    (this.parameters = {
      path: t,
      tubularSegments: e,
      radius: n,
      radialSegments: i,
      closed: r,
    }),
    (e = e || 64),
    (n = n || 1),
    (i = i || 8),
    (r = r || !1);
  const s = t.computeFrenetFrames(e, r);
  (this.tangents = s.tangents),
    (this.normals = s.normals),
    (this.binormals = s.binormals);
  const o = new S(),
    a = new S(),
    c = new H();
  let l = new S();
  const u = [],
    h = [],
    d = [],
    f = [];
  p(),
    this.setIndex(f),
    this.setAttribute("position", new rt(u, 3)),
    this.setAttribute("normal", new rt(h, 3)),
    this.setAttribute("uv", new rt(d, 2));
  function p() {
    for (let g = 0; g < e; g++) _(g);
    _(r === !1 ? e : 0), m(), y();
  }
  function _(g) {
    l = t.getPointAt(g / e, l);
    const b = s.normals[g],
      x = s.binormals[g];
    for (let v = 0; v <= i; v++) {
      const w = (v / i) * Math.PI * 2,
        M = Math.sin(w),
        C = -Math.cos(w);
      (a.x = C * b.x + M * x.x),
        (a.y = C * b.y + M * x.y),
        (a.z = C * b.z + M * x.z),
        a.normalize(),
        h.push(a.x, a.y, a.z),
        (o.x = l.x + n * a.x),
        (o.y = l.y + n * a.y),
        (o.z = l.z + n * a.z),
        u.push(o.x, o.y, o.z);
    }
  }
  function y() {
    for (let g = 1; g <= e; g++)
      for (let b = 1; b <= i; b++) {
        const x = (i + 1) * (g - 1) + (b - 1),
          v = (i + 1) * g + (b - 1),
          w = (i + 1) * g + b,
          M = (i + 1) * (g - 1) + b;
        f.push(x, v, M), f.push(v, w, M);
      }
  }
  function m() {
    for (let g = 0; g <= e; g++)
      for (let b = 0; b <= i; b++)
        (c.x = g / e), (c.y = b / i), d.push(c.x, c.y);
  }
}
Cs.prototype = Object.create(ct.prototype);
Cs.prototype.constructor = Cs;
Cs.prototype.toJSON = function () {
  const t = ct.prototype.toJSON.call(this);
  return (t.path = this.parameters.path.toJSON()), t;
};
function el(t, e, n, i, r, s, o) {
  Mt.call(this),
    (this.type = "TorusKnotGeometry"),
    (this.parameters = {
      radius: t,
      tube: e,
      tubularSegments: n,
      radialSegments: i,
      p: r,
      q: s,
    }),
    o !== void 0 &&
      console.warn(
        "THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."
      ),
    this.fromBufferGeometry(new qo(t, e, n, i, r, s)),
    this.mergeVertices();
}
el.prototype = Object.create(Mt.prototype);
el.prototype.constructor = el;
function qo(t, e, n, i, r, s) {
  ct.call(this),
    (this.type = "TorusKnotBufferGeometry"),
    (this.parameters = {
      radius: t,
      tube: e,
      tubularSegments: n,
      radialSegments: i,
      p: r,
      q: s,
    }),
    (t = t || 1),
    (e = e || 0.4),
    (n = Math.floor(n) || 64),
    (i = Math.floor(i) || 8),
    (r = r || 2),
    (s = s || 3);
  const o = [],
    a = [],
    c = [],
    l = [],
    u = new S(),
    h = new S(),
    d = new S(),
    f = new S(),
    p = new S(),
    _ = new S(),
    y = new S();
  for (let g = 0; g <= n; ++g) {
    const b = (g / n) * r * Math.PI * 2;
    m(b, r, s, t, d),
      m(b + 0.01, r, s, t, f),
      _.subVectors(f, d),
      y.addVectors(f, d),
      p.crossVectors(_, y),
      y.crossVectors(p, _),
      p.normalize(),
      y.normalize();
    for (let x = 0; x <= i; ++x) {
      const v = (x / i) * Math.PI * 2,
        w = -e * Math.cos(v),
        M = e * Math.sin(v);
      (u.x = d.x + (w * y.x + M * p.x)),
        (u.y = d.y + (w * y.y + M * p.y)),
        (u.z = d.z + (w * y.z + M * p.z)),
        a.push(u.x, u.y, u.z),
        h.subVectors(u, d).normalize(),
        c.push(h.x, h.y, h.z),
        l.push(g / n),
        l.push(x / i);
    }
  }
  for (let g = 1; g <= n; g++)
    for (let b = 1; b <= i; b++) {
      const x = (i + 1) * (g - 1) + (b - 1),
        v = (i + 1) * g + (b - 1),
        w = (i + 1) * g + b,
        M = (i + 1) * (g - 1) + b;
      o.push(x, v, M), o.push(v, w, M);
    }
  this.setIndex(o),
    this.setAttribute("position", new rt(a, 3)),
    this.setAttribute("normal", new rt(c, 3)),
    this.setAttribute("uv", new rt(l, 2));
  function m(g, b, x, v, w) {
    const M = Math.cos(g),
      C = Math.sin(g),
      A = (x / b) * g,
      U = Math.cos(A);
    (w.x = v * (2 + U) * 0.5 * M),
      (w.y = v * (2 + U) * C * 0.5),
      (w.z = v * Math.sin(A) * 0.5);
  }
}
qo.prototype = Object.create(ct.prototype);
qo.prototype.constructor = qo;
function nl(t, e, n, i, r) {
  Mt.call(this),
    (this.type = "TorusGeometry"),
    (this.parameters = {
      radius: t,
      tube: e,
      radialSegments: n,
      tubularSegments: i,
      arc: r,
    }),
    this.fromBufferGeometry(new Xo(t, e, n, i, r)),
    this.mergeVertices();
}
nl.prototype = Object.create(Mt.prototype);
nl.prototype.constructor = nl;
function Xo(t, e, n, i, r) {
  ct.call(this),
    (this.type = "TorusBufferGeometry"),
    (this.parameters = {
      radius: t,
      tube: e,
      radialSegments: n,
      tubularSegments: i,
      arc: r,
    }),
    (t = t || 1),
    (e = e || 0.4),
    (n = Math.floor(n) || 8),
    (i = Math.floor(i) || 6),
    (r = r || Math.PI * 2);
  const s = [],
    o = [],
    a = [],
    c = [],
    l = new S(),
    u = new S(),
    h = new S();
  for (let d = 0; d <= n; d++)
    for (let f = 0; f <= i; f++) {
      const p = (f / i) * r,
        _ = (d / n) * Math.PI * 2;
      (u.x = (t + e * Math.cos(_)) * Math.cos(p)),
        (u.y = (t + e * Math.cos(_)) * Math.sin(p)),
        (u.z = e * Math.sin(_)),
        o.push(u.x, u.y, u.z),
        (l.x = t * Math.cos(p)),
        (l.y = t * Math.sin(p)),
        h.subVectors(u, l).normalize(),
        a.push(h.x, h.y, h.z),
        c.push(f / i),
        c.push(d / n);
    }
  for (let d = 1; d <= n; d++)
    for (let f = 1; f <= i; f++) {
      const p = (i + 1) * d + f - 1,
        _ = (i + 1) * (d - 1) + f - 1,
        y = (i + 1) * (d - 1) + f,
        m = (i + 1) * d + f;
      s.push(p, _, m), s.push(_, y, m);
    }
  this.setIndex(s),
    this.setAttribute("position", new rt(o, 3)),
    this.setAttribute("normal", new rt(a, 3)),
    this.setAttribute("uv", new rt(c, 2));
}
Xo.prototype = Object.create(ct.prototype);
Xo.prototype.constructor = Xo;
const MM = {
  triangulate: function (t, e, n) {
    n = n || 2;
    let i = e && e.length,
      r = i ? e[0] * n : t.length,
      s = Bm(t, 0, r, n, !0),
      o = [];
    if (!s || s.next === s.prev) return o;
    let a, c, l, u, h, d, f;
    if ((i && (s = LM(t, e, s, n)), t.length > 80 * n)) {
      (a = l = t[0]), (c = u = t[1]);
      for (let p = n; p < r; p += n)
        (h = t[p]),
          (d = t[p + 1]),
          h < a && (a = h),
          d < c && (c = d),
          h > l && (l = h),
          d > u && (u = d);
      (f = Math.max(l - a, u - c)), (f = f !== 0 ? 1 / f : 0);
    }
    return Yo(s, o, n, a, c, f), o;
  },
};
function Bm(t, e, n, i, r) {
  let s, o;
  if (r === UM(t, e, n, i) > 0)
    for (s = e; s < n; s += i) o = km(s, t[s], t[s + 1], o);
  else for (s = n - i; s >= e; s -= i) o = km(s, t[s], t[s + 1], o);
  return o && il(o, o.next) && (Jo(o), (o = o.next)), o;
}
function Ui(t, e) {
  if (!t) return t;
  e || (e = t);
  let n = t,
    i;
  do
    if (
      ((i = !1), !n.steiner && (il(n, n.next) || re(n.prev, n, n.next) === 0))
    ) {
      if ((Jo(n), (n = e = n.prev), n === n.next)) break;
      i = !0;
    } else n = n.next;
  while (i || n !== e);
  return e;
}
function Yo(t, e, n, i, r, s, o) {
  if (!t) return;
  !o && s && DM(t, i, r, s);
  let a = t,
    c,
    l;
  for (; t.prev !== t.next; ) {
    if (((c = t.prev), (l = t.next), s ? TM(t, i, r, s) : SM(t))) {
      e.push(c.i / n),
        e.push(t.i / n),
        e.push(l.i / n),
        Jo(t),
        (t = l.next),
        (a = l.next);
      continue;
    }
    if (((t = l), t === a)) {
      o
        ? o === 1
          ? ((t = EM(Ui(t), e, n)), Yo(t, e, n, i, r, s, 2))
          : o === 2 && AM(t, e, n, i, r, s)
        : Yo(Ui(t), e, n, i, r, s, 1);
      break;
    }
  }
}
function SM(t) {
  let e = t.prev,
    n = t,
    i = t.next;
  if (re(e, n, i) >= 0) return !1;
  let r = t.next.next;
  for (; r !== t.prev; ) {
    if (
      Rs(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) &&
      re(r.prev, r, r.next) >= 0
    )
      return !1;
    r = r.next;
  }
  return !0;
}
function TM(t, e, n, i) {
  let r = t.prev,
    s = t,
    o = t.next;
  if (re(r, s, o) >= 0) return !1;
  let a = r.x < s.x ? (r.x < o.x ? r.x : o.x) : s.x < o.x ? s.x : o.x,
    c = r.y < s.y ? (r.y < o.y ? r.y : o.y) : s.y < o.y ? s.y : o.y,
    l = r.x > s.x ? (r.x > o.x ? r.x : o.x) : s.x > o.x ? s.x : o.x,
    u = r.y > s.y ? (r.y > o.y ? r.y : o.y) : s.y > o.y ? s.y : o.y,
    h = zh(a, c, e, n, i),
    d = zh(l, u, e, n, i),
    f = t.prevZ,
    p = t.nextZ;
  for (; f && f.z >= h && p && p.z <= d; ) {
    if (
      (f !== t.prev &&
        f !== t.next &&
        Rs(r.x, r.y, s.x, s.y, o.x, o.y, f.x, f.y) &&
        re(f.prev, f, f.next) >= 0) ||
      ((f = f.prevZ),
      p !== t.prev &&
        p !== t.next &&
        Rs(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) &&
        re(p.prev, p, p.next) >= 0)
    )
      return !1;
    p = p.nextZ;
  }
  for (; f && f.z >= h; ) {
    if (
      f !== t.prev &&
      f !== t.next &&
      Rs(r.x, r.y, s.x, s.y, o.x, o.y, f.x, f.y) &&
      re(f.prev, f, f.next) >= 0
    )
      return !1;
    f = f.prevZ;
  }
  for (; p && p.z <= d; ) {
    if (
      p !== t.prev &&
      p !== t.next &&
      Rs(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) &&
      re(p.prev, p, p.next) >= 0
    )
      return !1;
    p = p.nextZ;
  }
  return !0;
}
function EM(t, e, n) {
  let i = t;
  do {
    let r = i.prev,
      s = i.next.next;
    !il(r, s) &&
      zm(r, i, i.next, s) &&
      Zo(r, s) &&
      Zo(s, r) &&
      (e.push(r.i / n),
      e.push(i.i / n),
      e.push(s.i / n),
      Jo(i),
      Jo(i.next),
      (i = t = s)),
      (i = i.next);
  } while (i !== t);
  return Ui(i);
}
function AM(t, e, n, i, r, s) {
  let o = t;
  do {
    let a = o.next.next;
    for (; a !== o.prev; ) {
      if (o.i !== a.i && FM(o, a)) {
        let c = Um(o, a);
        (o = Ui(o, o.next)),
          (c = Ui(c, c.next)),
          Yo(o, e, n, i, r, s),
          Yo(c, e, n, i, r, s);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== t);
}
function LM(t, e, n, i) {
  let r = [],
    s,
    o,
    a,
    c,
    l;
  for (s = 0, o = e.length; s < o; s++)
    (a = e[s] * i),
      (c = s < o - 1 ? e[s + 1] * i : t.length),
      (l = Bm(t, a, c, i, !1)),
      l === l.next && (l.steiner = !0),
      r.push(NM(l));
  for (r.sort(PM), s = 0; s < r.length; s++) CM(r[s], n), (n = Ui(n, n.next));
  return n;
}
function PM(t, e) {
  return t.x - e.x;
}
function CM(t, e) {
  if (((e = RM(t, e)), e)) {
    const n = Um(e, t);
    Ui(e, e.next), Ui(n, n.next);
  }
}
function RM(t, e) {
  let n = e,
    i = t.x,
    r = t.y,
    s = -1 / 0,
    o;
  do {
    if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
      let d = n.x + ((r - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
      if (d <= i && d > s) {
        if (((s = d), d === i)) {
          if (r === n.y) return n;
          if (r === n.next.y) return n.next;
        }
        o = n.x < n.next.x ? n : n.next;
      }
    }
    n = n.next;
  } while (n !== e);
  if (!o) return null;
  if (i === s) return o;
  let a = o,
    c = o.x,
    l = o.y,
    u = 1 / 0,
    h;
  n = o;
  do
    i >= n.x &&
      n.x >= c &&
      i !== n.x &&
      Rs(r < l ? i : s, r, c, l, r < l ? s : i, r, n.x, n.y) &&
      ((h = Math.abs(r - n.y) / (i - n.x)),
      Zo(n, t) &&
        (h < u || (h === u && (n.x > o.x || (n.x === o.x && OM(o, n))))) &&
        ((o = n), (u = h))),
      (n = n.next);
  while (n !== a);
  return o;
}
function OM(t, e) {
  return re(t.prev, t, e.prev) < 0 && re(e.next, t, t.next) < 0;
}
function DM(t, e, n, i) {
  let r = t;
  do
    r.z === null && (r.z = zh(r.x, r.y, e, n, i)),
      (r.prevZ = r.prev),
      (r.nextZ = r.next),
      (r = r.next);
  while (r !== t);
  (r.prevZ.nextZ = null), (r.prevZ = null), IM(r);
}
function IM(t) {
  let e,
    n,
    i,
    r,
    s,
    o,
    a,
    c,
    l = 1;
  do {
    for (n = t, t = null, s = null, o = 0; n; ) {
      for (o++, i = n, a = 0, e = 0; e < l && (a++, (i = i.nextZ), !!i); e++);
      for (c = l; a > 0 || (c > 0 && i); )
        a !== 0 && (c === 0 || !i || n.z <= i.z)
          ? ((r = n), (n = n.nextZ), a--)
          : ((r = i), (i = i.nextZ), c--),
          s ? (s.nextZ = r) : (t = r),
          (r.prevZ = s),
          (s = r);
      n = i;
    }
    (s.nextZ = null), (l *= 2);
  } while (o > 1);
  return t;
}
function zh(t, e, n, i, r) {
  return (
    (t = 32767 * (t - n) * r),
    (e = 32767 * (e - i) * r),
    (t = (t | (t << 8)) & 16711935),
    (t = (t | (t << 4)) & 252645135),
    (t = (t | (t << 2)) & 858993459),
    (t = (t | (t << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    t | (e << 1)
  );
}
function NM(t) {
  let e = t,
    n = t;
  do (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
  while (e !== t);
  return n;
}
function Rs(t, e, n, i, r, s, o, a) {
  return (
    (r - o) * (e - a) - (t - o) * (s - a) >= 0 &&
    (t - o) * (i - a) - (n - o) * (e - a) >= 0 &&
    (n - o) * (s - a) - (r - o) * (i - a) >= 0
  );
}
function FM(t, e) {
  return (
    t.next.i !== e.i &&
    t.prev.i !== e.i &&
    !BM(t, e) &&
    ((Zo(t, e) &&
      Zo(e, t) &&
      zM(t, e) &&
      (re(t.prev, t, e.prev) || re(t, e.prev, e))) ||
      (il(t, e) && re(t.prev, t, t.next) > 0 && re(e.prev, e, e.next) > 0))
  );
}
function re(t, e, n) {
  return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
}
function il(t, e) {
  return t.x === e.x && t.y === e.y;
}
function zm(t, e, n, i) {
  const r = sl(re(t, e, n)),
    s = sl(re(t, e, i)),
    o = sl(re(n, i, t)),
    a = sl(re(n, i, e));
  return !!(
    (r !== s && o !== a) ||
    (r === 0 && rl(t, n, e)) ||
    (s === 0 && rl(t, i, e)) ||
    (o === 0 && rl(n, t, i)) ||
    (a === 0 && rl(n, e, i))
  );
}
function rl(t, e, n) {
  return (
    e.x <= Math.max(t.x, n.x) &&
    e.x >= Math.min(t.x, n.x) &&
    e.y <= Math.max(t.y, n.y) &&
    e.y >= Math.min(t.y, n.y)
  );
}
function sl(t) {
  return t > 0 ? 1 : t < 0 ? -1 : 0;
}
function BM(t, e) {
  let n = t;
  do {
    if (
      n.i !== t.i &&
      n.next.i !== t.i &&
      n.i !== e.i &&
      n.next.i !== e.i &&
      zm(n, n.next, t, e)
    )
      return !0;
    n = n.next;
  } while (n !== t);
  return !1;
}
function Zo(t, e) {
  return re(t.prev, t, t.next) < 0
    ? re(t, e, t.next) >= 0 && re(t, t.prev, e) >= 0
    : re(t, e, t.prev) < 0 || re(t, t.next, e) < 0;
}
function zM(t, e) {
  let n = t,
    i = !1,
    r = (t.x + e.x) / 2,
    s = (t.y + e.y) / 2;
  do
    n.y > s != n.next.y > s &&
      n.next.y !== n.y &&
      r < ((n.next.x - n.x) * (s - n.y)) / (n.next.y - n.y) + n.x &&
      (i = !i),
      (n = n.next);
  while (n !== t);
  return i;
}
function Um(t, e) {
  let n = new Uh(t.i, t.x, t.y),
    i = new Uh(e.i, e.x, e.y),
    r = t.next,
    s = e.prev;
  return (
    (t.next = e),
    (e.prev = t),
    (n.next = r),
    (r.prev = n),
    (i.next = n),
    (n.prev = i),
    (s.next = i),
    (i.prev = s),
    i
  );
}
function km(t, e, n, i) {
  const r = new Uh(t, e, n);
  return (
    i
      ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
      : ((r.prev = r), (r.next = r)),
    r
  );
}
function Jo(t) {
  (t.next.prev = t.prev),
    (t.prev.next = t.next),
    t.prevZ && (t.prevZ.nextZ = t.nextZ),
    t.nextZ && (t.nextZ.prevZ = t.prevZ);
}
function Uh(t, e, n) {
  (this.i = t),
    (this.x = e),
    (this.y = n),
    (this.prev = null),
    (this.next = null),
    (this.z = null),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function UM(t, e, n, i) {
  let r = 0;
  for (let s = e, o = n - i; s < n; s += i)
    (r += (t[o] - t[s]) * (t[s + 1] + t[o + 1])), (o = s);
  return r;
}
const ki = {
  area: function (t) {
    const e = t.length;
    let n = 0;
    for (let i = e - 1, r = 0; r < e; i = r++)
      n += t[i].x * t[r].y - t[r].x * t[i].y;
    return n * 0.5;
  },
  isClockWise: function (t) {
    return ki.area(t) < 0;
  },
  triangulateShape: function (t, e) {
    const n = [],
      i = [],
      r = [];
    Gm(t), Hm(n, t);
    let s = t.length;
    e.forEach(Gm);
    for (let a = 0; a < e.length; a++)
      i.push(s), (s += e[a].length), Hm(n, e[a]);
    const o = MM.triangulate(n, i);
    for (let a = 0; a < o.length; a += 3) r.push(o.slice(a, a + 3));
    return r;
  },
};
function Gm(t) {
  const e = t.length;
  e > 2 && t[e - 1].equals(t[0]) && t.pop();
}
function Hm(t, e) {
  for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
}
function Os(t, e) {
  Mt.call(this),
    (this.type = "ExtrudeGeometry"),
    (this.parameters = { shapes: t, options: e }),
    this.fromBufferGeometry(new pi(t, e)),
    this.mergeVertices();
}
Os.prototype = Object.create(Mt.prototype);
Os.prototype.constructor = Os;
Os.prototype.toJSON = function () {
  const t = Mt.prototype.toJSON.call(this),
    e = this.parameters.shapes,
    n = this.parameters.options;
  return Vm(e, n, t);
};
function pi(t, e) {
  ct.call(this),
    (this.type = "ExtrudeBufferGeometry"),
    (this.parameters = { shapes: t, options: e }),
    (t = Array.isArray(t) ? t : [t]);
  const n = this,
    i = [],
    r = [];
  for (let o = 0, a = t.length; o < a; o++) {
    const c = t[o];
    s(c);
  }
  this.setAttribute("position", new rt(i, 3)),
    this.setAttribute("uv", new rt(r, 2)),
    this.computeVertexNormals();
  function s(o) {
    const a = [],
      c = e.curveSegments !== void 0 ? e.curveSegments : 12,
      l = e.steps !== void 0 ? e.steps : 1;
    let u = e.depth !== void 0 ? e.depth : 100,
      h = e.bevelEnabled !== void 0 ? e.bevelEnabled : !0,
      d = e.bevelThickness !== void 0 ? e.bevelThickness : 6,
      f = e.bevelSize !== void 0 ? e.bevelSize : d - 2,
      p = e.bevelOffset !== void 0 ? e.bevelOffset : 0,
      _ = e.bevelSegments !== void 0 ? e.bevelSegments : 3;
    const y = e.extrudePath,
      m = e.UVGenerator !== void 0 ? e.UVGenerator : kM;
    e.amount !== void 0 &&
      (console.warn(
        "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
      ),
      (u = e.amount));
    let g,
      b = !1,
      x,
      v,
      w,
      M;
    y &&
      ((g = y.getSpacedPoints(l)),
      (b = !0),
      (h = !1),
      (x = y.computeFrenetFrames(l, !1)),
      (v = new S()),
      (w = new S()),
      (M = new S())),
      h || ((_ = 0), (d = 0), (f = 0), (p = 0));
    const C = o.extractPoints(c);
    let A = C.shape;
    const U = C.holes;
    if (!ki.isClockWise(A)) {
      A = A.reverse();
      for (let j = 0, q = U.length; j < q; j++) {
        const X = U[j];
        ki.isClockWise(X) && (U[j] = X.reverse());
      }
    }
    const B = ki.triangulateShape(A, U),
      F = A;
    for (let j = 0, q = U.length; j < q; j++) {
      const X = U[j];
      A = A.concat(X);
    }
    function O(j, q, X) {
      return (
        q || console.error("THREE.ExtrudeGeometry: vec does not exist"),
        q.clone().multiplyScalar(X).add(j)
      );
    }
    const R = A.length,
      P = B.length;
    function V(j, q, X) {
      let ht, ot, Tt;
      const T = j.x - q.x,
        L = j.y - q.y,
        Z = X.x - j.x,
        W = X.y - j.y,
        D = T * T + L * L,
        J = T * W - L * Z;
      if (Math.abs(J) > Number.EPSILON) {
        const Q = Math.sqrt(D),
          gt = Math.sqrt(Z * Z + W * W),
          $ = q.x - L / Q,
          at = q.y + T / Q,
          Et = X.x - W / gt,
          xt = X.y + Z / gt,
          ft = ((Et - $) * W - (xt - at) * Z) / (T * W - L * Z);
        (ht = $ + T * ft - j.x), (ot = at + L * ft - j.y);
        const dt = ht * ht + ot * ot;
        if (dt <= 2) return new H(ht, ot);
        Tt = Math.sqrt(dt / 2);
      } else {
        let Q = !1;
        T > Number.EPSILON
          ? Z > Number.EPSILON && (Q = !0)
          : T < -Number.EPSILON
          ? Z < -Number.EPSILON && (Q = !0)
          : Math.sign(L) === Math.sign(W) && (Q = !0),
          Q
            ? ((ht = -L), (ot = T), (Tt = Math.sqrt(D)))
            : ((ht = T), (ot = L), (Tt = Math.sqrt(D / 2)));
      }
      return new H(ht / Tt, ot / Tt);
    }
    const Y = [];
    for (let j = 0, q = F.length, X = q - 1, ht = j + 1; j < q; j++, X++, ht++)
      X === q && (X = 0), ht === q && (ht = 0), (Y[j] = V(F[j], F[X], F[ht]));
    const K = [];
    let it,
      et = Y.concat();
    for (let j = 0, q = U.length; j < q; j++) {
      const X = U[j];
      it = [];
      for (
        let ht = 0, ot = X.length, Tt = ot - 1, T = ht + 1;
        ht < ot;
        ht++, Tt++, T++
      )
        Tt === ot && (Tt = 0),
          T === ot && (T = 0),
          (it[ht] = V(X[ht], X[Tt], X[T]));
      K.push(it), (et = et.concat(it));
    }
    for (let j = 0; j < _; j++) {
      const q = j / _,
        X = d * Math.cos((q * Math.PI) / 2),
        ht = f * Math.sin((q * Math.PI) / 2) + p;
      for (let ot = 0, Tt = F.length; ot < Tt; ot++) {
        const T = O(F[ot], Y[ot], ht);
        G(T.x, T.y, -X);
      }
      for (let ot = 0, Tt = U.length; ot < Tt; ot++) {
        const T = U[ot];
        it = K[ot];
        for (let L = 0, Z = T.length; L < Z; L++) {
          const W = O(T[L], it[L], ht);
          G(W.x, W.y, -X);
        }
      }
    }
    const Ct = f + p;
    for (let j = 0; j < R; j++) {
      const q = h ? O(A[j], et[j], Ct) : A[j];
      b
        ? (w.copy(x.normals[0]).multiplyScalar(q.x),
          v.copy(x.binormals[0]).multiplyScalar(q.y),
          M.copy(g[0]).add(w).add(v),
          G(M.x, M.y, M.z))
        : G(q.x, q.y, 0);
    }
    for (let j = 1; j <= l; j++)
      for (let q = 0; q < R; q++) {
        const X = h ? O(A[q], et[q], Ct) : A[q];
        b
          ? (w.copy(x.normals[j]).multiplyScalar(X.x),
            v.copy(x.binormals[j]).multiplyScalar(X.y),
            M.copy(g[j]).add(w).add(v),
            G(M.x, M.y, M.z))
          : G(X.x, X.y, (u / l) * j);
      }
    for (let j = _ - 1; j >= 0; j--) {
      const q = j / _,
        X = d * Math.cos((q * Math.PI) / 2),
        ht = f * Math.sin((q * Math.PI) / 2) + p;
      for (let ot = 0, Tt = F.length; ot < Tt; ot++) {
        const T = O(F[ot], Y[ot], ht);
        G(T.x, T.y, u + X);
      }
      for (let ot = 0, Tt = U.length; ot < Tt; ot++) {
        const T = U[ot];
        it = K[ot];
        for (let L = 0, Z = T.length; L < Z; L++) {
          const W = O(T[L], it[L], ht);
          b ? G(W.x, W.y + g[l - 1].y, g[l - 1].x + X) : G(W.x, W.y, u + X);
        }
      }
    }
    mt(), Nt();
    function mt() {
      const j = i.length / 3;
      if (h) {
        let q = 0,
          X = R * q;
        for (let ht = 0; ht < P; ht++) {
          const ot = B[ht];
          kt(ot[2] + X, ot[1] + X, ot[0] + X);
        }
        (q = l + _ * 2), (X = R * q);
        for (let ht = 0; ht < P; ht++) {
          const ot = B[ht];
          kt(ot[0] + X, ot[1] + X, ot[2] + X);
        }
      } else {
        for (let q = 0; q < P; q++) {
          const X = B[q];
          kt(X[2], X[1], X[0]);
        }
        for (let q = 0; q < P; q++) {
          const X = B[q];
          kt(X[0] + R * l, X[1] + R * l, X[2] + R * l);
        }
      }
      n.addGroup(j, i.length / 3 - j, 0);
    }
    function Nt() {
      const j = i.length / 3;
      let q = 0;
      Ot(F, q), (q += F.length);
      for (let X = 0, ht = U.length; X < ht; X++) {
        const ot = U[X];
        Ot(ot, q), (q += ot.length);
      }
      n.addGroup(j, i.length / 3 - j, 1);
    }
    function Ot(j, q) {
      let X = j.length;
      for (; --X >= 0; ) {
        const ht = X;
        let ot = X - 1;
        ot < 0 && (ot = j.length - 1);
        for (let Tt = 0, T = l + _ * 2; Tt < T; Tt++) {
          const L = R * Tt,
            Z = R * (Tt + 1),
            W = q + ht + L,
            D = q + ot + L,
            J = q + ot + Z,
            Q = q + ht + Z;
          vt(W, D, J, Q);
        }
      }
    }
    function G(j, q, X) {
      a.push(j), a.push(q), a.push(X);
    }
    function kt(j, q, X) {
      St(j), St(q), St(X);
      const ht = i.length / 3,
        ot = m.generateTopUV(n, i, ht - 3, ht - 2, ht - 1);
      yt(ot[0]), yt(ot[1]), yt(ot[2]);
    }
    function vt(j, q, X, ht) {
      St(j), St(q), St(ht), St(q), St(X), St(ht);
      const ot = i.length / 3,
        Tt = m.generateSideWallUV(n, i, ot - 6, ot - 3, ot - 2, ot - 1);
      yt(Tt[0]), yt(Tt[1]), yt(Tt[3]), yt(Tt[1]), yt(Tt[2]), yt(Tt[3]);
    }
    function St(j) {
      i.push(a[j * 3 + 0]), i.push(a[j * 3 + 1]), i.push(a[j * 3 + 2]);
    }
    function yt(j) {
      r.push(j.x), r.push(j.y);
    }
  }
}
pi.prototype = Object.create(ct.prototype);
pi.prototype.constructor = pi;
pi.prototype.toJSON = function () {
  const t = ct.prototype.toJSON.call(this),
    e = this.parameters.shapes,
    n = this.parameters.options;
  return Vm(e, n, t);
};
const kM = {
  generateTopUV: function (t, e, n, i, r) {
    const s = e[n * 3],
      o = e[n * 3 + 1],
      a = e[i * 3],
      c = e[i * 3 + 1],
      l = e[r * 3],
      u = e[r * 3 + 1];
    return [new H(s, o), new H(a, c), new H(l, u)];
  },
  generateSideWallUV: function (t, e, n, i, r, s) {
    const o = e[n * 3],
      a = e[n * 3 + 1],
      c = e[n * 3 + 2],
      l = e[i * 3],
      u = e[i * 3 + 1],
      h = e[i * 3 + 2],
      d = e[r * 3],
      f = e[r * 3 + 1],
      p = e[r * 3 + 2],
      _ = e[s * 3],
      y = e[s * 3 + 1],
      m = e[s * 3 + 2];
    return Math.abs(a - u) < 0.01
      ? [new H(o, 1 - c), new H(l, 1 - h), new H(d, 1 - p), new H(_, 1 - m)]
      : [new H(a, 1 - c), new H(u, 1 - h), new H(f, 1 - p), new H(y, 1 - m)];
  },
};
function Vm(t, e, n) {
  if (((n.shapes = []), Array.isArray(t)))
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      n.shapes.push(s.uuid);
    }
  else n.shapes.push(t.uuid);
  return (
    e.extrudePath !== void 0 &&
      (n.options.extrudePath = e.extrudePath.toJSON()),
    n
  );
}
function ol(t, e) {
  Mt.call(this),
    (this.type = "TextGeometry"),
    (this.parameters = { text: t, parameters: e }),
    this.fromBufferGeometry(new $o(t, e)),
    this.mergeVertices();
}
ol.prototype = Object.create(Mt.prototype);
ol.prototype.constructor = ol;
function $o(t, e) {
  e = e || {};
  const n = e.font;
  if (!(n && n.isFont))
    return (
      console.error(
        "THREE.TextGeometry: font parameter is not an instance of THREE.Font."
      ),
      new Mt()
    );
  const i = n.generateShapes(t, e.size);
  (e.depth = e.height !== void 0 ? e.height : 50),
    e.bevelThickness === void 0 && (e.bevelThickness = 10),
    e.bevelSize === void 0 && (e.bevelSize = 8),
    e.bevelEnabled === void 0 && (e.bevelEnabled = !1),
    pi.call(this, i, e),
    (this.type = "TextBufferGeometry");
}
$o.prototype = Object.create(pi.prototype);
$o.prototype.constructor = $o;
function al(t, e, n, i, r, s, o) {
  Mt.call(this),
    (this.type = "SphereGeometry"),
    (this.parameters = {
      radius: t,
      widthSegments: e,
      heightSegments: n,
      phiStart: i,
      phiLength: r,
      thetaStart: s,
      thetaLength: o,
    }),
    this.fromBufferGeometry(new Ds(t, e, n, i, r, s, o)),
    this.mergeVertices();
}
al.prototype = Object.create(Mt.prototype);
al.prototype.constructor = al;
function Ds(t, e, n, i, r, s, o) {
  ct.call(this),
    (this.type = "SphereBufferGeometry"),
    (this.parameters = {
      radius: t,
      widthSegments: e,
      heightSegments: n,
      phiStart: i,
      phiLength: r,
      thetaStart: s,
      thetaLength: o,
    }),
    (t = t || 1),
    (e = Math.max(3, Math.floor(e) || 8)),
    (n = Math.max(2, Math.floor(n) || 6)),
    (i = i !== void 0 ? i : 0),
    (r = r !== void 0 ? r : Math.PI * 2),
    (s = s !== void 0 ? s : 0),
    (o = o !== void 0 ? o : Math.PI);
  const a = Math.min(s + o, Math.PI);
  let c = 0;
  const l = [],
    u = new S(),
    h = new S(),
    d = [],
    f = [],
    p = [],
    _ = [];
  for (let y = 0; y <= n; y++) {
    const m = [],
      g = y / n;
    let b = 0;
    y == 0 && s == 0 ? (b = 0.5 / e) : y == n && a == Math.PI && (b = -0.5 / e);
    for (let x = 0; x <= e; x++) {
      const v = x / e;
      (u.x = -t * Math.cos(i + v * r) * Math.sin(s + g * o)),
        (u.y = t * Math.cos(s + g * o)),
        (u.z = t * Math.sin(i + v * r) * Math.sin(s + g * o)),
        f.push(u.x, u.y, u.z),
        h.copy(u).normalize(),
        p.push(h.x, h.y, h.z),
        _.push(v + b, 1 - g),
        m.push(c++);
    }
    l.push(m);
  }
  for (let y = 0; y < n; y++)
    for (let m = 0; m < e; m++) {
      const g = l[y][m + 1],
        b = l[y][m],
        x = l[y + 1][m],
        v = l[y + 1][m + 1];
      (y !== 0 || s > 0) && d.push(g, b, v),
        (y !== n - 1 || a < Math.PI) && d.push(b, x, v);
    }
  this.setIndex(d),
    this.setAttribute("position", new rt(f, 3)),
    this.setAttribute("normal", new rt(p, 3)),
    this.setAttribute("uv", new rt(_, 2));
}
Ds.prototype = Object.create(ct.prototype);
Ds.prototype.constructor = Ds;
function cl(t, e, n, i, r, s) {
  Mt.call(this),
    (this.type = "RingGeometry"),
    (this.parameters = {
      innerRadius: t,
      outerRadius: e,
      thetaSegments: n,
      phiSegments: i,
      thetaStart: r,
      thetaLength: s,
    }),
    this.fromBufferGeometry(new Qo(t, e, n, i, r, s)),
    this.mergeVertices();
}
cl.prototype = Object.create(Mt.prototype);
cl.prototype.constructor = cl;
function Qo(t, e, n, i, r, s) {
  ct.call(this),
    (this.type = "RingBufferGeometry"),
    (this.parameters = {
      innerRadius: t,
      outerRadius: e,
      thetaSegments: n,
      phiSegments: i,
      thetaStart: r,
      thetaLength: s,
    }),
    (t = t || 0.5),
    (e = e || 1),
    (r = r !== void 0 ? r : 0),
    (s = s !== void 0 ? s : Math.PI * 2),
    (n = n !== void 0 ? Math.max(3, n) : 8),
    (i = i !== void 0 ? Math.max(1, i) : 1);
  const o = [],
    a = [],
    c = [],
    l = [];
  let u = t;
  const h = (e - t) / i,
    d = new S(),
    f = new H();
  for (let p = 0; p <= i; p++) {
    for (let _ = 0; _ <= n; _++) {
      const y = r + (_ / n) * s;
      (d.x = u * Math.cos(y)),
        (d.y = u * Math.sin(y)),
        a.push(d.x, d.y, d.z),
        c.push(0, 0, 1),
        (f.x = (d.x / e + 1) / 2),
        (f.y = (d.y / e + 1) / 2),
        l.push(f.x, f.y);
    }
    u += h;
  }
  for (let p = 0; p < i; p++) {
    const _ = p * (n + 1);
    for (let y = 0; y < n; y++) {
      const m = y + _,
        g = m,
        b = m + n + 1,
        x = m + n + 2,
        v = m + 1;
      o.push(g, b, v), o.push(b, x, v);
    }
  }
  this.setIndex(o),
    this.setAttribute("position", new rt(a, 3)),
    this.setAttribute("normal", new rt(c, 3)),
    this.setAttribute("uv", new rt(l, 2));
}
Qo.prototype = Object.create(ct.prototype);
Qo.prototype.constructor = Qo;
function ll(t, e, n, i) {
  Mt.call(this),
    (this.type = "LatheGeometry"),
    (this.parameters = { points: t, segments: e, phiStart: n, phiLength: i }),
    this.fromBufferGeometry(new Ko(t, e, n, i)),
    this.mergeVertices();
}
ll.prototype = Object.create(Mt.prototype);
ll.prototype.constructor = ll;
function Ko(t, e, n, i) {
  ct.call(this),
    (this.type = "LatheBufferGeometry"),
    (this.parameters = { points: t, segments: e, phiStart: n, phiLength: i }),
    (e = Math.floor(e) || 12),
    (n = n || 0),
    (i = i || Math.PI * 2),
    (i = Pt.clamp(i, 0, Math.PI * 2));
  const r = [],
    s = [],
    o = [],
    a = 1 / e,
    c = new S(),
    l = new H();
  for (let u = 0; u <= e; u++) {
    const h = n + u * a * i,
      d = Math.sin(h),
      f = Math.cos(h);
    for (let p = 0; p <= t.length - 1; p++)
      (c.x = t[p].x * d),
        (c.y = t[p].y),
        (c.z = t[p].x * f),
        s.push(c.x, c.y, c.z),
        (l.x = u / e),
        (l.y = p / (t.length - 1)),
        o.push(l.x, l.y);
  }
  for (let u = 0; u < e; u++)
    for (let h = 0; h < t.length - 1; h++) {
      const d = h + u * t.length,
        f = d,
        p = d + t.length,
        _ = d + t.length + 1,
        y = d + 1;
      r.push(f, p, y), r.push(p, _, y);
    }
  if (
    (this.setIndex(r),
    this.setAttribute("position", new rt(s, 3)),
    this.setAttribute("uv", new rt(o, 2)),
    this.computeVertexNormals(),
    i === Math.PI * 2)
  ) {
    const u = this.attributes.normal.array,
      h = new S(),
      d = new S(),
      f = new S(),
      p = e * t.length * 3;
    for (let _ = 0, y = 0; _ < t.length; _++, y += 3)
      (h.x = u[y + 0]),
        (h.y = u[y + 1]),
        (h.z = u[y + 2]),
        (d.x = u[p + y + 0]),
        (d.y = u[p + y + 1]),
        (d.z = u[p + y + 2]),
        f.addVectors(h, d).normalize(),
        (u[y + 0] = u[p + y + 0] = f.x),
        (u[y + 1] = u[p + y + 1] = f.y),
        (u[y + 2] = u[p + y + 2] = f.z);
  }
}
Ko.prototype = Object.create(ct.prototype);
Ko.prototype.constructor = Ko;
function Is(t, e) {
  Mt.call(this),
    (this.type = "ShapeGeometry"),
    typeof e == "object" &&
      (console.warn("THREE.ShapeGeometry: Options parameter has been removed."),
      (e = e.curveSegments)),
    (this.parameters = { shapes: t, curveSegments: e }),
    this.fromBufferGeometry(new Ns(t, e)),
    this.mergeVertices();
}
Is.prototype = Object.create(Mt.prototype);
Is.prototype.constructor = Is;
Is.prototype.toJSON = function () {
  const t = Mt.prototype.toJSON.call(this),
    e = this.parameters.shapes;
  return Wm(e, t);
};
function Ns(t, e) {
  ct.call(this),
    (this.type = "ShapeBufferGeometry"),
    (this.parameters = { shapes: t, curveSegments: e }),
    (e = e || 12);
  const n = [],
    i = [],
    r = [],
    s = [];
  let o = 0,
    a = 0;
  if (Array.isArray(t) === !1) c(t);
  else
    for (let l = 0; l < t.length; l++)
      c(t[l]), this.addGroup(o, a, l), (o += a), (a = 0);
  this.setIndex(n),
    this.setAttribute("position", new rt(i, 3)),
    this.setAttribute("normal", new rt(r, 3)),
    this.setAttribute("uv", new rt(s, 2));
  function c(l) {
    const u = i.length / 3,
      h = l.extractPoints(e);
    let d = h.shape;
    const f = h.holes;
    ki.isClockWise(d) === !1 && (d = d.reverse());
    for (let _ = 0, y = f.length; _ < y; _++) {
      const m = f[_];
      ki.isClockWise(m) === !0 && (f[_] = m.reverse());
    }
    const p = ki.triangulateShape(d, f);
    for (let _ = 0, y = f.length; _ < y; _++) {
      const m = f[_];
      d = d.concat(m);
    }
    for (let _ = 0, y = d.length; _ < y; _++) {
      const m = d[_];
      i.push(m.x, m.y, 0), r.push(0, 0, 1), s.push(m.x, m.y);
    }
    for (let _ = 0, y = p.length; _ < y; _++) {
      const m = p[_],
        g = m[0] + u,
        b = m[1] + u,
        x = m[2] + u;
      n.push(g, b, x), (a += 3);
    }
  }
}
Ns.prototype = Object.create(ct.prototype);
Ns.prototype.constructor = Ns;
Ns.prototype.toJSON = function () {
  const t = ct.prototype.toJSON.call(this),
    e = this.parameters.shapes;
  return Wm(e, t);
};
function Wm(t, e) {
  if (((e.shapes = []), Array.isArray(t)))
    for (let n = 0, i = t.length; n < i; n++) {
      const r = t[n];
      e.shapes.push(r.uuid);
    }
  else e.shapes.push(t.uuid);
  return e;
}
function ul(t, e) {
  ct.call(this),
    (this.type = "EdgesGeometry"),
    (this.parameters = { thresholdAngle: e }),
    (e = e !== void 0 ? e : 1);
  const n = [],
    i = Math.cos(Pt.DEG2RAD * e),
    r = [0, 0],
    s = {};
  let o, a, c;
  const l = ["a", "b", "c"];
  let u;
  t.isBufferGeometry
    ? ((u = new Mt()), u.fromBufferGeometry(t))
    : (u = t.clone()),
    u.mergeVertices(),
    u.computeFaceNormals();
  const h = u.vertices,
    d = u.faces;
  for (let f = 0, p = d.length; f < p; f++) {
    const _ = d[f];
    for (let y = 0; y < 3; y++)
      (o = _[l[y]]),
        (a = _[l[(y + 1) % 3]]),
        (r[0] = Math.min(o, a)),
        (r[1] = Math.max(o, a)),
        (c = r[0] + "," + r[1]),
        s[c] === void 0
          ? (s[c] = { index1: r[0], index2: r[1], face1: f, face2: void 0 })
          : (s[c].face2 = f);
  }
  for (c in s) {
    const f = s[c];
    if (f.face2 === void 0 || d[f.face1].normal.dot(d[f.face2].normal) <= i) {
      let p = h[f.index1];
      n.push(p.x, p.y, p.z), (p = h[f.index2]), n.push(p.x, p.y, p.z);
    }
  }
  this.setAttribute("position", new rt(n, 3));
}
ul.prototype = Object.create(ct.prototype);
ul.prototype.constructor = ul;
function Fs(t, e, n, i, r, s, o, a) {
  Mt.call(this),
    (this.type = "CylinderGeometry"),
    (this.parameters = {
      radiusTop: t,
      radiusBottom: e,
      height: n,
      radialSegments: i,
      heightSegments: r,
      openEnded: s,
      thetaStart: o,
      thetaLength: a,
    }),
    this.fromBufferGeometry(new Gi(t, e, n, i, r, s, o, a)),
    this.mergeVertices();
}
Fs.prototype = Object.create(Mt.prototype);
Fs.prototype.constructor = Fs;
function Gi(t, e, n, i, r, s, o, a) {
  ct.call(this),
    (this.type = "CylinderBufferGeometry"),
    (this.parameters = {
      radiusTop: t,
      radiusBottom: e,
      height: n,
      radialSegments: i,
      heightSegments: r,
      openEnded: s,
      thetaStart: o,
      thetaLength: a,
    });
  const c = this;
  (t = t !== void 0 ? t : 1),
    (e = e !== void 0 ? e : 1),
    (n = n || 1),
    (i = Math.floor(i) || 8),
    (r = Math.floor(r) || 1),
    (s = s !== void 0 ? s : !1),
    (o = o !== void 0 ? o : 0),
    (a = a !== void 0 ? a : Math.PI * 2);
  const l = [],
    u = [],
    h = [],
    d = [];
  let f = 0;
  const p = [],
    _ = n / 2;
  let y = 0;
  m(),
    s === !1 && (t > 0 && g(!0), e > 0 && g(!1)),
    this.setIndex(l),
    this.setAttribute("position", new rt(u, 3)),
    this.setAttribute("normal", new rt(h, 3)),
    this.setAttribute("uv", new rt(d, 2));
  function m() {
    const b = new S(),
      x = new S();
    let v = 0;
    const w = (e - t) / n;
    for (let M = 0; M <= r; M++) {
      const C = [],
        A = M / r,
        U = A * (e - t) + t;
      for (let I = 0; I <= i; I++) {
        const B = I / i,
          F = B * a + o,
          O = Math.sin(F),
          R = Math.cos(F);
        (x.x = U * O),
          (x.y = -A * n + _),
          (x.z = U * R),
          u.push(x.x, x.y, x.z),
          b.set(O, w, R).normalize(),
          h.push(b.x, b.y, b.z),
          d.push(B, 1 - A),
          C.push(f++);
      }
      p.push(C);
    }
    for (let M = 0; M < i; M++)
      for (let C = 0; C < r; C++) {
        const A = p[C][M],
          U = p[C + 1][M],
          I = p[C + 1][M + 1],
          B = p[C][M + 1];
        l.push(A, U, B), l.push(U, I, B), (v += 6);
      }
    c.addGroup(y, v, 0), (y += v);
  }
  function g(b) {
    let x, v;
    const w = new H(),
      M = new S();
    let C = 0;
    const A = b === !0 ? t : e,
      U = b === !0 ? 1 : -1;
    x = f;
    for (let I = 1; I <= i; I++)
      u.push(0, _ * U, 0), h.push(0, U, 0), d.push(0.5, 0.5), f++;
    v = f;
    for (let I = 0; I <= i; I++) {
      const F = (I / i) * a + o,
        O = Math.cos(F),
        R = Math.sin(F);
      (M.x = A * R),
        (M.y = _ * U),
        (M.z = A * O),
        u.push(M.x, M.y, M.z),
        h.push(0, U, 0),
        (w.x = O * 0.5 + 0.5),
        (w.y = R * 0.5 * U + 0.5),
        d.push(w.x, w.y),
        f++;
    }
    for (let I = 0; I < i; I++) {
      const B = x + I,
        F = v + I;
      b === !0 ? l.push(F, F + 1, B) : l.push(F + 1, F, B), (C += 3);
    }
    c.addGroup(y, C, b === !0 ? 1 : 2), (y += C);
  }
}
Gi.prototype = Object.create(ct.prototype);
Gi.prototype.constructor = Gi;
function hl(t, e, n, i, r, s, o) {
  Fs.call(this, 0, t, e, n, i, r, s, o),
    (this.type = "ConeGeometry"),
    (this.parameters = {
      radius: t,
      height: e,
      radialSegments: n,
      heightSegments: i,
      openEnded: r,
      thetaStart: s,
      thetaLength: o,
    });
}
hl.prototype = Object.create(Fs.prototype);
hl.prototype.constructor = hl;
function fl(t, e, n, i, r, s, o) {
  Gi.call(this, 0, t, e, n, i, r, s, o),
    (this.type = "ConeBufferGeometry"),
    (this.parameters = {
      radius: t,
      height: e,
      radialSegments: n,
      heightSegments: i,
      openEnded: r,
      thetaStart: s,
      thetaLength: o,
    });
}
fl.prototype = Object.create(Gi.prototype);
fl.prototype.constructor = fl;
function dl(t, e, n, i) {
  Mt.call(this),
    (this.type = "CircleGeometry"),
    (this.parameters = {
      radius: t,
      segments: e,
      thetaStart: n,
      thetaLength: i,
    }),
    this.fromBufferGeometry(new ta(t, e, n, i)),
    this.mergeVertices();
}
dl.prototype = Object.create(Mt.prototype);
dl.prototype.constructor = dl;
function ta(t, e, n, i) {
  ct.call(this),
    (this.type = "CircleBufferGeometry"),
    (this.parameters = {
      radius: t,
      segments: e,
      thetaStart: n,
      thetaLength: i,
    }),
    (t = t || 1),
    (e = e !== void 0 ? Math.max(3, e) : 8),
    (n = n !== void 0 ? n : 0),
    (i = i !== void 0 ? i : Math.PI * 2);
  const r = [],
    s = [],
    o = [],
    a = [],
    c = new S(),
    l = new H();
  s.push(0, 0, 0), o.push(0, 0, 1), a.push(0.5, 0.5);
  for (let u = 0, h = 3; u <= e; u++, h += 3) {
    const d = n + (u / e) * i;
    (c.x = t * Math.cos(d)),
      (c.y = t * Math.sin(d)),
      s.push(c.x, c.y, c.z),
      o.push(0, 0, 1),
      (l.x = (s[h] / t + 1) / 2),
      (l.y = (s[h + 1] / t + 1) / 2),
      a.push(l.x, l.y);
  }
  for (let u = 1; u <= e; u++) r.push(u, u + 1, 0);
  this.setIndex(r),
    this.setAttribute("position", new rt(s, 3)),
    this.setAttribute("normal", new rt(o, 3)),
    this.setAttribute("uv", new rt(a, 2));
}
ta.prototype = Object.create(ct.prototype);
ta.prototype.constructor = ta;
var He = Object.freeze({
  __proto__: null,
  WireframeGeometry: Xc,
  ParametricGeometry: Yc,
  ParametricBufferGeometry: Ho,
  TetrahedronGeometry: Jc,
  TetrahedronBufferGeometry: Vo,
  OctahedronGeometry: $c,
  OctahedronBufferGeometry: Ps,
  IcosahedronGeometry: Qc,
  IcosahedronBufferGeometry: Wo,
  DodecahedronGeometry: Kc,
  DodecahedronBufferGeometry: jo,
  PolyhedronGeometry: Zc,
  PolyhedronBufferGeometry: an,
  TubeGeometry: tl,
  TubeBufferGeometry: Cs,
  TorusKnotGeometry: el,
  TorusKnotBufferGeometry: qo,
  TorusGeometry: nl,
  TorusBufferGeometry: Xo,
  TextGeometry: ol,
  TextBufferGeometry: $o,
  SphereGeometry: al,
  SphereBufferGeometry: Ds,
  RingGeometry: cl,
  RingBufferGeometry: Qo,
  PlaneGeometry: Cc,
  PlaneBufferGeometry: Ms,
  LatheGeometry: ll,
  LatheBufferGeometry: Ko,
  ShapeGeometry: Is,
  ShapeBufferGeometry: Ns,
  ExtrudeGeometry: Os,
  ExtrudeBufferGeometry: pi,
  EdgesGeometry: ul,
  ConeGeometry: hl,
  ConeBufferGeometry: fl,
  CylinderGeometry: Fs,
  CylinderBufferGeometry: Gi,
  CircleGeometry: dl,
  CircleBufferGeometry: ta,
  BoxGeometry: Sx,
  BoxBufferGeometry: Lc,
});
function Bs(t) {
  bt.call(this),
    (this.type = "ShadowMaterial"),
    (this.color = new lt(0)),
    (this.transparent = !0),
    this.setValues(t);
}
Bs.prototype = Object.create(bt.prototype);
Bs.prototype.constructor = Bs;
Bs.prototype.isShadowMaterial = !0;
Bs.prototype.copy = function (t) {
  return bt.prototype.copy.call(this, t), this.color.copy(t.color), this;
};
function ea(t) {
  Je.call(this, t), (this.type = "RawShaderMaterial");
}
ea.prototype = Object.create(Je.prototype);
ea.prototype.constructor = ea;
ea.prototype.isRawShaderMaterial = !0;
function mi(t) {
  bt.call(this),
    (this.defines = { STANDARD: "" }),
    (this.type = "MeshStandardMaterial"),
    (this.color = new lt(16777215)),
    (this.roughness = 1),
    (this.metalness = 0),
    (this.map = null),
    (this.lightMap = null),
    (this.lightMapIntensity = 1),
    (this.aoMap = null),
    (this.aoMapIntensity = 1),
    (this.emissive = new lt(0)),
    (this.emissiveIntensity = 1),
    (this.emissiveMap = null),
    (this.bumpMap = null),
    (this.bumpScale = 1),
    (this.normalMap = null),
    (this.normalMapType = is),
    (this.normalScale = new H(1, 1)),
    (this.displacementMap = null),
    (this.displacementScale = 1),
    (this.displacementBias = 0),
    (this.roughnessMap = null),
    (this.metalnessMap = null),
    (this.alphaMap = null),
    (this.envMap = null),
    (this.envMapIntensity = 1),
    (this.refractionRatio = 0.98),
    (this.wireframe = !1),
    (this.wireframeLinewidth = 1),
    (this.wireframeLinecap = "round"),
    (this.wireframeLinejoin = "round"),
    (this.skinning = !1),
    (this.morphTargets = !1),
    (this.morphNormals = !1),
    (this.vertexTangents = !1),
    this.setValues(t);
}
mi.prototype = Object.create(bt.prototype);
mi.prototype.constructor = mi;
mi.prototype.isMeshStandardMaterial = !0;
mi.prototype.copy = function (t) {
  return (
    bt.prototype.copy.call(this, t),
    (this.defines = { STANDARD: "" }),
    this.color.copy(t.color),
    (this.roughness = t.roughness),
    (this.metalness = t.metalness),
    (this.map = t.map),
    (this.lightMap = t.lightMap),
    (this.lightMapIntensity = t.lightMapIntensity),
    (this.aoMap = t.aoMap),
    (this.aoMapIntensity = t.aoMapIntensity),
    this.emissive.copy(t.emissive),
    (this.emissiveMap = t.emissiveMap),
    (this.emissiveIntensity = t.emissiveIntensity),
    (this.bumpMap = t.bumpMap),
    (this.bumpScale = t.bumpScale),
    (this.normalMap = t.normalMap),
    (this.normalMapType = t.normalMapType),
    this.normalScale.copy(t.normalScale),
    (this.displacementMap = t.displacementMap),
    (this.displacementScale = t.displacementScale),
    (this.displacementBias = t.displacementBias),
    (this.roughnessMap = t.roughnessMap),
    (this.metalnessMap = t.metalnessMap),
    (this.alphaMap = t.alphaMap),
    (this.envMap = t.envMap),
    (this.envMapIntensity = t.envMapIntensity),
    (this.refractionRatio = t.refractionRatio),
    (this.wireframe = t.wireframe),
    (this.wireframeLinewidth = t.wireframeLinewidth),
    (this.wireframeLinecap = t.wireframeLinecap),
    (this.wireframeLinejoin = t.wireframeLinejoin),
    (this.skinning = t.skinning),
    (this.morphTargets = t.morphTargets),
    (this.morphNormals = t.morphNormals),
    (this.vertexTangents = t.vertexTangents),
    this
  );
};
function zs(t) {
  mi.call(this),
    (this.defines = { STANDARD: "", PHYSICAL: "" }),
    (this.type = "MeshPhysicalMaterial"),
    (this.clearcoat = 0),
    (this.clearcoatMap = null),
    (this.clearcoatRoughness = 0),
    (this.clearcoatRoughnessMap = null),
    (this.clearcoatNormalScale = new H(1, 1)),
    (this.clearcoatNormalMap = null),
    (this.reflectivity = 0.5),
    (this.sheen = null),
    (this.transparency = 0),
    this.setValues(t);
}
zs.prototype = Object.create(mi.prototype);
zs.prototype.constructor = zs;
zs.prototype.isMeshPhysicalMaterial = !0;
zs.prototype.copy = function (t) {
  return (
    mi.prototype.copy.call(this, t),
    (this.defines = { STANDARD: "", PHYSICAL: "" }),
    (this.clearcoat = t.clearcoat),
    (this.clearcoatMap = t.clearcoatMap),
    (this.clearcoatRoughness = t.clearcoatRoughness),
    (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
    (this.clearcoatNormalMap = t.clearcoatNormalMap),
    this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
    (this.reflectivity = t.reflectivity),
    t.sheen
      ? (this.sheen = (this.sheen || new lt()).copy(t.sheen))
      : (this.sheen = null),
    (this.transparency = t.transparency),
    this
  );
};
function _r(t) {
  bt.call(this),
    (this.type = "MeshPhongMaterial"),
    (this.color = new lt(16777215)),
    (this.specular = new lt(1118481)),
    (this.shininess = 30),
    (this.map = null),
    (this.lightMap = null),
    (this.lightMapIntensity = 1),
    (this.aoMap = null),
    (this.aoMapIntensity = 1),
    (this.emissive = new lt(0)),
    (this.emissiveIntensity = 1),
    (this.emissiveMap = null),
    (this.bumpMap = null),
    (this.bumpScale = 1),
    (this.normalMap = null),
    (this.normalMapType = is),
    (this.normalScale = new H(1, 1)),
    (this.displacementMap = null),
    (this.displacementScale = 1),
    (this.displacementBias = 0),
    (this.specularMap = null),
    (this.alphaMap = null),
    (this.envMap = null),
    (this.combine = tc),
    (this.reflectivity = 1),
    (this.refractionRatio = 0.98),
    (this.wireframe = !1),
    (this.wireframeLinewidth = 1),
    (this.wireframeLinecap = "round"),
    (this.wireframeLinejoin = "round"),
    (this.skinning = !1),
    (this.morphTargets = !1),
    (this.morphNormals = !1),
    this.setValues(t);
}
_r.prototype = Object.create(bt.prototype);
_r.prototype.constructor = _r;
_r.prototype.isMeshPhongMaterial = !0;
_r.prototype.copy = function (t) {
  return (
    bt.prototype.copy.call(this, t),
    this.color.copy(t.color),
    this.specular.copy(t.specular),
    (this.shininess = t.shininess),
    (this.map = t.map),
    (this.lightMap = t.lightMap),
    (this.lightMapIntensity = t.lightMapIntensity),
    (this.aoMap = t.aoMap),
    (this.aoMapIntensity = t.aoMapIntensity),
    this.emissive.copy(t.emissive),
    (this.emissiveMap = t.emissiveMap),
    (this.emissiveIntensity = t.emissiveIntensity),
    (this.bumpMap = t.bumpMap),
    (this.bumpScale = t.bumpScale),
    (this.normalMap = t.normalMap),
    (this.normalMapType = t.normalMapType),
    this.normalScale.copy(t.normalScale),
    (this.displacementMap = t.displacementMap),
    (this.displacementScale = t.displacementScale),
    (this.displacementBias = t.displacementBias),
    (this.specularMap = t.specularMap),
    (this.alphaMap = t.alphaMap),
    (this.envMap = t.envMap),
    (this.combine = t.combine),
    (this.reflectivity = t.reflectivity),
    (this.refractionRatio = t.refractionRatio),
    (this.wireframe = t.wireframe),
    (this.wireframeLinewidth = t.wireframeLinewidth),
    (this.wireframeLinecap = t.wireframeLinecap),
    (this.wireframeLinejoin = t.wireframeLinejoin),
    (this.skinning = t.skinning),
    (this.morphTargets = t.morphTargets),
    (this.morphNormals = t.morphNormals),
    this
  );
};
function Us(t) {
  bt.call(this),
    (this.defines = { TOON: "" }),
    (this.type = "MeshToonMaterial"),
    (this.color = new lt(16777215)),
    (this.map = null),
    (this.gradientMap = null),
    (this.lightMap = null),
    (this.lightMapIntensity = 1),
    (this.aoMap = null),
    (this.aoMapIntensity = 1),
    (this.emissive = new lt(0)),
    (this.emissiveIntensity = 1),
    (this.emissiveMap = null),
    (this.bumpMap = null),
    (this.bumpScale = 1),
    (this.normalMap = null),
    (this.normalMapType = is),
    (this.normalScale = new H(1, 1)),
    (this.displacementMap = null),
    (this.displacementScale = 1),
    (this.displacementBias = 0),
    (this.alphaMap = null),
    (this.wireframe = !1),
    (this.wireframeLinewidth = 1),
    (this.wireframeLinecap = "round"),
    (this.wireframeLinejoin = "round"),
    (this.skinning = !1),
    (this.morphTargets = !1),
    (this.morphNormals = !1),
    this.setValues(t);
}
Us.prototype = Object.create(bt.prototype);
Us.prototype.constructor = Us;
Us.prototype.isMeshToonMaterial = !0;
Us.prototype.copy = function (t) {
  return (
    bt.prototype.copy.call(this, t),
    this.color.copy(t.color),
    (this.map = t.map),
    (this.gradientMap = t.gradientMap),
    (this.lightMap = t.lightMap),
    (this.lightMapIntensity = t.lightMapIntensity),
    (this.aoMap = t.aoMap),
    (this.aoMapIntensity = t.aoMapIntensity),
    this.emissive.copy(t.emissive),
    (this.emissiveMap = t.emissiveMap),
    (this.emissiveIntensity = t.emissiveIntensity),
    (this.bumpMap = t.bumpMap),
    (this.bumpScale = t.bumpScale),
    (this.normalMap = t.normalMap),
    (this.normalMapType = t.normalMapType),
    this.normalScale.copy(t.normalScale),
    (this.displacementMap = t.displacementMap),
    (this.displacementScale = t.displacementScale),
    (this.displacementBias = t.displacementBias),
    (this.alphaMap = t.alphaMap),
    (this.wireframe = t.wireframe),
    (this.wireframeLinewidth = t.wireframeLinewidth),
    (this.wireframeLinecap = t.wireframeLinecap),
    (this.wireframeLinejoin = t.wireframeLinejoin),
    (this.skinning = t.skinning),
    (this.morphTargets = t.morphTargets),
    (this.morphNormals = t.morphNormals),
    this
  );
};
function ks(t) {
  bt.call(this),
    (this.type = "MeshNormalMaterial"),
    (this.bumpMap = null),
    (this.bumpScale = 1),
    (this.normalMap = null),
    (this.normalMapType = is),
    (this.normalScale = new H(1, 1)),
    (this.displacementMap = null),
    (this.displacementScale = 1),
    (this.displacementBias = 0),
    (this.wireframe = !1),
    (this.wireframeLinewidth = 1),
    (this.fog = !1),
    (this.skinning = !1),
    (this.morphTargets = !1),
    (this.morphNormals = !1),
    this.setValues(t);
}
ks.prototype = Object.create(bt.prototype);
ks.prototype.constructor = ks;
ks.prototype.isMeshNormalMaterial = !0;
ks.prototype.copy = function (t) {
  return (
    bt.prototype.copy.call(this, t),
    (this.bumpMap = t.bumpMap),
    (this.bumpScale = t.bumpScale),
    (this.normalMap = t.normalMap),
    (this.normalMapType = t.normalMapType),
    this.normalScale.copy(t.normalScale),
    (this.displacementMap = t.displacementMap),
    (this.displacementScale = t.displacementScale),
    (this.displacementBias = t.displacementBias),
    (this.wireframe = t.wireframe),
    (this.wireframeLinewidth = t.wireframeLinewidth),
    (this.skinning = t.skinning),
    (this.morphTargets = t.morphTargets),
    (this.morphNormals = t.morphNormals),
    this
  );
};
function Gs(t) {
  bt.call(this),
    (this.type = "MeshLambertMaterial"),
    (this.color = new lt(16777215)),
    (this.map = null),
    (this.lightMap = null),
    (this.lightMapIntensity = 1),
    (this.aoMap = null),
    (this.aoMapIntensity = 1),
    (this.emissive = new lt(0)),
    (this.emissiveIntensity = 1),
    (this.emissiveMap = null),
    (this.specularMap = null),
    (this.alphaMap = null),
    (this.envMap = null),
    (this.combine = tc),
    (this.reflectivity = 1),
    (this.refractionRatio = 0.98),
    (this.wireframe = !1),
    (this.wireframeLinewidth = 1),
    (this.wireframeLinecap = "round"),
    (this.wireframeLinejoin = "round"),
    (this.skinning = !1),
    (this.morphTargets = !1),
    (this.morphNormals = !1),
    this.setValues(t);
}
Gs.prototype = Object.create(bt.prototype);
Gs.prototype.constructor = Gs;
Gs.prototype.isMeshLambertMaterial = !0;
Gs.prototype.copy = function (t) {
  return (
    bt.prototype.copy.call(this, t),
    this.color.copy(t.color),
    (this.map = t.map),
    (this.lightMap = t.lightMap),
    (this.lightMapIntensity = t.lightMapIntensity),
    (this.aoMap = t.aoMap),
    (this.aoMapIntensity = t.aoMapIntensity),
    this.emissive.copy(t.emissive),
    (this.emissiveMap = t.emissiveMap),
    (this.emissiveIntensity = t.emissiveIntensity),
    (this.specularMap = t.specularMap),
    (this.alphaMap = t.alphaMap),
    (this.envMap = t.envMap),
    (this.combine = t.combine),
    (this.reflectivity = t.reflectivity),
    (this.refractionRatio = t.refractionRatio),
    (this.wireframe = t.wireframe),
    (this.wireframeLinewidth = t.wireframeLinewidth),
    (this.wireframeLinecap = t.wireframeLinecap),
    (this.wireframeLinejoin = t.wireframeLinejoin),
    (this.skinning = t.skinning),
    (this.morphTargets = t.morphTargets),
    (this.morphNormals = t.morphNormals),
    this
  );
};
function Hs(t) {
  bt.call(this),
    (this.defines = { MATCAP: "" }),
    (this.type = "MeshMatcapMaterial"),
    (this.color = new lt(16777215)),
    (this.matcap = null),
    (this.map = null),
    (this.bumpMap = null),
    (this.bumpScale = 1),
    (this.normalMap = null),
    (this.normalMapType = is),
    (this.normalScale = new H(1, 1)),
    (this.displacementMap = null),
    (this.displacementScale = 1),
    (this.displacementBias = 0),
    (this.alphaMap = null),
    (this.skinning = !1),
    (this.morphTargets = !1),
    (this.morphNormals = !1),
    this.setValues(t);
}
Hs.prototype = Object.create(bt.prototype);
Hs.prototype.constructor = Hs;
Hs.prototype.isMeshMatcapMaterial = !0;
Hs.prototype.copy = function (t) {
  return (
    bt.prototype.copy.call(this, t),
    (this.defines = { MATCAP: "" }),
    this.color.copy(t.color),
    (this.matcap = t.matcap),
    (this.map = t.map),
    (this.bumpMap = t.bumpMap),
    (this.bumpScale = t.bumpScale),
    (this.normalMap = t.normalMap),
    (this.normalMapType = t.normalMapType),
    this.normalScale.copy(t.normalScale),
    (this.displacementMap = t.displacementMap),
    (this.displacementScale = t.displacementScale),
    (this.displacementBias = t.displacementBias),
    (this.alphaMap = t.alphaMap),
    (this.skinning = t.skinning),
    (this.morphTargets = t.morphTargets),
    (this.morphNormals = t.morphNormals),
    this
  );
};
function Vs(t) {
  me.call(this),
    (this.type = "LineDashedMaterial"),
    (this.scale = 1),
    (this.dashSize = 3),
    (this.gapSize = 1),
    this.setValues(t);
}
Vs.prototype = Object.create(me.prototype);
Vs.prototype.constructor = Vs;
Vs.prototype.isLineDashedMaterial = !0;
Vs.prototype.copy = function (t) {
  return (
    me.prototype.copy.call(this, t),
    (this.scale = t.scale),
    (this.dashSize = t.dashSize),
    (this.gapSize = t.gapSize),
    this
  );
};
var GM = Object.freeze({
  __proto__: null,
  ShadowMaterial: Bs,
  SpriteMaterial: gr,
  RawShaderMaterial: ea,
  ShaderMaterial: Je,
  PointsMaterial: yr,
  MeshPhysicalMaterial: zs,
  MeshStandardMaterial: mi,
  MeshPhongMaterial: _r,
  MeshToonMaterial: Us,
  MeshNormalMaterial: ks,
  MeshLambertMaterial: Gs,
  MeshDepthMaterial: fr,
  MeshDistanceMaterial: dr,
  MeshBasicMaterial: Ln,
  MeshMatcapMaterial: Hs,
  LineDashedMaterial: Vs,
  LineBasicMaterial: me,
  Material: bt,
});
const se = {
  arraySlice: function (t, e, n) {
    return se.isTypedArray(t)
      ? new t.constructor(t.subarray(e, n !== void 0 ? n : t.length))
      : t.slice(e, n);
  },
  convertArray: function (t, e, n) {
    return !t || (!n && t.constructor === e)
      ? t
      : typeof e.BYTES_PER_ELEMENT == "number"
      ? new e(t)
      : Array.prototype.slice.call(t);
  },
  isTypedArray: function (t) {
    return ArrayBuffer.isView(t) && !(t instanceof DataView);
  },
  getKeyframeOrder: function (t) {
    function e(r, s) {
      return t[r] - t[s];
    }
    const n = t.length,
      i = new Array(n);
    for (let r = 0; r !== n; ++r) i[r] = r;
    return i.sort(e), i;
  },
  sortedArray: function (t, e, n) {
    const i = t.length,
      r = new t.constructor(i);
    for (let s = 0, o = 0; o !== i; ++s) {
      const a = n[s] * e;
      for (let c = 0; c !== e; ++c) r[o++] = t[a + c];
    }
    return r;
  },
  flattenJSON: function (t, e, n, i) {
    let r = 1,
      s = t[0];
    for (; s !== void 0 && s[i] === void 0; ) s = t[r++];
    if (s === void 0) return;
    let o = s[i];
    if (o !== void 0)
      if (Array.isArray(o))
        do
          (o = s[i]),
            o !== void 0 && (e.push(s.time), n.push.apply(n, o)),
            (s = t[r++]);
        while (s !== void 0);
      else if (o.toArray !== void 0)
        do
          (o = s[i]),
            o !== void 0 && (e.push(s.time), o.toArray(n, n.length)),
            (s = t[r++]);
        while (s !== void 0);
      else
        do
          (o = s[i]), o !== void 0 && (e.push(s.time), n.push(o)), (s = t[r++]);
        while (s !== void 0);
  },
  subclip: function (t, e, n, i, r) {
    r = r || 30;
    const s = t.clone();
    s.name = e;
    const o = [];
    for (let c = 0; c < s.tracks.length; ++c) {
      const l = s.tracks[c],
        u = l.getValueSize(),
        h = [],
        d = [];
      for (let f = 0; f < l.times.length; ++f) {
        const p = l.times[f] * r;
        if (!(p < n || p >= i)) {
          h.push(l.times[f]);
          for (let _ = 0; _ < u; ++_) d.push(l.values[f * u + _]);
        }
      }
      h.length !== 0 &&
        ((l.times = se.convertArray(h, l.times.constructor)),
        (l.values = se.convertArray(d, l.values.constructor)),
        o.push(l));
    }
    s.tracks = o;
    let a = 1 / 0;
    for (let c = 0; c < s.tracks.length; ++c)
      a > s.tracks[c].times[0] && (a = s.tracks[c].times[0]);
    for (let c = 0; c < s.tracks.length; ++c) s.tracks[c].shift(-1 * a);
    return s.resetDuration(), s;
  },
  makeClipAdditive: function (t, e, n, i) {
    e === void 0 && (e = 0),
      n === void 0 && (n = t),
      (i === void 0 || i <= 0) && (i = 30);
    const r = t.tracks.length,
      s = e / i;
    for (let o = 0; o < r; ++o) {
      const a = n.tracks[o],
        c = a.ValueTypeName;
      if (c === "bool" || c === "string") continue;
      const l = t.tracks.find(function (p) {
        return p.name === a.name && p.ValueTypeName === c;
      });
      if (l === void 0) continue;
      const u = a.getValueSize(),
        h = a.times.length - 1;
      let d;
      if (s <= a.times[0]) d = se.arraySlice(a.values, 0, a.valueSize);
      else if (s >= a.times[h]) {
        const p = h * u;
        d = se.arraySlice(a.values, p);
      } else {
        const p = a.createInterpolant();
        p.evaluate(s), (d = p.resultBuffer);
      }
      c === "quaternion" &&
        new Ae(d[0], d[1], d[2], d[3]).normalize().conjugate().toArray(d);
      const f = l.times.length;
      for (let p = 0; p < f; ++p) {
        const _ = p * u;
        if (c === "quaternion")
          Ae.multiplyQuaternionsFlat(l.values, _, d, 0, l.values, _);
        else for (let y = 0; y < u; ++y) l.values[_ + y] -= d[y];
      }
    }
    return (t.blendMode = Bp), t;
  },
};
function _n(t, e, n, i) {
  (this.parameterPositions = t),
    (this._cachedIndex = 0),
    (this.resultBuffer = i !== void 0 ? i : new e.constructor(n)),
    (this.sampleValues = e),
    (this.valueSize = n);
}
Object.assign(_n.prototype, {
  evaluate: function (t) {
    let e = this.parameterPositions,
      n = this._cachedIndex,
      i = e[n],
      r = e[n - 1];
    t: {
      e: {
        let s;
        n: {
          i: if (!(t < i)) {
            for (let o = n + 2; ; ) {
              if (i === void 0) {
                if (t < r) break i;
                return (
                  (n = e.length),
                  (this._cachedIndex = n),
                  this.afterEnd_(n - 1, t, r)
                );
              }
              if (n === o) break;
              if (((r = i), (i = e[++n]), t < i)) break e;
            }
            s = e.length;
            break n;
          }
          if (!(t >= r)) {
            const o = e[1];
            t < o && ((n = 2), (r = o));
            for (let a = n - 2; ; ) {
              if (r === void 0)
                return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
              if (n === a) break;
              if (((i = r), (r = e[--n - 1]), t >= r)) break e;
            }
            (s = n), (n = 0);
            break n;
          }
          break t;
        }
        for (; n < s; ) {
          const o = (n + s) >>> 1;
          t < e[o] ? (s = o) : (n = o + 1);
        }
        if (((i = e[n]), (r = e[n - 1]), r === void 0))
          return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
        if (i === void 0)
          return (
            (n = e.length), (this._cachedIndex = n), this.afterEnd_(n - 1, r, t)
          );
      }
      (this._cachedIndex = n), this.intervalChanged_(n, r, i);
    }
    return this.interpolate_(n, r, t, i);
  },
  settings: null,
  DefaultSettings_: {},
  getSettings_: function () {
    return this.settings || this.DefaultSettings_;
  },
  copySampleValue_: function (t) {
    const e = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      r = t * i;
    for (let s = 0; s !== i; ++s) e[s] = n[r + s];
    return e;
  },
  interpolate_: function () {
    throw new Error("call to abstract method");
  },
  intervalChanged_: function () {},
});
Object.assign(_n.prototype, {
  beforeStart_: _n.prototype.copySampleValue_,
  afterEnd_: _n.prototype.copySampleValue_,
});
function kh(t, e, n, i) {
  _n.call(this, t, e, n, i),
    (this._weightPrev = -0),
    (this._offsetPrev = -0),
    (this._weightNext = -0),
    (this._offsetNext = -0);
}
kh.prototype = Object.assign(Object.create(_n.prototype), {
  constructor: kh,
  DefaultSettings_: { endingStart: es, endingEnd: es },
  intervalChanged_: function (t, e, n) {
    let i = this.parameterPositions,
      r = t - 2,
      s = t + 1,
      o = i[r],
      a = i[s];
    if (o === void 0)
      switch (this.getSettings_().endingStart) {
        case ns:
          (r = t), (o = 2 * e - n);
          break;
        case uc:
          (r = i.length - 2), (o = e + i[r] - i[r + 1]);
          break;
        default:
          (r = t), (o = n);
      }
    if (a === void 0)
      switch (this.getSettings_().endingEnd) {
        case ns:
          (s = t), (a = 2 * n - e);
          break;
        case uc:
          (s = 1), (a = n + i[1] - i[0]);
          break;
        default:
          (s = t - 1), (a = e);
      }
    const c = (n - e) * 0.5,
      l = this.valueSize;
    (this._weightPrev = c / (e - o)),
      (this._weightNext = c / (a - n)),
      (this._offsetPrev = r * l),
      (this._offsetNext = s * l);
  },
  interpolate_: function (t, e, n, i) {
    const r = this.resultBuffer,
      s = this.sampleValues,
      o = this.valueSize,
      a = t * o,
      c = a - o,
      l = this._offsetPrev,
      u = this._offsetNext,
      h = this._weightPrev,
      d = this._weightNext,
      f = (n - e) / (i - e),
      p = f * f,
      _ = p * f,
      y = -h * _ + 2 * h * p - h * f,
      m = (1 + h) * _ + (-1.5 - 2 * h) * p + (-0.5 + h) * f + 1,
      g = (-1 - d) * _ + (1.5 + d) * p + 0.5 * f,
      b = d * _ - d * p;
    for (let x = 0; x !== o; ++x)
      r[x] = y * s[l + x] + m * s[c + x] + g * s[a + x] + b * s[u + x];
    return r;
  },
});
function pl(t, e, n, i) {
  _n.call(this, t, e, n, i);
}
pl.prototype = Object.assign(Object.create(_n.prototype), {
  constructor: pl,
  interpolate_: function (t, e, n, i) {
    const r = this.resultBuffer,
      s = this.sampleValues,
      o = this.valueSize,
      a = t * o,
      c = a - o,
      l = (n - e) / (i - e),
      u = 1 - l;
    for (let h = 0; h !== o; ++h) r[h] = s[c + h] * u + s[a + h] * l;
    return r;
  },
});
function Gh(t, e, n, i) {
  _n.call(this, t, e, n, i);
}
Gh.prototype = Object.assign(Object.create(_n.prototype), {
  constructor: Gh,
  interpolate_: function (t) {
    return this.copySampleValue_(t - 1);
  },
});
function Fe(t, e, n, i) {
  if (t === void 0)
    throw new Error("THREE.KeyframeTrack: track name is undefined");
  if (e === void 0 || e.length === 0)
    throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
  (this.name = t),
    (this.times = se.convertArray(e, this.TimeBufferType)),
    (this.values = se.convertArray(n, this.ValueBufferType)),
    this.setInterpolation(i || this.DefaultInterpolation);
}
Object.assign(Fe, {
  toJSON: function (t) {
    const e = t.constructor;
    let n;
    if (e.toJSON !== void 0) n = e.toJSON(t);
    else {
      n = {
        name: t.name,
        times: se.convertArray(t.times, Array),
        values: se.convertArray(t.values, Array),
      };
      const i = t.getInterpolation();
      i !== t.DefaultInterpolation && (n.interpolation = i);
    }
    return (n.type = t.ValueTypeName), n;
  },
});
Object.assign(Fe.prototype, {
  constructor: Fe,
  TimeBufferType: Float32Array,
  ValueBufferType: Float32Array,
  DefaultInterpolation: lc,
  InterpolantFactoryMethodDiscrete: function (t) {
    return new Gh(this.times, this.values, this.getValueSize(), t);
  },
  InterpolantFactoryMethodLinear: function (t) {
    return new pl(this.times, this.values, this.getValueSize(), t);
  },
  InterpolantFactoryMethodSmooth: function (t) {
    return new kh(this.times, this.values, this.getValueSize(), t);
  },
  setInterpolation: function (t) {
    let e;
    switch (t) {
      case cc:
        e = this.InterpolantFactoryMethodDiscrete;
        break;
      case lc:
        e = this.InterpolantFactoryMethodLinear;
        break;
      case Yu:
        e = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (e === void 0) {
      const n =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (t !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(n);
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return (this.createInterpolant = e), this;
  },
  getInterpolation: function () {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return cc;
      case this.InterpolantFactoryMethodLinear:
        return lc;
      case this.InterpolantFactoryMethodSmooth:
        return Yu;
    }
  },
  getValueSize: function () {
    return this.values.length / this.times.length;
  },
  shift: function (t) {
    if (t !== 0) {
      const e = this.times;
      for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
    }
    return this;
  },
  scale: function (t) {
    if (t !== 1) {
      const e = this.times;
      for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
    }
    return this;
  },
  trim: function (t, e) {
    const n = this.times,
      i = n.length;
    let r = 0,
      s = i - 1;
    for (; r !== i && n[r] < t; ) ++r;
    for (; s !== -1 && n[s] > e; ) --s;
    if ((++s, r !== 0 || s !== i)) {
      r >= s && ((s = Math.max(s, 1)), (r = s - 1));
      const o = this.getValueSize();
      (this.times = se.arraySlice(n, r, s)),
        (this.values = se.arraySlice(this.values, r * o, s * o));
    }
    return this;
  },
  validate: function () {
    let t = !0;
    const e = this.getValueSize();
    e - Math.floor(e) != 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (t = !1));
    const n = this.times,
      i = this.values,
      r = n.length;
    r === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (t = !1));
    let s = null;
    for (let o = 0; o !== r; o++) {
      const a = n[o];
      if (typeof a == "number" && isNaN(a)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          o,
          a
        ),
          (t = !1);
        break;
      }
      if (s !== null && s > a) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, o, a, s),
          (t = !1);
        break;
      }
      s = a;
    }
    if (i !== void 0 && se.isTypedArray(i))
      for (let o = 0, a = i.length; o !== a; ++o) {
        const c = i[o];
        if (isNaN(c)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            o,
            c
          ),
            (t = !1);
          break;
        }
      }
    return t;
  },
  optimize: function () {
    const t = se.arraySlice(this.times),
      e = se.arraySlice(this.values),
      n = this.getValueSize(),
      i = this.getInterpolation() === Yu,
      r = t.length - 1;
    let s = 1;
    for (let o = 1; o < r; ++o) {
      let a = !1;
      const c = t[o],
        l = t[o + 1];
      if (c !== l && (o !== 1 || c !== c[0]))
        if (i) a = !0;
        else {
          const u = o * n,
            h = u - n,
            d = u + n;
          for (let f = 0; f !== n; ++f) {
            const p = e[u + f];
            if (p !== e[h + f] || p !== e[d + f]) {
              a = !0;
              break;
            }
          }
        }
      if (a) {
        if (o !== s) {
          t[s] = t[o];
          const u = o * n,
            h = s * n;
          for (let d = 0; d !== n; ++d) e[h + d] = e[u + d];
        }
        ++s;
      }
    }
    if (r > 0) {
      t[s] = t[r];
      for (let o = r * n, a = s * n, c = 0; c !== n; ++c) e[a + c] = e[o + c];
      ++s;
    }
    return (
      s !== t.length
        ? ((this.times = se.arraySlice(t, 0, s)),
          (this.values = se.arraySlice(e, 0, s * n)))
        : ((this.times = t), (this.values = e)),
      this
    );
  },
  clone: function () {
    const t = se.arraySlice(this.times, 0),
      e = se.arraySlice(this.values, 0),
      n = this.constructor,
      i = new n(this.name, t, e);
    return (i.createInterpolant = this.createInterpolant), i;
  },
});
function Hh(t, e, n) {
  Fe.call(this, t, e, n);
}
Hh.prototype = Object.assign(Object.create(Fe.prototype), {
  constructor: Hh,
  ValueTypeName: "bool",
  ValueBufferType: Array,
  DefaultInterpolation: cc,
  InterpolantFactoryMethodLinear: void 0,
  InterpolantFactoryMethodSmooth: void 0,
});
function Vh(t, e, n, i) {
  Fe.call(this, t, e, n, i);
}
Vh.prototype = Object.assign(Object.create(Fe.prototype), {
  constructor: Vh,
  ValueTypeName: "color",
});
function na(t, e, n, i) {
  Fe.call(this, t, e, n, i);
}
na.prototype = Object.assign(Object.create(Fe.prototype), {
  constructor: na,
  ValueTypeName: "number",
});
function Wh(t, e, n, i) {
  _n.call(this, t, e, n, i);
}
Wh.prototype = Object.assign(Object.create(_n.prototype), {
  constructor: Wh,
  interpolate_: function (t, e, n, i) {
    const r = this.resultBuffer,
      s = this.sampleValues,
      o = this.valueSize,
      a = (n - e) / (i - e);
    let c = t * o;
    for (let l = c + o; c !== l; c += 4) Ae.slerpFlat(r, 0, s, c - o, s, c, a);
    return r;
  },
});
function ml(t, e, n, i) {
  Fe.call(this, t, e, n, i);
}
ml.prototype = Object.assign(Object.create(Fe.prototype), {
  constructor: ml,
  ValueTypeName: "quaternion",
  DefaultInterpolation: lc,
  InterpolantFactoryMethodLinear: function (t) {
    return new Wh(this.times, this.values, this.getValueSize(), t);
  },
  InterpolantFactoryMethodSmooth: void 0,
});
function jh(t, e, n, i) {
  Fe.call(this, t, e, n, i);
}
jh.prototype = Object.assign(Object.create(Fe.prototype), {
  constructor: jh,
  ValueTypeName: "string",
  ValueBufferType: Array,
  DefaultInterpolation: cc,
  InterpolantFactoryMethodLinear: void 0,
  InterpolantFactoryMethodSmooth: void 0,
});
function ia(t, e, n, i) {
  Fe.call(this, t, e, n, i);
}
ia.prototype = Object.assign(Object.create(Fe.prototype), {
  constructor: ia,
  ValueTypeName: "vector",
});
function Pn(t, e, n, i) {
  (this.name = t),
    (this.tracks = n),
    (this.duration = e !== void 0 ? e : -1),
    (this.blendMode = i !== void 0 ? i : Zu),
    (this.uuid = Pt.generateUUID()),
    this.duration < 0 && this.resetDuration();
}
function HM(t) {
  switch (t.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return na;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return ia;
    case "color":
      return Vh;
    case "quaternion":
      return ml;
    case "bool":
    case "boolean":
      return Hh;
    case "string":
      return jh;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
}
function VM(t) {
  if (t.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = HM(t.type);
  if (t.times === void 0) {
    const n = [],
      i = [];
    se.flattenJSON(t.keys, n, i, "value"), (t.times = n), (t.values = i);
  }
  return e.parse !== void 0
    ? e.parse(t)
    : new e(t.name, t.times, t.values, t.interpolation);
}
Object.assign(Pn, {
  parse: function (t) {
    const e = [],
      n = t.tracks,
      i = 1 / (t.fps || 1);
    for (let r = 0, s = n.length; r !== s; ++r) e.push(VM(n[r]).scale(i));
    return new Pn(t.name, t.duration, e, t.blendMode);
  },
  toJSON: function (t) {
    const e = [],
      n = t.tracks,
      i = {
        name: t.name,
        duration: t.duration,
        tracks: e,
        uuid: t.uuid,
        blendMode: t.blendMode,
      };
    for (let r = 0, s = n.length; r !== s; ++r) e.push(Fe.toJSON(n[r]));
    return i;
  },
  CreateFromMorphTargetSequence: function (t, e, n, i) {
    const r = e.length,
      s = [];
    for (let o = 0; o < r; o++) {
      let a = [],
        c = [];
      a.push((o + r - 1) % r, o, (o + 1) % r), c.push(0, 1, 0);
      const l = se.getKeyframeOrder(a);
      (a = se.sortedArray(a, 1, l)),
        (c = se.sortedArray(c, 1, l)),
        !i && a[0] === 0 && (a.push(r), c.push(c[0])),
        s.push(
          new na(".morphTargetInfluences[" + e[o].name + "]", a, c).scale(1 / n)
        );
    }
    return new Pn(t, -1, s);
  },
  findByName: function (t, e) {
    let n = t;
    if (!Array.isArray(t)) {
      const i = t;
      n = (i.geometry && i.geometry.animations) || i.animations;
    }
    for (let i = 0; i < n.length; i++) if (n[i].name === e) return n[i];
    return null;
  },
  CreateClipsFromMorphTargetSequences: function (t, e, n) {
    const i = {},
      r = /^([\w-]*?)([\d]+)$/;
    for (let o = 0, a = t.length; o < a; o++) {
      const c = t[o],
        l = c.name.match(r);
      if (l && l.length > 1) {
        const u = l[1];
        let h = i[u];
        h || (i[u] = h = []), h.push(c);
      }
    }
    const s = [];
    for (const o in i) s.push(Pn.CreateFromMorphTargetSequence(o, i[o], e, n));
    return s;
  },
  parseAnimation: function (t, e) {
    if (!t)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const n = function (u, h, d, f, p) {
        if (d.length !== 0) {
          const _ = [],
            y = [];
          se.flattenJSON(d, _, y, f), _.length !== 0 && p.push(new u(h, _, y));
        }
      },
      i = [],
      r = t.name || "default",
      s = t.fps || 30,
      o = t.blendMode;
    let a = t.length || -1;
    const c = t.hierarchy || [];
    for (let u = 0; u < c.length; u++) {
      const h = c[u].keys;
      if (!(!h || h.length === 0))
        if (h[0].morphTargets) {
          const d = {};
          let f;
          for (f = 0; f < h.length; f++)
            if (h[f].morphTargets)
              for (let p = 0; p < h[f].morphTargets.length; p++)
                d[h[f].morphTargets[p]] = -1;
          for (const p in d) {
            const _ = [],
              y = [];
            for (let m = 0; m !== h[f].morphTargets.length; ++m) {
              const g = h[f];
              _.push(g.time), y.push(g.morphTarget === p ? 1 : 0);
            }
            i.push(new na(".morphTargetInfluence[" + p + "]", _, y));
          }
          a = d.length * (s || 1);
        } else {
          const d = ".bones[" + e[u].name + "]";
          n(ia, d + ".position", h, "pos", i),
            n(ml, d + ".quaternion", h, "rot", i),
            n(ia, d + ".scale", h, "scl", i);
        }
    }
    return i.length === 0 ? null : new Pn(r, a, i, o);
  },
});
Object.assign(Pn.prototype, {
  resetDuration: function () {
    const t = this.tracks;
    let e = 0;
    for (let n = 0, i = t.length; n !== i; ++n) {
      const r = this.tracks[n];
      e = Math.max(e, r.times[r.times.length - 1]);
    }
    return (this.duration = e), this;
  },
  trim: function () {
    for (let t = 0; t < this.tracks.length; t++)
      this.tracks[t].trim(0, this.duration);
    return this;
  },
  validate: function () {
    let t = !0;
    for (let e = 0; e < this.tracks.length; e++)
      t = t && this.tracks[e].validate();
    return t;
  },
  optimize: function () {
    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
    return this;
  },
  clone: function () {
    const t = [];
    for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
    return new Pn(this.name, this.duration, t, this.blendMode);
  },
});
const Ws = {
  enabled: !1,
  files: {},
  add: function (t, e) {
    this.enabled !== !1 && (this.files[t] = e);
  },
  get: function (t) {
    if (this.enabled !== !1) return this.files[t];
  },
  remove: function (t) {
    delete this.files[t];
  },
  clear: function () {
    this.files = {};
  },
};
function jm(t, e, n) {
  const i = this;
  let r = !1,
    s = 0,
    o = 0,
    a;
  const c = [];
  (this.onStart = void 0),
    (this.onLoad = t),
    (this.onProgress = e),
    (this.onError = n),
    (this.itemStart = function (l) {
      o++, r === !1 && i.onStart !== void 0 && i.onStart(l, s, o), (r = !0);
    }),
    (this.itemEnd = function (l) {
      s++,
        i.onProgress !== void 0 && i.onProgress(l, s, o),
        s === o && ((r = !1), i.onLoad !== void 0 && i.onLoad());
    }),
    (this.itemError = function (l) {
      i.onError !== void 0 && i.onError(l);
    }),
    (this.resolveURL = function (l) {
      return a ? a(l) : l;
    }),
    (this.setURLModifier = function (l) {
      return (a = l), this;
    }),
    (this.addHandler = function (l, u) {
      return c.push(l, u), this;
    }),
    (this.removeHandler = function (l) {
      const u = c.indexOf(l);
      return u !== -1 && c.splice(u, 2), this;
    }),
    (this.getHandler = function (l) {
      for (let u = 0, h = c.length; u < h; u += 2) {
        const d = c[u],
          f = c[u + 1];
        if ((d.global && (d.lastIndex = 0), d.test(l))) return f;
      }
      return null;
    });
}
const WM = new jm();
function Wt(t) {
  (this.manager = t !== void 0 ? t : WM),
    (this.crossOrigin = "anonymous"),
    (this.path = ""),
    (this.resourcePath = ""),
    (this.requestHeader = {});
}
Object.assign(Wt.prototype, {
  load: function () {},
  loadAsync: function (t, e) {
    const n = this;
    return new Promise(function (i, r) {
      n.load(t, i, e, r);
    });
  },
  parse: function () {},
  setCrossOrigin: function (t) {
    return (this.crossOrigin = t), this;
  },
  setPath: function (t) {
    return (this.path = t), this;
  },
  setResourcePath: function (t) {
    return (this.resourcePath = t), this;
  },
  setRequestHeader: function (t) {
    return (this.requestHeader = t), this;
  },
});
const Cn = {};
function qn(t) {
  Wt.call(this, t);
}
qn.prototype = Object.assign(Object.create(Wt.prototype), {
  constructor: qn,
  load: function (t, e, n, i) {
    t === void 0 && (t = ""),
      this.path !== void 0 && (t = this.path + t),
      (t = this.manager.resolveURL(t));
    const r = this,
      s = Ws.get(t);
    if (s !== void 0)
      return (
        r.manager.itemStart(t),
        setTimeout(function () {
          e && e(s), r.manager.itemEnd(t);
        }, 0),
        s
      );
    if (Cn[t] !== void 0) {
      Cn[t].push({ onLoad: e, onProgress: n, onError: i });
      return;
    }
    const o = /^data:(.*?)(;base64)?,(.*)$/,
      a = t.match(o);
    let c;
    if (a) {
      const l = a[1],
        u = !!a[2];
      let h = a[3];
      (h = decodeURIComponent(h)), u && (h = atob(h));
      try {
        let d;
        const f = (this.responseType || "").toLowerCase();
        switch (f) {
          case "arraybuffer":
          case "blob":
            const p = new Uint8Array(h.length);
            for (let y = 0; y < h.length; y++) p[y] = h.charCodeAt(y);
            f === "blob"
              ? (d = new Blob([p.buffer], { type: l }))
              : (d = p.buffer);
            break;
          case "document":
            d = new DOMParser().parseFromString(h, l);
            break;
          case "json":
            d = JSON.parse(h);
            break;
          default:
            d = h;
            break;
        }
        setTimeout(function () {
          e && e(d), r.manager.itemEnd(t);
        }, 0);
      } catch (d) {
        setTimeout(function () {
          i && i(d), r.manager.itemError(t), r.manager.itemEnd(t);
        }, 0);
      }
    } else {
      (Cn[t] = []),
        Cn[t].push({ onLoad: e, onProgress: n, onError: i }),
        (c = new XMLHttpRequest()),
        c.open("GET", t, !0),
        c.addEventListener(
          "load",
          function (l) {
            const u = this.response,
              h = Cn[t];
            if ((delete Cn[t], this.status === 200 || this.status === 0)) {
              this.status === 0 &&
                console.warn("THREE.FileLoader: HTTP Status 0 received."),
                Ws.add(t, u);
              for (let d = 0, f = h.length; d < f; d++) {
                const p = h[d];
                p.onLoad && p.onLoad(u);
              }
              r.manager.itemEnd(t);
            } else {
              for (let d = 0, f = h.length; d < f; d++) {
                const p = h[d];
                p.onError && p.onError(l);
              }
              r.manager.itemError(t), r.manager.itemEnd(t);
            }
          },
          !1
        ),
        c.addEventListener(
          "progress",
          function (l) {
            const u = Cn[t];
            for (let h = 0, d = u.length; h < d; h++) {
              const f = u[h];
              f.onProgress && f.onProgress(l);
            }
          },
          !1
        ),
        c.addEventListener(
          "error",
          function (l) {
            const u = Cn[t];
            delete Cn[t];
            for (let h = 0, d = u.length; h < d; h++) {
              const f = u[h];
              f.onError && f.onError(l);
            }
            r.manager.itemError(t), r.manager.itemEnd(t);
          },
          !1
        ),
        c.addEventListener(
          "abort",
          function (l) {
            const u = Cn[t];
            delete Cn[t];
            for (let h = 0, d = u.length; h < d; h++) {
              const f = u[h];
              f.onError && f.onError(l);
            }
            r.manager.itemError(t), r.manager.itemEnd(t);
          },
          !1
        ),
        this.responseType !== void 0 && (c.responseType = this.responseType),
        this.withCredentials !== void 0 &&
          (c.withCredentials = this.withCredentials),
        c.overrideMimeType &&
          c.overrideMimeType(
            this.mimeType !== void 0 ? this.mimeType : "text/plain"
          );
      for (const l in this.requestHeader)
        c.setRequestHeader(l, this.requestHeader[l]);
      c.send(null);
    }
    return r.manager.itemStart(t), c;
  },
  setResponseType: function (t) {
    return (this.responseType = t), this;
  },
  setWithCredentials: function (t) {
    return (this.withCredentials = t), this;
  },
  setMimeType: function (t) {
    return (this.mimeType = t), this;
  },
});
function qm(t) {
  Wt.call(this, t);
}
qm.prototype = Object.assign(Object.create(Wt.prototype), {
  constructor: qm,
  load: function (t, e, n, i) {
    const r = this,
      s = new qn(r.manager);
    s.setPath(r.path),
      s.load(
        t,
        function (o) {
          try {
            e(r.parse(JSON.parse(o)));
          } catch (a) {
            i ? i(a) : console.error(a), r.manager.itemError(t);
          }
        },
        n,
        i
      );
  },
  parse: function (t) {
    const e = [];
    for (let n = 0; n < t.length; n++) {
      const i = Pn.parse(t[n]);
      e.push(i);
    }
    return e;
  },
});
function Xm(t) {
  Wt.call(this, t);
}
Xm.prototype = Object.assign(Object.create(Wt.prototype), {
  constructor: Xm,
  load: function (t, e, n, i) {
    const r = this,
      s = [],
      o = new Go();
    o.image = s;
    const a = new qn(this.manager);
    a.setPath(this.path), a.setResponseType("arraybuffer");
    let c = 0;
    function l(u) {
      a.load(
        t[u],
        function (h) {
          const d = r.parse(h, !0);
          (s[u] = {
            width: d.width,
            height: d.height,
            format: d.format,
            mipmaps: d.mipmaps,
          }),
            (c += 1),
            c === 6 &&
              (d.mipmapCount === 1 && (o.minFilter = Ie),
              (o.format = d.format),
              (o.needsUpdate = !0),
              e && e(o));
        },
        n,
        i
      );
    }
    if (Array.isArray(t)) for (let u = 0, h = t.length; u < h; ++u) l(u);
    else
      a.load(
        t,
        function (u) {
          const h = r.parse(u, !0);
          if (h.isCubemap) {
            const d = h.mipmaps.length / h.mipmapCount;
            for (let f = 0; f < d; f++) {
              s[f] = { mipmaps: [] };
              for (let p = 0; p < h.mipmapCount; p++)
                s[f].mipmaps.push(h.mipmaps[f * h.mipmapCount + p]),
                  (s[f].format = h.format),
                  (s[f].width = h.width),
                  (s[f].height = h.height);
            }
          } else
            (o.image.width = h.width),
              (o.image.height = h.height),
              (o.mipmaps = h.mipmaps);
          h.mipmapCount === 1 && (o.minFilter = Ie),
            (o.format = h.format),
            (o.needsUpdate = !0),
            e && e(o);
        },
        n,
        i
      );
    return o;
  },
});
function Ym(t) {
  Wt.call(this, t);
}
Ym.prototype = Object.assign(Object.create(Wt.prototype), {
  constructor: Ym,
  load: function (t, e, n, i) {
    const r = this,
      s = new bs(),
      o = new qn(this.manager);
    return (
      o.setResponseType("arraybuffer"),
      o.setPath(this.path),
      o.load(
        t,
        function (a) {
          const c = r.parse(a);
          !c ||
            (c.image !== void 0
              ? (s.image = c.image)
              : c.data !== void 0 &&
                ((s.image.width = c.width),
                (s.image.height = c.height),
                (s.image.data = c.data)),
            (s.wrapS = c.wrapS !== void 0 ? c.wrapS : Ze),
            (s.wrapT = c.wrapT !== void 0 ? c.wrapT : Ze),
            (s.magFilter = c.magFilter !== void 0 ? c.magFilter : Ie),
            (s.minFilter = c.minFilter !== void 0 ? c.minFilter : Ie),
            (s.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1),
            c.format !== void 0 && (s.format = c.format),
            c.type !== void 0 && (s.type = c.type),
            c.mipmaps !== void 0 &&
              ((s.mipmaps = c.mipmaps), (s.minFilter = rc)),
            c.mipmapCount === 1 && (s.minFilter = Ie),
            (s.needsUpdate = !0),
            e && e(s, c));
        },
        n,
        i
      ),
      s
    );
  },
});
function ra(t) {
  Wt.call(this, t);
}
ra.prototype = Object.assign(Object.create(Wt.prototype), {
  constructor: ra,
  load: function (t, e, n, i) {
    this.path !== void 0 && (t = this.path + t),
      (t = this.manager.resolveURL(t));
    const r = this,
      s = Ws.get(t);
    if (s !== void 0)
      return (
        r.manager.itemStart(t),
        setTimeout(function () {
          e && e(s), r.manager.itemEnd(t);
        }, 0),
        s
      );
    const o = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    function a() {
      o.removeEventListener("load", a, !1),
        o.removeEventListener("error", c, !1),
        Ws.add(t, this),
        e && e(this),
        r.manager.itemEnd(t);
    }
    function c(l) {
      o.removeEventListener("load", a, !1),
        o.removeEventListener("error", c, !1),
        i && i(l),
        r.manager.itemError(t),
        r.manager.itemEnd(t);
    }
    return (
      o.addEventListener("load", a, !1),
      o.addEventListener("error", c, !1),
      t.substr(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (o.crossOrigin = this.crossOrigin),
      r.manager.itemStart(t),
      (o.src = t),
      o
    );
  },
});
function qh(t) {
  Wt.call(this, t);
}
qh.prototype = Object.assign(Object.create(Wt.prototype), {
  constructor: qh,
  load: function (t, e, n, i) {
    const r = new Bi(),
      s = new ra(this.manager);
    s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
    let o = 0;
    function a(c) {
      s.load(
        t[c],
        function (l) {
          (r.images[c] = l), o++, o === 6 && ((r.needsUpdate = !0), e && e(r));
        },
        void 0,
        i
      );
    }
    for (let c = 0; c < t.length; ++c) a(c);
    return r;
  },
});
function Xh(t) {
  Wt.call(this, t);
}
Xh.prototype = Object.assign(Object.create(Wt.prototype), {
  constructor: Xh,
  load: function (t, e, n, i) {
    const r = new Jt(),
      s = new ra(this.manager);
    return (
      s.setCrossOrigin(this.crossOrigin),
      s.setPath(this.path),
      s.load(
        t,
        function (o) {
          r.image = o;
          const a =
            t.search(/\.jpe?g($|\?)/i) > 0 ||
            t.search(/^data\:image\/jpeg/) === 0;
          (r.format = a ? ar : Gn), (r.needsUpdate = !0), e !== void 0 && e(r);
        },
        n,
        i
      ),
      r
    );
  },
});
function _t() {
  (this.type = "Curve"), (this.arcLengthDivisions = 200);
}
Object.assign(_t.prototype, {
  getPoint: function () {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  },
  getPointAt: function (t, e) {
    const n = this.getUtoTmapping(t);
    return this.getPoint(n, e);
  },
  getPoints: function (t) {
    t === void 0 && (t = 5);
    const e = [];
    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
    return e;
  },
  getSpacedPoints: function (t) {
    t === void 0 && (t = 5);
    const e = [];
    for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
    return e;
  },
  getLength: function () {
    const t = this.getLengths();
    return t[t.length - 1];
  },
  getLengths: function (t) {
    if (
      (t === void 0 && (t = this.arcLengthDivisions),
      this.cacheArcLengths &&
        this.cacheArcLengths.length === t + 1 &&
        !this.needsUpdate)
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const e = [];
    let n,
      i = this.getPoint(0),
      r = 0;
    e.push(0);
    for (let s = 1; s <= t; s++)
      (n = this.getPoint(s / t)), (r += n.distanceTo(i)), e.push(r), (i = n);
    return (this.cacheArcLengths = e), e;
  },
  updateArcLengths: function () {
    (this.needsUpdate = !0), this.getLengths();
  },
  getUtoTmapping: function (t, e) {
    const n = this.getLengths();
    let i = 0,
      r = n.length,
      s;
    e ? (s = e) : (s = t * n[r - 1]);
    let o = 0,
      a = r - 1,
      c;
    for (; o <= a; )
      if (((i = Math.floor(o + (a - o) / 2)), (c = n[i] - s), c < 0)) o = i + 1;
      else if (c > 0) a = i - 1;
      else {
        a = i;
        break;
      }
    if (((i = a), n[i] === s)) return i / (r - 1);
    const l = n[i],
      h = n[i + 1] - l,
      d = (s - l) / h;
    return (i + d) / (r - 1);
  },
  getTangent: function (t, e) {
    const n = 1e-4;
    let i = t - n,
      r = t + n;
    i < 0 && (i = 0), r > 1 && (r = 1);
    const s = this.getPoint(i),
      o = this.getPoint(r),
      a = e || (s.isVector2 ? new H() : new S());
    return a.copy(o).sub(s).normalize(), a;
  },
  getTangentAt: function (t, e) {
    const n = this.getUtoTmapping(t);
    return this.getTangent(n, e);
  },
  computeFrenetFrames: function (t, e) {
    const n = new S(),
      i = [],
      r = [],
      s = [],
      o = new S(),
      a = new Rt();
    for (let d = 0; d <= t; d++) {
      const f = d / t;
      (i[d] = this.getTangentAt(f, new S())), i[d].normalize();
    }
    (r[0] = new S()), (s[0] = new S());
    let c = Number.MAX_VALUE;
    const l = Math.abs(i[0].x),
      u = Math.abs(i[0].y),
      h = Math.abs(i[0].z);
    l <= c && ((c = l), n.set(1, 0, 0)),
      u <= c && ((c = u), n.set(0, 1, 0)),
      h <= c && n.set(0, 0, 1),
      o.crossVectors(i[0], n).normalize(),
      r[0].crossVectors(i[0], o),
      s[0].crossVectors(i[0], r[0]);
    for (let d = 1; d <= t; d++) {
      if (
        ((r[d] = r[d - 1].clone()),
        (s[d] = s[d - 1].clone()),
        o.crossVectors(i[d - 1], i[d]),
        o.length() > Number.EPSILON)
      ) {
        o.normalize();
        const f = Math.acos(Pt.clamp(i[d - 1].dot(i[d]), -1, 1));
        r[d].applyMatrix4(a.makeRotationAxis(o, f));
      }
      s[d].crossVectors(i[d], r[d]);
    }
    if (e === !0) {
      let d = Math.acos(Pt.clamp(r[0].dot(r[t]), -1, 1));
      (d /= t), i[0].dot(o.crossVectors(r[0], r[t])) > 0 && (d = -d);
      for (let f = 1; f <= t; f++)
        r[f].applyMatrix4(a.makeRotationAxis(i[f], d * f)),
          s[f].crossVectors(i[f], r[f]);
    }
    return { tangents: i, normals: r, binormals: s };
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return (this.arcLengthDivisions = t.arcLengthDivisions), this;
  },
  toJSON: function () {
    const t = {
      metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (t.arcLengthDivisions = this.arcLengthDivisions), (t.type = this.type), t
    );
  },
  fromJSON: function (t) {
    return (this.arcLengthDivisions = t.arcLengthDivisions), this;
  },
});
function xn(t, e, n, i, r, s, o, a) {
  _t.call(this),
    (this.type = "EllipseCurve"),
    (this.aX = t || 0),
    (this.aY = e || 0),
    (this.xRadius = n || 1),
    (this.yRadius = i || 1),
    (this.aStartAngle = r || 0),
    (this.aEndAngle = s || 2 * Math.PI),
    (this.aClockwise = o || !1),
    (this.aRotation = a || 0);
}
xn.prototype = Object.create(_t.prototype);
xn.prototype.constructor = xn;
xn.prototype.isEllipseCurve = !0;
xn.prototype.getPoint = function (t, e) {
  const n = e || new H(),
    i = Math.PI * 2;
  let r = this.aEndAngle - this.aStartAngle;
  const s = Math.abs(r) < Number.EPSILON;
  for (; r < 0; ) r += i;
  for (; r > i; ) r -= i;
  r < Number.EPSILON && (s ? (r = 0) : (r = i)),
    this.aClockwise === !0 && !s && (r === i ? (r = -i) : (r = r - i));
  const o = this.aStartAngle + t * r;
  let a = this.aX + this.xRadius * Math.cos(o),
    c = this.aY + this.yRadius * Math.sin(o);
  if (this.aRotation !== 0) {
    const l = Math.cos(this.aRotation),
      u = Math.sin(this.aRotation),
      h = a - this.aX,
      d = c - this.aY;
    (a = h * l - d * u + this.aX), (c = h * u + d * l + this.aY);
  }
  return n.set(a, c);
};
xn.prototype.copy = function (t) {
  return (
    _t.prototype.copy.call(this, t),
    (this.aX = t.aX),
    (this.aY = t.aY),
    (this.xRadius = t.xRadius),
    (this.yRadius = t.yRadius),
    (this.aStartAngle = t.aStartAngle),
    (this.aEndAngle = t.aEndAngle),
    (this.aClockwise = t.aClockwise),
    (this.aRotation = t.aRotation),
    this
  );
};
xn.prototype.toJSON = function () {
  const t = _t.prototype.toJSON.call(this);
  return (
    (t.aX = this.aX),
    (t.aY = this.aY),
    (t.xRadius = this.xRadius),
    (t.yRadius = this.yRadius),
    (t.aStartAngle = this.aStartAngle),
    (t.aEndAngle = this.aEndAngle),
    (t.aClockwise = this.aClockwise),
    (t.aRotation = this.aRotation),
    t
  );
};
xn.prototype.fromJSON = function (t) {
  return (
    _t.prototype.fromJSON.call(this, t),
    (this.aX = t.aX),
    (this.aY = t.aY),
    (this.xRadius = t.xRadius),
    (this.yRadius = t.yRadius),
    (this.aStartAngle = t.aStartAngle),
    (this.aEndAngle = t.aEndAngle),
    (this.aClockwise = t.aClockwise),
    (this.aRotation = t.aRotation),
    this
  );
};
function sa(t, e, n, i, r, s) {
  xn.call(this, t, e, n, n, i, r, s), (this.type = "ArcCurve");
}
sa.prototype = Object.create(xn.prototype);
sa.prototype.constructor = sa;
sa.prototype.isArcCurve = !0;
function Yh() {
  let t = 0,
    e = 0,
    n = 0,
    i = 0;
  function r(s, o, a, c) {
    (t = s),
      (e = a),
      (n = -3 * s + 3 * o - 2 * a - c),
      (i = 2 * s - 2 * o + a + c);
  }
  return {
    initCatmullRom: function (s, o, a, c, l) {
      r(o, a, l * (a - s), l * (c - o));
    },
    initNonuniformCatmullRom: function (s, o, a, c, l, u, h) {
      let d = (o - s) / l - (a - s) / (l + u) + (a - o) / u,
        f = (a - o) / u - (c - o) / (u + h) + (c - a) / h;
      (d *= u), (f *= u), r(o, a, d, f);
    },
    calc: function (s) {
      const o = s * s,
        a = o * s;
      return t + e * s + n * o + i * a;
    },
  };
}
const gl = new S(),
  Zh = new Yh(),
  Jh = new Yh(),
  $h = new Yh();
function Rn(t, e, n, i) {
  _t.call(this),
    (this.type = "CatmullRomCurve3"),
    (this.points = t || []),
    (this.closed = e || !1),
    (this.curveType = n || "centripetal"),
    (this.tension = i || 0.5);
}
Rn.prototype = Object.create(_t.prototype);
Rn.prototype.constructor = Rn;
Rn.prototype.isCatmullRomCurve3 = !0;
Rn.prototype.getPoint = function (t, e) {
  const n = e || new S(),
    i = this.points,
    r = i.length,
    s = (r - (this.closed ? 0 : 1)) * t;
  let o = Math.floor(s),
    a = s - o;
  this.closed
    ? (o += o > 0 ? 0 : (Math.floor(Math.abs(o) / r) + 1) * r)
    : a === 0 && o === r - 1 && ((o = r - 2), (a = 1));
  let c, l, u, h;
  if (
    (this.closed || o > 0
      ? (c = i[(o - 1) % r])
      : (gl.subVectors(i[0], i[1]).add(i[0]), (c = gl)),
    (l = i[o % r]),
    (u = i[(o + 1) % r]),
    this.closed || o + 2 < r
      ? (h = i[(o + 2) % r])
      : (gl.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (h = gl)),
    this.curveType === "centripetal" || this.curveType === "chordal")
  ) {
    const d = this.curveType === "chordal" ? 0.5 : 0.25;
    let f = Math.pow(c.distanceToSquared(l), d),
      p = Math.pow(l.distanceToSquared(u), d),
      _ = Math.pow(u.distanceToSquared(h), d);
    p < 1e-4 && (p = 1),
      f < 1e-4 && (f = p),
      _ < 1e-4 && (_ = p),
      Zh.initNonuniformCatmullRom(c.x, l.x, u.x, h.x, f, p, _),
      Jh.initNonuniformCatmullRom(c.y, l.y, u.y, h.y, f, p, _),
      $h.initNonuniformCatmullRom(c.z, l.z, u.z, h.z, f, p, _);
  } else
    this.curveType === "catmullrom" &&
      (Zh.initCatmullRom(c.x, l.x, u.x, h.x, this.tension),
      Jh.initCatmullRom(c.y, l.y, u.y, h.y, this.tension),
      $h.initCatmullRom(c.z, l.z, u.z, h.z, this.tension));
  return n.set(Zh.calc(a), Jh.calc(a), $h.calc(a)), n;
};
Rn.prototype.copy = function (t) {
  _t.prototype.copy.call(this, t), (this.points = []);
  for (let e = 0, n = t.points.length; e < n; e++) {
    const i = t.points[e];
    this.points.push(i.clone());
  }
  return (
    (this.closed = t.closed),
    (this.curveType = t.curveType),
    (this.tension = t.tension),
    this
  );
};
Rn.prototype.toJSON = function () {
  const t = _t.prototype.toJSON.call(this);
  t.points = [];
  for (let e = 0, n = this.points.length; e < n; e++) {
    const i = this.points[e];
    t.points.push(i.toArray());
  }
  return (
    (t.closed = this.closed),
    (t.curveType = this.curveType),
    (t.tension = this.tension),
    t
  );
};
Rn.prototype.fromJSON = function (t) {
  _t.prototype.fromJSON.call(this, t), (this.points = []);
  for (let e = 0, n = t.points.length; e < n; e++) {
    const i = t.points[e];
    this.points.push(new S().fromArray(i));
  }
  return (
    (this.closed = t.closed),
    (this.curveType = t.curveType),
    (this.tension = t.tension),
    this
  );
};
function Zm(t, e, n, i, r) {
  const s = (i - e) * 0.5,
    o = (r - n) * 0.5,
    a = t * t,
    c = t * a;
  return (
    (2 * n - 2 * i + s + o) * c + (-3 * n + 3 * i - 2 * s - o) * a + s * t + n
  );
}
function jM(t, e) {
  const n = 1 - t;
  return n * n * e;
}
function qM(t, e) {
  return 2 * (1 - t) * t * e;
}
function XM(t, e) {
  return t * t * e;
}
function oa(t, e, n, i) {
  return jM(t, e) + qM(t, n) + XM(t, i);
}
function YM(t, e) {
  const n = 1 - t;
  return n * n * n * e;
}
function ZM(t, e) {
  const n = 1 - t;
  return 3 * n * n * t * e;
}
function JM(t, e) {
  return 3 * (1 - t) * t * t * e;
}
function $M(t, e) {
  return t * t * t * e;
}
function aa(t, e, n, i, r) {
  return YM(t, e) + ZM(t, n) + JM(t, i) + $M(t, r);
}
function Xn(t, e, n, i) {
  _t.call(this),
    (this.type = "CubicBezierCurve"),
    (this.v0 = t || new H()),
    (this.v1 = e || new H()),
    (this.v2 = n || new H()),
    (this.v3 = i || new H());
}
Xn.prototype = Object.create(_t.prototype);
Xn.prototype.constructor = Xn;
Xn.prototype.isCubicBezierCurve = !0;
Xn.prototype.getPoint = function (t, e) {
  const n = e || new H(),
    i = this.v0,
    r = this.v1,
    s = this.v2,
    o = this.v3;
  return n.set(aa(t, i.x, r.x, s.x, o.x), aa(t, i.y, r.y, s.y, o.y)), n;
};
Xn.prototype.copy = function (t) {
  return (
    _t.prototype.copy.call(this, t),
    this.v0.copy(t.v0),
    this.v1.copy(t.v1),
    this.v2.copy(t.v2),
    this.v3.copy(t.v3),
    this
  );
};
Xn.prototype.toJSON = function () {
  const t = _t.prototype.toJSON.call(this);
  return (
    (t.v0 = this.v0.toArray()),
    (t.v1 = this.v1.toArray()),
    (t.v2 = this.v2.toArray()),
    (t.v3 = this.v3.toArray()),
    t
  );
};
Xn.prototype.fromJSON = function (t) {
  return (
    _t.prototype.fromJSON.call(this, t),
    this.v0.fromArray(t.v0),
    this.v1.fromArray(t.v1),
    this.v2.fromArray(t.v2),
    this.v3.fromArray(t.v3),
    this
  );
};
function gi(t, e, n, i) {
  _t.call(this),
    (this.type = "CubicBezierCurve3"),
    (this.v0 = t || new S()),
    (this.v1 = e || new S()),
    (this.v2 = n || new S()),
    (this.v3 = i || new S());
}
gi.prototype = Object.create(_t.prototype);
gi.prototype.constructor = gi;
gi.prototype.isCubicBezierCurve3 = !0;
gi.prototype.getPoint = function (t, e) {
  const n = e || new S(),
    i = this.v0,
    r = this.v1,
    s = this.v2,
    o = this.v3;
  return (
    n.set(
      aa(t, i.x, r.x, s.x, o.x),
      aa(t, i.y, r.y, s.y, o.y),
      aa(t, i.z, r.z, s.z, o.z)
    ),
    n
  );
};
gi.prototype.copy = function (t) {
  return (
    _t.prototype.copy.call(this, t),
    this.v0.copy(t.v0),
    this.v1.copy(t.v1),
    this.v2.copy(t.v2),
    this.v3.copy(t.v3),
    this
  );
};
gi.prototype.toJSON = function () {
  const t = _t.prototype.toJSON.call(this);
  return (
    (t.v0 = this.v0.toArray()),
    (t.v1 = this.v1.toArray()),
    (t.v2 = this.v2.toArray()),
    (t.v3 = this.v3.toArray()),
    t
  );
};
gi.prototype.fromJSON = function (t) {
  return (
    _t.prototype.fromJSON.call(this, t),
    this.v0.fromArray(t.v0),
    this.v1.fromArray(t.v1),
    this.v2.fromArray(t.v2),
    this.v3.fromArray(t.v3),
    this
  );
};
function cn(t, e) {
  _t.call(this),
    (this.type = "LineCurve"),
    (this.v1 = t || new H()),
    (this.v2 = e || new H());
}
cn.prototype = Object.create(_t.prototype);
cn.prototype.constructor = cn;
cn.prototype.isLineCurve = !0;
cn.prototype.getPoint = function (t, e) {
  const n = e || new H();
  return (
    t === 1
      ? n.copy(this.v2)
      : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
    n
  );
};
cn.prototype.getPointAt = function (t, e) {
  return this.getPoint(t, e);
};
cn.prototype.getTangent = function (t, e) {
  const n = e || new H();
  return n.copy(this.v2).sub(this.v1).normalize(), n;
};
cn.prototype.copy = function (t) {
  return (
    _t.prototype.copy.call(this, t),
    this.v1.copy(t.v1),
    this.v2.copy(t.v2),
    this
  );
};
cn.prototype.toJSON = function () {
  const t = _t.prototype.toJSON.call(this);
  return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
};
cn.prototype.fromJSON = function (t) {
  return (
    _t.prototype.fromJSON.call(this, t),
    this.v1.fromArray(t.v1),
    this.v2.fromArray(t.v2),
    this
  );
};
function Yn(t, e) {
  _t.call(this),
    (this.type = "LineCurve3"),
    (this.v1 = t || new S()),
    (this.v2 = e || new S());
}
Yn.prototype = Object.create(_t.prototype);
Yn.prototype.constructor = Yn;
Yn.prototype.isLineCurve3 = !0;
Yn.prototype.getPoint = function (t, e) {
  const n = e || new S();
  return (
    t === 1
      ? n.copy(this.v2)
      : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
    n
  );
};
Yn.prototype.getPointAt = function (t, e) {
  return this.getPoint(t, e);
};
Yn.prototype.copy = function (t) {
  return (
    _t.prototype.copy.call(this, t),
    this.v1.copy(t.v1),
    this.v2.copy(t.v2),
    this
  );
};
Yn.prototype.toJSON = function () {
  const t = _t.prototype.toJSON.call(this);
  return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
};
Yn.prototype.fromJSON = function (t) {
  return (
    _t.prototype.fromJSON.call(this, t),
    this.v1.fromArray(t.v1),
    this.v2.fromArray(t.v2),
    this
  );
};
function Zn(t, e, n) {
  _t.call(this),
    (this.type = "QuadraticBezierCurve"),
    (this.v0 = t || new H()),
    (this.v1 = e || new H()),
    (this.v2 = n || new H());
}
Zn.prototype = Object.create(_t.prototype);
Zn.prototype.constructor = Zn;
Zn.prototype.isQuadraticBezierCurve = !0;
Zn.prototype.getPoint = function (t, e) {
  const n = e || new H(),
    i = this.v0,
    r = this.v1,
    s = this.v2;
  return n.set(oa(t, i.x, r.x, s.x), oa(t, i.y, r.y, s.y)), n;
};
Zn.prototype.copy = function (t) {
  return (
    _t.prototype.copy.call(this, t),
    this.v0.copy(t.v0),
    this.v1.copy(t.v1),
    this.v2.copy(t.v2),
    this
  );
};
Zn.prototype.toJSON = function () {
  const t = _t.prototype.toJSON.call(this);
  return (
    (t.v0 = this.v0.toArray()),
    (t.v1 = this.v1.toArray()),
    (t.v2 = this.v2.toArray()),
    t
  );
};
Zn.prototype.fromJSON = function (t) {
  return (
    _t.prototype.fromJSON.call(this, t),
    this.v0.fromArray(t.v0),
    this.v1.fromArray(t.v1),
    this.v2.fromArray(t.v2),
    this
  );
};
function yi(t, e, n) {
  _t.call(this),
    (this.type = "QuadraticBezierCurve3"),
    (this.v0 = t || new S()),
    (this.v1 = e || new S()),
    (this.v2 = n || new S());
}
yi.prototype = Object.create(_t.prototype);
yi.prototype.constructor = yi;
yi.prototype.isQuadraticBezierCurve3 = !0;
yi.prototype.getPoint = function (t, e) {
  const n = e || new S(),
    i = this.v0,
    r = this.v1,
    s = this.v2;
  return (
    n.set(oa(t, i.x, r.x, s.x), oa(t, i.y, r.y, s.y), oa(t, i.z, r.z, s.z)), n
  );
};
yi.prototype.copy = function (t) {
  return (
    _t.prototype.copy.call(this, t),
    this.v0.copy(t.v0),
    this.v1.copy(t.v1),
    this.v2.copy(t.v2),
    this
  );
};
yi.prototype.toJSON = function () {
  const t = _t.prototype.toJSON.call(this);
  return (
    (t.v0 = this.v0.toArray()),
    (t.v1 = this.v1.toArray()),
    (t.v2 = this.v2.toArray()),
    t
  );
};
yi.prototype.fromJSON = function (t) {
  return (
    _t.prototype.fromJSON.call(this, t),
    this.v0.fromArray(t.v0),
    this.v1.fromArray(t.v1),
    this.v2.fromArray(t.v2),
    this
  );
};
function Jn(t) {
  _t.call(this), (this.type = "SplineCurve"), (this.points = t || []);
}
Jn.prototype = Object.create(_t.prototype);
Jn.prototype.constructor = Jn;
Jn.prototype.isSplineCurve = !0;
Jn.prototype.getPoint = function (t, e) {
  const n = e || new H(),
    i = this.points,
    r = (i.length - 1) * t,
    s = Math.floor(r),
    o = r - s,
    a = i[s === 0 ? s : s - 1],
    c = i[s],
    l = i[s > i.length - 2 ? i.length - 1 : s + 1],
    u = i[s > i.length - 3 ? i.length - 1 : s + 2];
  return n.set(Zm(o, a.x, c.x, l.x, u.x), Zm(o, a.y, c.y, l.y, u.y)), n;
};
Jn.prototype.copy = function (t) {
  _t.prototype.copy.call(this, t), (this.points = []);
  for (let e = 0, n = t.points.length; e < n; e++) {
    const i = t.points[e];
    this.points.push(i.clone());
  }
  return this;
};
Jn.prototype.toJSON = function () {
  const t = _t.prototype.toJSON.call(this);
  t.points = [];
  for (let e = 0, n = this.points.length; e < n; e++) {
    const i = this.points[e];
    t.points.push(i.toArray());
  }
  return t;
};
Jn.prototype.fromJSON = function (t) {
  _t.prototype.fromJSON.call(this, t), (this.points = []);
  for (let e = 0, n = t.points.length; e < n; e++) {
    const i = t.points[e];
    this.points.push(new H().fromArray(i));
  }
  return this;
};
var Qh = Object.freeze({
  __proto__: null,
  ArcCurve: sa,
  CatmullRomCurve3: Rn,
  CubicBezierCurve: Xn,
  CubicBezierCurve3: gi,
  EllipseCurve: xn,
  LineCurve: cn,
  LineCurve3: Yn,
  QuadraticBezierCurve: Zn,
  QuadraticBezierCurve3: yi,
  SplineCurve: Jn,
});
function Hi() {
  _t.call(this),
    (this.type = "CurvePath"),
    (this.curves = []),
    (this.autoClose = !1);
}
Hi.prototype = Object.assign(Object.create(_t.prototype), {
  constructor: Hi,
  add: function (t) {
    this.curves.push(t);
  },
  closePath: function () {
    const t = this.curves[0].getPoint(0),
      e = this.curves[this.curves.length - 1].getPoint(1);
    t.equals(e) || this.curves.push(new cn(e, t));
  },
  getPoint: function (t) {
    const e = t * this.getLength(),
      n = this.getCurveLengths();
    let i = 0;
    for (; i < n.length; ) {
      if (n[i] >= e) {
        const r = n[i] - e,
          s = this.curves[i],
          o = s.getLength(),
          a = o === 0 ? 0 : 1 - r / o;
        return s.getPointAt(a);
      }
      i++;
    }
    return null;
  },
  getLength: function () {
    const t = this.getCurveLengths();
    return t[t.length - 1];
  },
  updateArcLengths: function () {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  },
  getCurveLengths: function () {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const t = [];
    let e = 0;
    for (let n = 0, i = this.curves.length; n < i; n++)
      (e += this.curves[n].getLength()), t.push(e);
    return (this.cacheLengths = t), t;
  },
  getSpacedPoints: function (t) {
    t === void 0 && (t = 40);
    const e = [];
    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
    return this.autoClose && e.push(e[0]), e;
  },
  getPoints: function (t) {
    t = t || 12;
    const e = [];
    let n;
    for (let i = 0, r = this.curves; i < r.length; i++) {
      const s = r[i],
        o =
          s && s.isEllipseCurve
            ? t * 2
            : s && (s.isLineCurve || s.isLineCurve3)
            ? 1
            : s && s.isSplineCurve
            ? t * s.points.length
            : t,
        a = s.getPoints(o);
      for (let c = 0; c < a.length; c++) {
        const l = a[c];
        (n && n.equals(l)) || (e.push(l), (n = l));
      }
    }
    return (
      this.autoClose &&
        e.length > 1 &&
        !e[e.length - 1].equals(e[0]) &&
        e.push(e[0]),
      e
    );
  },
  copy: function (t) {
    _t.prototype.copy.call(this, t), (this.curves = []);
    for (let e = 0, n = t.curves.length; e < n; e++) {
      const i = t.curves[e];
      this.curves.push(i.clone());
    }
    return (this.autoClose = t.autoClose), this;
  },
  toJSON: function () {
    const t = _t.prototype.toJSON.call(this);
    (t.autoClose = this.autoClose), (t.curves = []);
    for (let e = 0, n = this.curves.length; e < n; e++) {
      const i = this.curves[e];
      t.curves.push(i.toJSON());
    }
    return t;
  },
  fromJSON: function (t) {
    _t.prototype.fromJSON.call(this, t),
      (this.autoClose = t.autoClose),
      (this.curves = []);
    for (let e = 0, n = t.curves.length; e < n; e++) {
      const i = t.curves[e];
      this.curves.push(new Qh[i.type]().fromJSON(i));
    }
    return this;
  },
});
function $n(t) {
  Hi.call(this),
    (this.type = "Path"),
    (this.currentPoint = new H()),
    t && this.setFromPoints(t);
}
$n.prototype = Object.assign(Object.create(Hi.prototype), {
  constructor: $n,
  setFromPoints: function (t) {
    this.moveTo(t[0].x, t[0].y);
    for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
    return this;
  },
  moveTo: function (t, e) {
    return this.currentPoint.set(t, e), this;
  },
  lineTo: function (t, e) {
    const n = new cn(this.currentPoint.clone(), new H(t, e));
    return this.curves.push(n), this.currentPoint.set(t, e), this;
  },
  quadraticCurveTo: function (t, e, n, i) {
    const r = new Zn(this.currentPoint.clone(), new H(t, e), new H(n, i));
    return this.curves.push(r), this.currentPoint.set(n, i), this;
  },
  bezierCurveTo: function (t, e, n, i, r, s) {
    const o = new Xn(
      this.currentPoint.clone(),
      new H(t, e),
      new H(n, i),
      new H(r, s)
    );
    return this.curves.push(o), this.currentPoint.set(r, s), this;
  },
  splineThru: function (t) {
    const e = [this.currentPoint.clone()].concat(t),
      n = new Jn(e);
    return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this;
  },
  arc: function (t, e, n, i, r, s) {
    const o = this.currentPoint.x,
      a = this.currentPoint.y;
    return this.absarc(t + o, e + a, n, i, r, s), this;
  },
  absarc: function (t, e, n, i, r, s) {
    return this.absellipse(t, e, n, n, i, r, s), this;
  },
  ellipse: function (t, e, n, i, r, s, o, a) {
    const c = this.currentPoint.x,
      l = this.currentPoint.y;
    return this.absellipse(t + c, e + l, n, i, r, s, o, a), this;
  },
  absellipse: function (t, e, n, i, r, s, o, a) {
    const c = new xn(t, e, n, i, r, s, o, a);
    if (this.curves.length > 0) {
      const u = c.getPoint(0);
      u.equals(this.currentPoint) || this.lineTo(u.x, u.y);
    }
    this.curves.push(c);
    const l = c.getPoint(1);
    return this.currentPoint.copy(l), this;
  },
  copy: function (t) {
    return (
      Hi.prototype.copy.call(this, t),
      this.currentPoint.copy(t.currentPoint),
      this
    );
  },
  toJSON: function () {
    const t = Hi.prototype.toJSON.call(this);
    return (t.currentPoint = this.currentPoint.toArray()), t;
  },
  fromJSON: function (t) {
    return (
      Hi.prototype.fromJSON.call(this, t),
      this.currentPoint.fromArray(t.currentPoint),
      this
    );
  },
});
function xr(t) {
  $n.call(this, t),
    (this.uuid = Pt.generateUUID()),
    (this.type = "Shape"),
    (this.holes = []);
}
xr.prototype = Object.assign(Object.create($n.prototype), {
  constructor: xr,
  getPointsHoles: function (t) {
    const e = [];
    for (let n = 0, i = this.holes.length; n < i; n++)
      e[n] = this.holes[n].getPoints(t);
    return e;
  },
  extractPoints: function (t) {
    return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
  },
  copy: function (t) {
    $n.prototype.copy.call(this, t), (this.holes = []);
    for (let e = 0, n = t.holes.length; e < n; e++) {
      const i = t.holes[e];
      this.holes.push(i.clone());
    }
    return this;
  },
  toJSON: function () {
    const t = $n.prototype.toJSON.call(this);
    (t.uuid = this.uuid), (t.holes = []);
    for (let e = 0, n = this.holes.length; e < n; e++) {
      const i = this.holes[e];
      t.holes.push(i.toJSON());
    }
    return t;
  },
  fromJSON: function (t) {
    $n.prototype.fromJSON.call(this, t),
      (this.uuid = t.uuid),
      (this.holes = []);
    for (let e = 0, n = t.holes.length; e < n; e++) {
      const i = t.holes[e];
      this.holes.push(new $n().fromJSON(i));
    }
    return this;
  },
});
function ee(t, e) {
  nt.call(this),
    (this.type = "Light"),
    (this.color = new lt(t)),
    (this.intensity = e !== void 0 ? e : 1),
    (this.receiveShadow = void 0);
}
ee.prototype = Object.assign(Object.create(nt.prototype), {
  constructor: ee,
  isLight: !0,
  copy: function (t) {
    return (
      nt.prototype.copy.call(this, t),
      this.color.copy(t.color),
      (this.intensity = t.intensity),
      this
    );
  },
  toJSON: function (t) {
    const e = nt.prototype.toJSON.call(this, t);
    return (
      (e.object.color = this.color.getHex()),
      (e.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (e.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (e.object.distance = this.distance),
      this.angle !== void 0 && (e.object.angle = this.angle),
      this.decay !== void 0 && (e.object.decay = this.decay),
      this.penumbra !== void 0 && (e.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()),
      e
    );
  },
});
function Kh(t, e, n) {
  ee.call(this, t, n),
    (this.type = "HemisphereLight"),
    (this.castShadow = void 0),
    this.position.copy(nt.DefaultUp),
    this.updateMatrix(),
    (this.groundColor = new lt(e));
}
Kh.prototype = Object.assign(Object.create(ee.prototype), {
  constructor: Kh,
  isHemisphereLight: !0,
  copy: function (t) {
    return (
      ee.prototype.copy.call(this, t),
      this.groundColor.copy(t.groundColor),
      this
    );
  },
});
function _i(t) {
  (this.camera = t),
    (this.bias = 0),
    (this.normalBias = 0),
    (this.radius = 1),
    (this.mapSize = new H(512, 512)),
    (this.map = null),
    (this.mapPass = null),
    (this.matrix = new Rt()),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this._frustum = new Ro()),
    (this._frameExtents = new H(1, 1)),
    (this._viewportCount = 1),
    (this._viewports = [new Vt(0, 0, 1, 1)]);
}
Object.assign(_i.prototype, {
  _projScreenMatrix: new Rt(),
  _lightPositionWorld: new S(),
  _lookTarget: new S(),
  getViewportCount: function () {
    return this._viewportCount;
  },
  getFrustum: function () {
    return this._frustum;
  },
  updateMatrices: function (t) {
    const e = this.camera,
      n = this.matrix,
      i = this._projScreenMatrix,
      r = this._lookTarget,
      s = this._lightPositionWorld;
    s.setFromMatrixPosition(t.matrixWorld),
      e.position.copy(s),
      r.setFromMatrixPosition(t.target.matrixWorld),
      e.lookAt(r),
      e.updateMatrixWorld(),
      i.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(i),
      n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      n.multiply(e.projectionMatrix),
      n.multiply(e.matrixWorldInverse);
  },
  getViewport: function (t) {
    return this._viewports[t];
  },
  getFrameExtents: function () {
    return this._frameExtents;
  },
  copy: function (t) {
    return (
      (this.camera = t.camera.clone()),
      (this.bias = t.bias),
      (this.radius = t.radius),
      this.mapSize.copy(t.mapSize),
      this
    );
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  toJSON: function () {
    const t = {};
    return (
      this.bias !== 0 && (t.bias = this.bias),
      this.normalBias !== 0 && (t.normalBias = this.normalBias),
      this.radius !== 1 && (t.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (t.mapSize = this.mapSize.toArray()),
      (t.camera = this.camera.toJSON(!1).object),
      delete t.camera.matrix,
      t
    );
  },
});
function tf() {
  _i.call(this, new Pe(50, 1, 0.5, 500));
}
tf.prototype = Object.assign(Object.create(_i.prototype), {
  constructor: tf,
  isSpotLightShadow: !0,
  updateMatrices: function (t) {
    const e = this.camera,
      n = Pt.RAD2DEG * 2 * t.angle,
      i = this.mapSize.width / this.mapSize.height,
      r = t.distance || e.far;
    (n !== e.fov || i !== e.aspect || r !== e.far) &&
      ((e.fov = n), (e.aspect = i), (e.far = r), e.updateProjectionMatrix()),
      _i.prototype.updateMatrices.call(this, t);
  },
});
function ef(t, e, n, i, r, s) {
  ee.call(this, t, e),
    (this.type = "SpotLight"),
    this.position.copy(nt.DefaultUp),
    this.updateMatrix(),
    (this.target = new nt()),
    Object.defineProperty(this, "power", {
      get: function () {
        return this.intensity * Math.PI;
      },
      set: function (o) {
        this.intensity = o / Math.PI;
      },
    }),
    (this.distance = n !== void 0 ? n : 0),
    (this.angle = i !== void 0 ? i : Math.PI / 3),
    (this.penumbra = r !== void 0 ? r : 0),
    (this.decay = s !== void 0 ? s : 1),
    (this.shadow = new tf());
}
ef.prototype = Object.assign(Object.create(ee.prototype), {
  constructor: ef,
  isSpotLight: !0,
  copy: function (t) {
    return (
      ee.prototype.copy.call(this, t),
      (this.distance = t.distance),
      (this.angle = t.angle),
      (this.penumbra = t.penumbra),
      (this.decay = t.decay),
      (this.target = t.target.clone()),
      (this.shadow = t.shadow.clone()),
      this
    );
  },
});
function nf() {
  _i.call(this, new Pe(90, 1, 0.5, 500)),
    (this._frameExtents = new H(4, 2)),
    (this._viewportCount = 6),
    (this._viewports = [
      new Vt(2, 1, 1, 1),
      new Vt(0, 1, 1, 1),
      new Vt(3, 1, 1, 1),
      new Vt(1, 1, 1, 1),
      new Vt(3, 0, 1, 1),
      new Vt(1, 0, 1, 1),
    ]),
    (this._cubeDirections = [
      new S(1, 0, 0),
      new S(-1, 0, 0),
      new S(0, 0, 1),
      new S(0, 0, -1),
      new S(0, 1, 0),
      new S(0, -1, 0),
    ]),
    (this._cubeUps = [
      new S(0, 1, 0),
      new S(0, 1, 0),
      new S(0, 1, 0),
      new S(0, 1, 0),
      new S(0, 0, 1),
      new S(0, 0, -1),
    ]);
}
nf.prototype = Object.assign(Object.create(_i.prototype), {
  constructor: nf,
  isPointLightShadow: !0,
  updateMatrices: function (t, e) {
    e === void 0 && (e = 0);
    const n = this.camera,
      i = this.matrix,
      r = this._lightPositionWorld,
      s = this._lookTarget,
      o = this._projScreenMatrix;
    r.setFromMatrixPosition(t.matrixWorld),
      n.position.copy(r),
      s.copy(n.position),
      s.add(this._cubeDirections[e]),
      n.up.copy(this._cubeUps[e]),
      n.lookAt(s),
      n.updateMatrixWorld(),
      i.makeTranslation(-r.x, -r.y, -r.z),
      o.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(o);
  },
});
function rf(t, e, n, i) {
  ee.call(this, t, e),
    (this.type = "PointLight"),
    Object.defineProperty(this, "power", {
      get: function () {
        return this.intensity * 4 * Math.PI;
      },
      set: function (r) {
        this.intensity = r / (4 * Math.PI);
      },
    }),
    (this.distance = n !== void 0 ? n : 0),
    (this.decay = i !== void 0 ? i : 1),
    (this.shadow = new nf());
}
rf.prototype = Object.assign(Object.create(ee.prototype), {
  constructor: rf,
  isPointLight: !0,
  copy: function (t) {
    return (
      ee.prototype.copy.call(this, t),
      (this.distance = t.distance),
      (this.decay = t.decay),
      (this.shadow = t.shadow.clone()),
      this
    );
  },
});
function ca(t, e, n, i, r, s) {
  fi.call(this),
    (this.type = "OrthographicCamera"),
    (this.zoom = 1),
    (this.view = null),
    (this.left = t !== void 0 ? t : -1),
    (this.right = e !== void 0 ? e : 1),
    (this.top = n !== void 0 ? n : 1),
    (this.bottom = i !== void 0 ? i : -1),
    (this.near = r !== void 0 ? r : 0.1),
    (this.far = s !== void 0 ? s : 2e3),
    this.updateProjectionMatrix();
}
ca.prototype = Object.assign(Object.create(fi.prototype), {
  constructor: ca,
  isOrthographicCamera: !0,
  copy: function (t, e) {
    return (
      fi.prototype.copy.call(this, t, e),
      (this.left = t.left),
      (this.right = t.right),
      (this.top = t.top),
      (this.bottom = t.bottom),
      (this.near = t.near),
      (this.far = t.far),
      (this.zoom = t.zoom),
      (this.view = t.view === null ? null : Object.assign({}, t.view)),
      this
    );
  },
  setViewOffset: function (t, e, n, i, r, s) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = t),
      (this.view.fullHeight = e),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = r),
      (this.view.height = s),
      this.updateProjectionMatrix();
  },
  clearViewOffset: function () {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function () {
    const t = (this.right - this.left) / (2 * this.zoom),
      e = (this.top - this.bottom) / (2 * this.zoom),
      n = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2;
    let r = n - t,
      s = n + t,
      o = i + e,
      a = i - e;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
        l = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (r += c * this.view.offsetX),
        (s = r + c * this.view.width),
        (o -= l * this.view.offsetY),
        (a = o - l * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(r, s, o, a, this.near, this.far),
      this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  },
  toJSON: function (t) {
    const e = nt.prototype.toJSON.call(this, t);
    return (
      (e.object.zoom = this.zoom),
      (e.object.left = this.left),
      (e.object.right = this.right),
      (e.object.top = this.top),
      (e.object.bottom = this.bottom),
      (e.object.near = this.near),
      (e.object.far = this.far),
      this.view !== null && (e.object.view = Object.assign({}, this.view)),
      e
    );
  },
});
function sf() {
  _i.call(this, new ca(-5, 5, 5, -5, 0.5, 500));
}
sf.prototype = Object.assign(Object.create(_i.prototype), {
  constructor: sf,
  isDirectionalLightShadow: !0,
  updateMatrices: function (t) {
    _i.prototype.updateMatrices.call(this, t);
  },
});
function of(t, e) {
  ee.call(this, t, e),
    (this.type = "DirectionalLight"),
    this.position.copy(nt.DefaultUp),
    this.updateMatrix(),
    (this.target = new nt()),
    (this.shadow = new sf());
}
of.prototype = Object.assign(Object.create(ee.prototype), {
  constructor: of,
  isDirectionalLight: !0,
  copy: function (t) {
    return (
      ee.prototype.copy.call(this, t),
      (this.target = t.target.clone()),
      (this.shadow = t.shadow.clone()),
      this
    );
  },
});
function af(t, e) {
  ee.call(this, t, e), (this.type = "AmbientLight"), (this.castShadow = void 0);
}
af.prototype = Object.assign(Object.create(ee.prototype), {
  constructor: af,
  isAmbientLight: !0,
});
function cf(t, e, n, i) {
  ee.call(this, t, e),
    (this.type = "RectAreaLight"),
    (this.width = n !== void 0 ? n : 10),
    (this.height = i !== void 0 ? i : 10);
}
cf.prototype = Object.assign(Object.create(ee.prototype), {
  constructor: cf,
  isRectAreaLight: !0,
  copy: function (t) {
    return (
      ee.prototype.copy.call(this, t),
      (this.width = t.width),
      (this.height = t.height),
      this
    );
  },
  toJSON: function (t) {
    const e = ee.prototype.toJSON.call(this, t);
    return (e.object.width = this.width), (e.object.height = this.height), e;
  },
});
function lf() {
  this.coefficients = [];
  for (let t = 0; t < 9; t++) this.coefficients.push(new S());
}
Object.assign(lf.prototype, {
  isSphericalHarmonics3: !0,
  set: function (t) {
    for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
    return this;
  },
  zero: function () {
    for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
    return this;
  },
  getAt: function (t, e) {
    const n = t.x,
      i = t.y,
      r = t.z,
      s = this.coefficients;
    return (
      e.copy(s[0]).multiplyScalar(0.282095),
      e.addScaledVector(s[1], 0.488603 * i),
      e.addScaledVector(s[2], 0.488603 * r),
      e.addScaledVector(s[3], 0.488603 * n),
      e.addScaledVector(s[4], 1.092548 * (n * i)),
      e.addScaledVector(s[5], 1.092548 * (i * r)),
      e.addScaledVector(s[6], 0.315392 * (3 * r * r - 1)),
      e.addScaledVector(s[7], 1.092548 * (n * r)),
      e.addScaledVector(s[8], 0.546274 * (n * n - i * i)),
      e
    );
  },
  getIrradianceAt: function (t, e) {
    const n = t.x,
      i = t.y,
      r = t.z,
      s = this.coefficients;
    return (
      e.copy(s[0]).multiplyScalar(0.886227),
      e.addScaledVector(s[1], 2 * 0.511664 * i),
      e.addScaledVector(s[2], 2 * 0.511664 * r),
      e.addScaledVector(s[3], 2 * 0.511664 * n),
      e.addScaledVector(s[4], 2 * 0.429043 * n * i),
      e.addScaledVector(s[5], 2 * 0.429043 * i * r),
      e.addScaledVector(s[6], 0.743125 * r * r - 0.247708),
      e.addScaledVector(s[7], 2 * 0.429043 * n * r),
      e.addScaledVector(s[8], 0.429043 * (n * n - i * i)),
      e
    );
  },
  add: function (t) {
    for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
    return this;
  },
  addScaledSH: function (t, e) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(t.coefficients[n], e);
    return this;
  },
  scale: function (t) {
    for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
    return this;
  },
  lerp: function (t, e) {
    for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
    return this;
  },
  equals: function (t) {
    for (let e = 0; e < 9; e++)
      if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
    return !0;
  },
  copy: function (t) {
    return this.set(t.coefficients);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  fromArray: function (t, e) {
    e === void 0 && (e = 0);
    const n = this.coefficients;
    for (let i = 0; i < 9; i++) n[i].fromArray(t, e + i * 3);
    return this;
  },
  toArray: function (t, e) {
    t === void 0 && (t = []), e === void 0 && (e = 0);
    const n = this.coefficients;
    for (let i = 0; i < 9; i++) n[i].toArray(t, e + i * 3);
    return t;
  },
});
Object.assign(lf, {
  getBasisAt: function (t, e) {
    const n = t.x,
      i = t.y,
      r = t.z;
    (e[0] = 0.282095),
      (e[1] = 0.488603 * i),
      (e[2] = 0.488603 * r),
      (e[3] = 0.488603 * n),
      (e[4] = 1.092548 * n * i),
      (e[5] = 1.092548 * i * r),
      (e[6] = 0.315392 * (3 * r * r - 1)),
      (e[7] = 1.092548 * n * r),
      (e[8] = 0.546274 * (n * n - i * i));
  },
});
function On(t, e) {
  ee.call(this, void 0, e),
    (this.type = "LightProbe"),
    (this.sh = t !== void 0 ? t : new lf());
}
On.prototype = Object.assign(Object.create(ee.prototype), {
  constructor: On,
  isLightProbe: !0,
  copy: function (t) {
    return ee.prototype.copy.call(this, t), this.sh.copy(t.sh), this;
  },
  fromJSON: function (t) {
    return (this.intensity = t.intensity), this.sh.fromArray(t.sh), this;
  },
  toJSON: function (t) {
    const e = ee.prototype.toJSON.call(this, t);
    return (e.object.sh = this.sh.toArray()), e;
  },
});
function uf(t) {
  Wt.call(this, t), (this.textures = {});
}
uf.prototype = Object.assign(Object.create(Wt.prototype), {
  constructor: uf,
  load: function (t, e, n, i) {
    const r = this,
      s = new qn(r.manager);
    s.setPath(r.path),
      s.load(
        t,
        function (o) {
          try {
            e(r.parse(JSON.parse(o)));
          } catch (a) {
            i ? i(a) : console.error(a), r.manager.itemError(t);
          }
        },
        n,
        i
      );
  },
  parse: function (t) {
    const e = this.textures;
    function n(r) {
      return (
        e[r] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", r),
        e[r]
      );
    }
    const i = new GM[t.type]();
    if (
      (t.uuid !== void 0 && (i.uuid = t.uuid),
      t.name !== void 0 && (i.name = t.name),
      t.color !== void 0 && i.color.setHex(t.color),
      t.roughness !== void 0 && (i.roughness = t.roughness),
      t.metalness !== void 0 && (i.metalness = t.metalness),
      t.sheen !== void 0 && (i.sheen = new lt().setHex(t.sheen)),
      t.emissive !== void 0 && i.emissive.setHex(t.emissive),
      t.specular !== void 0 && i.specular.setHex(t.specular),
      t.shininess !== void 0 && (i.shininess = t.shininess),
      t.clearcoat !== void 0 && (i.clearcoat = t.clearcoat),
      t.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = t.clearcoatRoughness),
      t.fog !== void 0 && (i.fog = t.fog),
      t.flatShading !== void 0 && (i.flatShading = t.flatShading),
      t.blending !== void 0 && (i.blending = t.blending),
      t.combine !== void 0 && (i.combine = t.combine),
      t.side !== void 0 && (i.side = t.side),
      t.opacity !== void 0 && (i.opacity = t.opacity),
      t.transparent !== void 0 && (i.transparent = t.transparent),
      t.alphaTest !== void 0 && (i.alphaTest = t.alphaTest),
      t.depthTest !== void 0 && (i.depthTest = t.depthTest),
      t.depthWrite !== void 0 && (i.depthWrite = t.depthWrite),
      t.colorWrite !== void 0 && (i.colorWrite = t.colorWrite),
      t.stencilWrite !== void 0 && (i.stencilWrite = t.stencilWrite),
      t.stencilWriteMask !== void 0 &&
        (i.stencilWriteMask = t.stencilWriteMask),
      t.stencilFunc !== void 0 && (i.stencilFunc = t.stencilFunc),
      t.stencilRef !== void 0 && (i.stencilRef = t.stencilRef),
      t.stencilFuncMask !== void 0 && (i.stencilFuncMask = t.stencilFuncMask),
      t.stencilFail !== void 0 && (i.stencilFail = t.stencilFail),
      t.stencilZFail !== void 0 && (i.stencilZFail = t.stencilZFail),
      t.stencilZPass !== void 0 && (i.stencilZPass = t.stencilZPass),
      t.wireframe !== void 0 && (i.wireframe = t.wireframe),
      t.wireframeLinewidth !== void 0 &&
        (i.wireframeLinewidth = t.wireframeLinewidth),
      t.wireframeLinecap !== void 0 &&
        (i.wireframeLinecap = t.wireframeLinecap),
      t.wireframeLinejoin !== void 0 &&
        (i.wireframeLinejoin = t.wireframeLinejoin),
      t.rotation !== void 0 && (i.rotation = t.rotation),
      t.linewidth !== 1 && (i.linewidth = t.linewidth),
      t.dashSize !== void 0 && (i.dashSize = t.dashSize),
      t.gapSize !== void 0 && (i.gapSize = t.gapSize),
      t.scale !== void 0 && (i.scale = t.scale),
      t.polygonOffset !== void 0 && (i.polygonOffset = t.polygonOffset),
      t.polygonOffsetFactor !== void 0 &&
        (i.polygonOffsetFactor = t.polygonOffsetFactor),
      t.polygonOffsetUnits !== void 0 &&
        (i.polygonOffsetUnits = t.polygonOffsetUnits),
      t.skinning !== void 0 && (i.skinning = t.skinning),
      t.morphTargets !== void 0 && (i.morphTargets = t.morphTargets),
      t.morphNormals !== void 0 && (i.morphNormals = t.morphNormals),
      t.dithering !== void 0 && (i.dithering = t.dithering),
      t.vertexTangents !== void 0 && (i.vertexTangents = t.vertexTangents),
      t.visible !== void 0 && (i.visible = t.visible),
      t.toneMapped !== void 0 && (i.toneMapped = t.toneMapped),
      t.userData !== void 0 && (i.userData = t.userData),
      t.vertexColors !== void 0 &&
        (typeof t.vertexColors == "number"
          ? (i.vertexColors = t.vertexColors > 0)
          : (i.vertexColors = t.vertexColors)),
      t.uniforms !== void 0)
    )
      for (const r in t.uniforms) {
        const s = t.uniforms[r];
        switch (((i.uniforms[r] = {}), s.type)) {
          case "t":
            i.uniforms[r].value = n(s.value);
            break;
          case "c":
            i.uniforms[r].value = new lt().setHex(s.value);
            break;
          case "v2":
            i.uniforms[r].value = new H().fromArray(s.value);
            break;
          case "v3":
            i.uniforms[r].value = new S().fromArray(s.value);
            break;
          case "v4":
            i.uniforms[r].value = new Vt().fromArray(s.value);
            break;
          case "m3":
            i.uniforms[r].value = new Ge().fromArray(s.value);
          case "m4":
            i.uniforms[r].value = new Rt().fromArray(s.value);
            break;
          default:
            i.uniforms[r].value = s.value;
        }
      }
    if (
      (t.defines !== void 0 && (i.defines = t.defines),
      t.vertexShader !== void 0 && (i.vertexShader = t.vertexShader),
      t.fragmentShader !== void 0 && (i.fragmentShader = t.fragmentShader),
      t.extensions !== void 0)
    )
      for (const r in t.extensions) i.extensions[r] = t.extensions[r];
    if (
      (t.shading !== void 0 && (i.flatShading = t.shading === 1),
      t.size !== void 0 && (i.size = t.size),
      t.sizeAttenuation !== void 0 && (i.sizeAttenuation = t.sizeAttenuation),
      t.map !== void 0 && (i.map = n(t.map)),
      t.matcap !== void 0 && (i.matcap = n(t.matcap)),
      t.alphaMap !== void 0 && (i.alphaMap = n(t.alphaMap)),
      t.bumpMap !== void 0 && (i.bumpMap = n(t.bumpMap)),
      t.bumpScale !== void 0 && (i.bumpScale = t.bumpScale),
      t.normalMap !== void 0 && (i.normalMap = n(t.normalMap)),
      t.normalMapType !== void 0 && (i.normalMapType = t.normalMapType),
      t.normalScale !== void 0)
    ) {
      let r = t.normalScale;
      Array.isArray(r) === !1 && (r = [r, r]),
        (i.normalScale = new H().fromArray(r));
    }
    return (
      t.displacementMap !== void 0 &&
        (i.displacementMap = n(t.displacementMap)),
      t.displacementScale !== void 0 &&
        (i.displacementScale = t.displacementScale),
      t.displacementBias !== void 0 &&
        (i.displacementBias = t.displacementBias),
      t.roughnessMap !== void 0 && (i.roughnessMap = n(t.roughnessMap)),
      t.metalnessMap !== void 0 && (i.metalnessMap = n(t.metalnessMap)),
      t.emissiveMap !== void 0 && (i.emissiveMap = n(t.emissiveMap)),
      t.emissiveIntensity !== void 0 &&
        (i.emissiveIntensity = t.emissiveIntensity),
      t.specularMap !== void 0 && (i.specularMap = n(t.specularMap)),
      t.envMap !== void 0 && (i.envMap = n(t.envMap)),
      t.envMapIntensity !== void 0 && (i.envMapIntensity = t.envMapIntensity),
      t.reflectivity !== void 0 && (i.reflectivity = t.reflectivity),
      t.refractionRatio !== void 0 && (i.refractionRatio = t.refractionRatio),
      t.lightMap !== void 0 && (i.lightMap = n(t.lightMap)),
      t.lightMapIntensity !== void 0 &&
        (i.lightMapIntensity = t.lightMapIntensity),
      t.aoMap !== void 0 && (i.aoMap = n(t.aoMap)),
      t.aoMapIntensity !== void 0 && (i.aoMapIntensity = t.aoMapIntensity),
      t.gradientMap !== void 0 && (i.gradientMap = n(t.gradientMap)),
      t.clearcoatMap !== void 0 && (i.clearcoatMap = n(t.clearcoatMap)),
      t.clearcoatRoughnessMap !== void 0 &&
        (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)),
      t.clearcoatNormalMap !== void 0 &&
        (i.clearcoatNormalMap = n(t.clearcoatNormalMap)),
      t.clearcoatNormalScale !== void 0 &&
        (i.clearcoatNormalScale = new H().fromArray(t.clearcoatNormalScale)),
      i
    );
  },
  setTextures: function (t) {
    return (this.textures = t), this;
  },
});
const Jm = {
  decodeText: function (t) {
    if (typeof TextDecoder != "undefined") return new TextDecoder().decode(t);
    let e = "";
    for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]);
    try {
      return decodeURIComponent(escape(e));
    } catch {
      return e;
    }
  },
  extractUrlBase: function (t) {
    const e = t.lastIndexOf("/");
    return e === -1 ? "./" : t.substr(0, e + 1);
  },
};
function yl() {
  ct.call(this),
    (this.type = "InstancedBufferGeometry"),
    (this.instanceCount = 1 / 0);
}
yl.prototype = Object.assign(Object.create(ct.prototype), {
  constructor: yl,
  isInstancedBufferGeometry: !0,
  copy: function (t) {
    return (
      ct.prototype.copy.call(this, t),
      (this.instanceCount = t.instanceCount),
      this
    );
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  toJSON: function () {
    const t = ct.prototype.toJSON.call(this);
    return (
      (t.instanceCount = this.instanceCount),
      (t.isInstancedBufferGeometry = !0),
      t
    );
  },
});
function hf(t, e, n, i) {
  typeof n == "number" &&
    ((i = n),
    (n = !1),
    console.error(
      "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
    )),
    wt.call(this, t, e, n),
    (this.meshPerAttribute = i || 1);
}
hf.prototype = Object.assign(Object.create(wt.prototype), {
  constructor: hf,
  isInstancedBufferAttribute: !0,
  copy: function (t) {
    return (
      wt.prototype.copy.call(this, t),
      (this.meshPerAttribute = t.meshPerAttribute),
      this
    );
  },
  toJSON: function () {
    const t = wt.prototype.toJSON.call(this);
    return (
      (t.meshPerAttribute = this.meshPerAttribute),
      (t.isInstancedBufferAttribute = !0),
      t
    );
  },
});
function ff(t) {
  Wt.call(this, t);
}
ff.prototype = Object.assign(Object.create(Wt.prototype), {
  constructor: ff,
  load: function (t, e, n, i) {
    const r = this,
      s = new qn(r.manager);
    s.setPath(r.path),
      s.load(
        t,
        function (o) {
          try {
            e(r.parse(JSON.parse(o)));
          } catch (a) {
            i ? i(a) : console.error(a), r.manager.itemError(t);
          }
        },
        n,
        i
      );
  },
  parse: function (t) {
    const e = {},
      n = {};
    function i(d, f) {
      if (e[f] !== void 0) return e[f];
      const _ = d.interleavedBuffers[f],
        y = r(d, _.buffer),
        m = new _l[_.type](y),
        g = new gn(m, _.stride);
      return (g.uuid = _.uuid), (e[f] = g), g;
    }
    function r(d, f) {
      if (n[f] !== void 0) return n[f];
      const _ = d.arrayBuffers[f],
        y = new Uint32Array(_).buffer;
      return (n[f] = y), y;
    }
    const s = t.isInstancedBufferGeometry ? new yl() : new ct(),
      o = t.data.index;
    if (o !== void 0) {
      const d = new _l[o.type](o.array);
      s.setIndex(new wt(d, 1));
    }
    const a = t.data.attributes;
    for (const d in a) {
      const f = a[d];
      let p;
      if (f.isInterleavedBufferAttribute) {
        const _ = i(t.data, f.data);
        p = new mr(_, f.itemSize, f.offset, f.normalized);
      } else {
        const _ = new _l[f.type](f.array),
          y = f.isInstancedBufferAttribute ? hf : wt;
        p = new y(_, f.itemSize, f.normalized);
      }
      f.name !== void 0 && (p.name = f.name), s.setAttribute(d, p);
    }
    const c = t.data.morphAttributes;
    if (c)
      for (const d in c) {
        const f = c[d],
          p = [];
        for (let _ = 0, y = f.length; _ < y; _++) {
          const m = f[_];
          let g;
          if (m.isInterleavedBufferAttribute) {
            const b = i(t.data, m.data);
            g = new mr(b, m.itemSize, m.offset, m.normalized);
          } else {
            const b = new _l[m.type](m.array);
            g = new wt(b, m.itemSize, m.normalized);
          }
          m.name !== void 0 && (g.name = m.name), p.push(g);
        }
        s.morphAttributes[d] = p;
      }
    t.data.morphTargetsRelative && (s.morphTargetsRelative = !0);
    const u = t.data.groups || t.data.drawcalls || t.data.offsets;
    if (u !== void 0)
      for (let d = 0, f = u.length; d !== f; ++d) {
        const p = u[d];
        s.addGroup(p.start, p.count, p.materialIndex);
      }
    const h = t.data.boundingSphere;
    if (h !== void 0) {
      const d = new S();
      h.center !== void 0 && d.fromArray(h.center),
        (s.boundingSphere = new ci(d, h.radius));
    }
    return (
      t.name && (s.name = t.name), t.userData && (s.userData = t.userData), s
    );
  },
});
const _l = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray:
    typeof Uint8ClampedArray != "undefined" ? Uint8ClampedArray : Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function df(t) {
  Wt.call(this, t);
}
df.prototype = Object.assign(Object.create(Wt.prototype), {
  constructor: df,
  load: function (t, e, n, i) {
    const r = this,
      s = this.path === "" ? Jm.extractUrlBase(t) : this.path;
    this.resourcePath = this.resourcePath || s;
    const o = new qn(r.manager);
    o.setPath(this.path),
      o.load(
        t,
        function (a) {
          let c = null;
          try {
            c = JSON.parse(a);
          } catch (u) {
            i !== void 0 && i(u),
              console.error(
                "THREE:ObjectLoader: Can't parse " + t + ".",
                u.message
              );
            return;
          }
          const l = c.metadata;
          if (
            l === void 0 ||
            l.type === void 0 ||
            l.type.toLowerCase() === "geometry"
          ) {
            console.error("THREE.ObjectLoader: Can't load " + t);
            return;
          }
          r.parse(c, e);
        },
        n,
        i
      );
  },
  parse: function (t, e) {
    const n = this.parseShape(t.shapes),
      i = this.parseGeometries(t.geometries, n),
      r = this.parseImages(t.images, function () {
        e !== void 0 && e(a);
      }),
      s = this.parseTextures(t.textures, r),
      o = this.parseMaterials(t.materials, s),
      a = this.parseObject(t.object, i, o);
    return (
      t.animations && (a.animations = this.parseAnimations(t.animations)),
      (t.images === void 0 || t.images.length === 0) && e !== void 0 && e(a),
      a
    );
  },
  parseShape: function (t) {
    const e = {};
    if (t !== void 0)
      for (let n = 0, i = t.length; n < i; n++) {
        const r = new xr().fromJSON(t[n]);
        e[r.uuid] = r;
      }
    return e;
  },
  parseGeometries: function (t, e) {
    const n = {};
    let i;
    if (t !== void 0) {
      const r = new ff();
      for (let s = 0, o = t.length; s < o; s++) {
        let a;
        const c = t[s];
        switch (c.type) {
          case "PlaneGeometry":
          case "PlaneBufferGeometry":
            a = new He[c.type](
              c.width,
              c.height,
              c.widthSegments,
              c.heightSegments
            );
            break;
          case "BoxGeometry":
          case "BoxBufferGeometry":
          case "CubeGeometry":
            a = new He[c.type](
              c.width,
              c.height,
              c.depth,
              c.widthSegments,
              c.heightSegments,
              c.depthSegments
            );
            break;
          case "CircleGeometry":
          case "CircleBufferGeometry":
            a = new He[c.type](
              c.radius,
              c.segments,
              c.thetaStart,
              c.thetaLength
            );
            break;
          case "CylinderGeometry":
          case "CylinderBufferGeometry":
            a = new He[c.type](
              c.radiusTop,
              c.radiusBottom,
              c.height,
              c.radialSegments,
              c.heightSegments,
              c.openEnded,
              c.thetaStart,
              c.thetaLength
            );
            break;
          case "ConeGeometry":
          case "ConeBufferGeometry":
            a = new He[c.type](
              c.radius,
              c.height,
              c.radialSegments,
              c.heightSegments,
              c.openEnded,
              c.thetaStart,
              c.thetaLength
            );
            break;
          case "SphereGeometry":
          case "SphereBufferGeometry":
            a = new He[c.type](
              c.radius,
              c.widthSegments,
              c.heightSegments,
              c.phiStart,
              c.phiLength,
              c.thetaStart,
              c.thetaLength
            );
            break;
          case "DodecahedronGeometry":
          case "DodecahedronBufferGeometry":
          case "IcosahedronGeometry":
          case "IcosahedronBufferGeometry":
          case "OctahedronGeometry":
          case "OctahedronBufferGeometry":
          case "TetrahedronGeometry":
          case "TetrahedronBufferGeometry":
            a = new He[c.type](c.radius, c.detail);
            break;
          case "RingGeometry":
          case "RingBufferGeometry":
            a = new He[c.type](
              c.innerRadius,
              c.outerRadius,
              c.thetaSegments,
              c.phiSegments,
              c.thetaStart,
              c.thetaLength
            );
            break;
          case "TorusGeometry":
          case "TorusBufferGeometry":
            a = new He[c.type](
              c.radius,
              c.tube,
              c.radialSegments,
              c.tubularSegments,
              c.arc
            );
            break;
          case "TorusKnotGeometry":
          case "TorusKnotBufferGeometry":
            a = new He[c.type](
              c.radius,
              c.tube,
              c.tubularSegments,
              c.radialSegments,
              c.p,
              c.q
            );
            break;
          case "TubeGeometry":
          case "TubeBufferGeometry":
            a = new He[c.type](
              new Qh[c.path.type]().fromJSON(c.path),
              c.tubularSegments,
              c.radius,
              c.radialSegments,
              c.closed
            );
            break;
          case "LatheGeometry":
          case "LatheBufferGeometry":
            a = new He[c.type](c.points, c.segments, c.phiStart, c.phiLength);
            break;
          case "PolyhedronGeometry":
          case "PolyhedronBufferGeometry":
            a = new He[c.type](c.vertices, c.indices, c.radius, c.details);
            break;
          case "ShapeGeometry":
          case "ShapeBufferGeometry":
            i = [];
            for (let u = 0, h = c.shapes.length; u < h; u++) {
              const d = e[c.shapes[u]];
              i.push(d);
            }
            a = new He[c.type](i, c.curveSegments);
            break;
          case "ExtrudeGeometry":
          case "ExtrudeBufferGeometry":
            i = [];
            for (let u = 0, h = c.shapes.length; u < h; u++) {
              const d = e[c.shapes[u]];
              i.push(d);
            }
            const l = c.options.extrudePath;
            l !== void 0 &&
              (c.options.extrudePath = new Qh[l.type]().fromJSON(l)),
              (a = new He[c.type](i, c.options));
            break;
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = r.parse(c);
            break;
          case "Geometry":
            console.error(
              'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.'
            );
            break;
          default:
            console.warn(
              'THREE.ObjectLoader: Unsupported geometry type "' + c.type + '"'
            );
            continue;
        }
        (a.uuid = c.uuid),
          c.name !== void 0 && (a.name = c.name),
          a.isBufferGeometry === !0 &&
            c.userData !== void 0 &&
            (a.userData = c.userData),
          (n[c.uuid] = a);
      }
    }
    return n;
  },
  parseMaterials: function (t, e) {
    const n = {},
      i = {};
    if (t !== void 0) {
      const r = new uf();
      r.setTextures(e);
      for (let s = 0, o = t.length; s < o; s++) {
        const a = t[s];
        if (a.type === "MultiMaterial") {
          const c = [];
          for (let l = 0; l < a.materials.length; l++) {
            const u = a.materials[l];
            n[u.uuid] === void 0 && (n[u.uuid] = r.parse(u)), c.push(n[u.uuid]);
          }
          i[a.uuid] = c;
        } else
          n[a.uuid] === void 0 && (n[a.uuid] = r.parse(a)),
            (i[a.uuid] = n[a.uuid]);
      }
    }
    return i;
  },
  parseAnimations: function (t) {
    const e = [];
    for (let n = 0; n < t.length; n++) {
      const i = t[n],
        r = Pn.parse(i);
      i.uuid !== void 0 && (r.uuid = i.uuid), e.push(r);
    }
    return e;
  },
  parseImages: function (t, e) {
    const n = this,
      i = {};
    let r;
    function s(o) {
      return (
        n.manager.itemStart(o),
        r.load(
          o,
          function () {
            n.manager.itemEnd(o);
          },
          void 0,
          function () {
            n.manager.itemError(o), n.manager.itemEnd(o);
          }
        )
      );
    }
    if (t !== void 0 && t.length > 0) {
      const o = new jm(e);
      (r = new ra(o)), r.setCrossOrigin(this.crossOrigin);
      for (let a = 0, c = t.length; a < c; a++) {
        const l = t[a],
          u = l.url;
        if (Array.isArray(u)) {
          i[l.uuid] = [];
          for (let h = 0, d = u.length; h < d; h++) {
            const f = u[h],
              p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : n.resourcePath + f;
            i[l.uuid].push(s(p));
          }
        } else {
          const h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url)
            ? l.url
            : n.resourcePath + l.url;
          i[l.uuid] = s(h);
        }
      }
    }
    return i;
  },
  parseTextures: function (t, e) {
    function n(r, s) {
      return typeof r == "number"
        ? r
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            r
          ),
          s[r]);
    }
    const i = {};
    if (t !== void 0)
      for (let r = 0, s = t.length; r < s; r++) {
        const o = t[r];
        o.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid),
          e[o.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", o.image);
        let a;
        Array.isArray(e[o.image])
          ? (a = new Bi(e[o.image]))
          : (a = new Jt(e[o.image])),
          (a.needsUpdate = !0),
          (a.uuid = o.uuid),
          o.name !== void 0 && (a.name = o.name),
          o.mapping !== void 0 && (a.mapping = n(o.mapping, QM)),
          o.offset !== void 0 && a.offset.fromArray(o.offset),
          o.repeat !== void 0 && a.repeat.fromArray(o.repeat),
          o.center !== void 0 && a.center.fromArray(o.center),
          o.rotation !== void 0 && (a.rotation = o.rotation),
          o.wrap !== void 0 &&
            ((a.wrapS = n(o.wrap[0], $m)), (a.wrapT = n(o.wrap[1], $m))),
          o.format !== void 0 && (a.format = o.format),
          o.type !== void 0 && (a.type = o.type),
          o.encoding !== void 0 && (a.encoding = o.encoding),
          o.minFilter !== void 0 && (a.minFilter = n(o.minFilter, Qm)),
          o.magFilter !== void 0 && (a.magFilter = n(o.magFilter, Qm)),
          o.anisotropy !== void 0 && (a.anisotropy = o.anisotropy),
          o.flipY !== void 0 && (a.flipY = o.flipY),
          o.premultiplyAlpha !== void 0 &&
            (a.premultiplyAlpha = o.premultiplyAlpha),
          o.unpackAlignment !== void 0 &&
            (a.unpackAlignment = o.unpackAlignment),
          (i[o.uuid] = a);
      }
    return i;
  },
  parseObject: function (t, e, n) {
    let i;
    function r(c) {
      return (
        e[c] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", c),
        e[c]
      );
    }
    function s(c) {
      if (c !== void 0) {
        if (Array.isArray(c)) {
          const l = [];
          for (let u = 0, h = c.length; u < h; u++) {
            const d = c[u];
            n[d] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", d),
              l.push(n[d]);
          }
          return l;
        }
        return (
          n[c] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", c),
          n[c]
        );
      }
    }
    let o, a;
    switch (t.type) {
      case "Scene":
        (i = new pc()),
          t.background !== void 0 &&
            Number.isInteger(t.background) &&
            (i.background = new lt(t.background)),
          t.fog !== void 0 &&
            (t.fog.type === "Fog"
              ? (i.fog = new Lh(t.fog.color, t.fog.near, t.fog.far))
              : t.fog.type === "FogExp2" &&
                (i.fog = new Ah(t.fog.color, t.fog.density)));
        break;
      case "PerspectiveCamera":
        (i = new Pe(t.fov, t.aspect, t.near, t.far)),
          t.focus !== void 0 && (i.focus = t.focus),
          t.zoom !== void 0 && (i.zoom = t.zoom),
          t.filmGauge !== void 0 && (i.filmGauge = t.filmGauge),
          t.filmOffset !== void 0 && (i.filmOffset = t.filmOffset),
          t.view !== void 0 && (i.view = Object.assign({}, t.view));
        break;
      case "OrthographicCamera":
        (i = new ca(t.left, t.right, t.top, t.bottom, t.near, t.far)),
          t.zoom !== void 0 && (i.zoom = t.zoom),
          t.view !== void 0 && (i.view = Object.assign({}, t.view));
        break;
      case "AmbientLight":
        i = new af(t.color, t.intensity);
        break;
      case "DirectionalLight":
        i = new of(t.color, t.intensity);
        break;
      case "PointLight":
        i = new rf(t.color, t.intensity, t.distance, t.decay);
        break;
      case "RectAreaLight":
        i = new cf(t.color, t.intensity, t.width, t.height);
        break;
      case "SpotLight":
        i = new ef(
          t.color,
          t.intensity,
          t.distance,
          t.angle,
          t.penumbra,
          t.decay
        );
        break;
      case "HemisphereLight":
        i = new Kh(t.color, t.groundColor, t.intensity);
        break;
      case "LightProbe":
        i = new On().fromJSON(t);
        break;
      case "SkinnedMesh":
        console.warn(
          "THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."
        );
      case "Mesh":
        (o = r(t.geometry)), (a = s(t.material)), (i = new he(o, a));
        break;
      case "InstancedMesh":
        (o = r(t.geometry)), (a = s(t.material));
        const c = t.count,
          l = t.instanceMatrix;
        (i = new Dh(o, a, c)),
          (i.instanceMatrix = new wt(new Float32Array(l.array), 16));
        break;
      case "LOD":
        i = new Bc();
        break;
      case "Line":
        i = new yn(r(t.geometry), s(t.material), t.mode);
        break;
      case "LineLoop":
        i = new Ih(r(t.geometry), s(t.material));
        break;
      case "LineSegments":
        i = new ve(r(t.geometry), s(t.material));
        break;
      case "PointCloud":
      case "Points":
        i = new Fh(r(t.geometry), s(t.material));
        break;
      case "Sprite":
        i = new Ch(s(t.material));
        break;
      case "Group":
        i = new Fo();
        break;
      default:
        i = new nt();
    }
    if (
      ((i.uuid = t.uuid),
      t.name !== void 0 && (i.name = t.name),
      t.matrix !== void 0
        ? (i.matrix.fromArray(t.matrix),
          t.matrixAutoUpdate !== void 0 &&
            (i.matrixAutoUpdate = t.matrixAutoUpdate),
          i.matrixAutoUpdate &&
            i.matrix.decompose(i.position, i.quaternion, i.scale))
        : (t.position !== void 0 && i.position.fromArray(t.position),
          t.rotation !== void 0 && i.rotation.fromArray(t.rotation),
          t.quaternion !== void 0 && i.quaternion.fromArray(t.quaternion),
          t.scale !== void 0 && i.scale.fromArray(t.scale)),
      t.castShadow !== void 0 && (i.castShadow = t.castShadow),
      t.receiveShadow !== void 0 && (i.receiveShadow = t.receiveShadow),
      t.shadow &&
        (t.shadow.bias !== void 0 && (i.shadow.bias = t.shadow.bias),
        t.shadow.normalBias !== void 0 &&
          (i.shadow.normalBias = t.shadow.normalBias),
        t.shadow.radius !== void 0 && (i.shadow.radius = t.shadow.radius),
        t.shadow.mapSize !== void 0 &&
          i.shadow.mapSize.fromArray(t.shadow.mapSize),
        t.shadow.camera !== void 0 &&
          (i.shadow.camera = this.parseObject(t.shadow.camera))),
      t.visible !== void 0 && (i.visible = t.visible),
      t.frustumCulled !== void 0 && (i.frustumCulled = t.frustumCulled),
      t.renderOrder !== void 0 && (i.renderOrder = t.renderOrder),
      t.userData !== void 0 && (i.userData = t.userData),
      t.layers !== void 0 && (i.layers.mask = t.layers),
      t.children !== void 0)
    ) {
      const c = t.children;
      for (let l = 0; l < c.length; l++) i.add(this.parseObject(c[l], e, n));
    }
    if (t.type === "LOD") {
      t.autoUpdate !== void 0 && (i.autoUpdate = t.autoUpdate);
      const c = t.levels;
      for (let l = 0; l < c.length; l++) {
        const u = c[l],
          h = i.getObjectByProperty("uuid", u.object);
        h !== void 0 && i.addLevel(h, u.distance);
      }
    }
    return i;
  },
});
const QM = {
    UVMapping: ku,
    CubeReflectionMapping: Gu,
    CubeRefractionMapping: Hu,
    EquirectangularReflectionMapping: Tp,
    EquirectangularRefractionMapping: Vu,
    CubeUVReflectionMapping: ec,
    CubeUVRefractionMapping: Wu,
  },
  $m = {
    RepeatWrapping: nc,
    ClampToEdgeWrapping: Ze,
    MirroredRepeatWrapping: ic,
  },
  Qm = {
    NearestFilter: De,
    NearestMipmapNearestFilter: ju,
    NearestMipmapLinearFilter: qu,
    LinearFilter: Ie,
    LinearMipmapNearestFilter: Ep,
    LinearMipmapLinearFilter: rc,
  };
function Km(t) {
  typeof createImageBitmap == "undefined" &&
    console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
    typeof fetch == "undefined" &&
      console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
    Wt.call(this, t),
    (this.options = { premultiplyAlpha: "none" });
}
Km.prototype = Object.assign(Object.create(Wt.prototype), {
  constructor: Km,
  isImageBitmapLoader: !0,
  setOptions: function (e) {
    return (this.options = e), this;
  },
  load: function (t, e, n, i) {
    t === void 0 && (t = ""),
      this.path !== void 0 && (t = this.path + t),
      (t = this.manager.resolveURL(t));
    const r = this,
      s = Ws.get(t);
    if (s !== void 0)
      return (
        r.manager.itemStart(t),
        setTimeout(function () {
          e && e(s), r.manager.itemEnd(t);
        }, 0),
        s
      );
    fetch(t)
      .then(function (o) {
        return o.blob();
      })
      .then(function (o) {
        return createImageBitmap(o, r.options);
      })
      .then(function (o) {
        Ws.add(t, o), e && e(o), r.manager.itemEnd(t);
      })
      .catch(function (o) {
        i && i(o), r.manager.itemError(t), r.manager.itemEnd(t);
      }),
      r.manager.itemStart(t);
  },
});
function tg() {
  (this.type = "ShapePath"),
    (this.color = new lt()),
    (this.subPaths = []),
    (this.currentPath = null);
}
Object.assign(tg.prototype, {
  moveTo: function (t, e) {
    return (
      (this.currentPath = new $n()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(t, e),
      this
    );
  },
  lineTo: function (t, e) {
    return this.currentPath.lineTo(t, e), this;
  },
  quadraticCurveTo: function (t, e, n, i) {
    return this.currentPath.quadraticCurveTo(t, e, n, i), this;
  },
  bezierCurveTo: function (t, e, n, i, r, s) {
    return this.currentPath.bezierCurveTo(t, e, n, i, r, s), this;
  },
  splineThru: function (t) {
    return this.currentPath.splineThru(t), this;
  },
  toShapes: function (t, e) {
    function n(m) {
      const g = [];
      for (let b = 0, x = m.length; b < x; b++) {
        const v = m[b],
          w = new xr();
        (w.curves = v.curves), g.push(w);
      }
      return g;
    }
    function i(m, g) {
      const b = g.length;
      let x = !1;
      for (let v = b - 1, w = 0; w < b; v = w++) {
        let M = g[v],
          C = g[w],
          A = C.x - M.x,
          U = C.y - M.y;
        if (Math.abs(U) > Number.EPSILON) {
          if (
            (U < 0 && ((M = g[w]), (A = -A), (C = g[v]), (U = -U)),
            m.y < M.y || m.y > C.y)
          )
            continue;
          if (m.y === M.y) {
            if (m.x === M.x) return !0;
          } else {
            const I = U * (m.x - M.x) - A * (m.y - M.y);
            if (I === 0) return !0;
            if (I < 0) continue;
            x = !x;
          }
        } else {
          if (m.y !== M.y) continue;
          if ((C.x <= m.x && m.x <= M.x) || (M.x <= m.x && m.x <= C.x))
            return !0;
        }
      }
      return x;
    }
    const r = ki.isClockWise,
      s = this.subPaths;
    if (s.length === 0) return [];
    if (e === !0) return n(s);
    let o,
      a,
      c,
      l = [];
    if (s.length === 1)
      return (a = s[0]), (c = new xr()), (c.curves = a.curves), l.push(c), l;
    let u = !r(s[0].getPoints());
    u = t ? !u : u;
    const h = [],
      d = [];
    let f = [],
      p = 0,
      _;
    (d[p] = void 0), (f[p] = []);
    for (let m = 0, g = s.length; m < g; m++)
      (a = s[m]),
        (_ = a.getPoints()),
        (o = r(_)),
        (o = t ? !o : o),
        o
          ? (!u && d[p] && p++,
            (d[p] = { s: new xr(), p: _ }),
            (d[p].s.curves = a.curves),
            u && p++,
            (f[p] = []))
          : f[p].push({ h: a, p: _[0] });
    if (!d[0]) return n(s);
    if (d.length > 1) {
      let m = !1;
      const g = [];
      for (let b = 0, x = d.length; b < x; b++) h[b] = [];
      for (let b = 0, x = d.length; b < x; b++) {
        const v = f[b];
        for (let w = 0; w < v.length; w++) {
          const M = v[w];
          let C = !0;
          for (let A = 0; A < d.length; A++)
            i(M.p, d[A].p) &&
              (b !== A && g.push({ froms: b, tos: A, hole: w }),
              C ? ((C = !1), h[A].push(M)) : (m = !0));
          C && h[b].push(M);
        }
      }
      g.length > 0 && (m || (f = h));
    }
    let y;
    for (let m = 0, g = d.length; m < g; m++) {
      (c = d[m].s), l.push(c), (y = f[m]);
      for (let b = 0, x = y.length; b < x; b++) c.holes.push(y[b].h);
    }
    return l;
  },
});
function eg(t) {
  (this.type = "Font"), (this.data = t);
}
Object.assign(eg.prototype, {
  isFont: !0,
  generateShapes: function (t, e) {
    e === void 0 && (e = 100);
    const n = [],
      i = KM(t, e, this.data);
    for (let r = 0, s = i.length; r < s; r++)
      Array.prototype.push.apply(n, i[r].toShapes());
    return n;
  },
});
function KM(t, e, n) {
  const i = Array.from ? Array.from(t) : String(t).split(""),
    r = e / n.resolution,
    s = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r,
    o = [];
  let a = 0,
    c = 0;
  for (let l = 0; l < i.length; l++) {
    const u = i[l];
    if (
      u ===
      `
`
    )
      (a = 0), (c -= s);
    else {
      const h = t1(u, r, a, c, n);
      (a += h.offsetX), o.push(h.path);
    }
  }
  return o;
}
function t1(t, e, n, i, r) {
  const s = r.glyphs[t] || r.glyphs["?"];
  if (!s) {
    console.error(
      'THREE.Font: character "' +
        t +
        '" does not exists in font family ' +
        r.familyName +
        "."
    );
    return;
  }
  const o = new tg();
  let a, c, l, u, h, d, f, p;
  if (s.o) {
    const _ = s._cachedOutline || (s._cachedOutline = s.o.split(" "));
    for (let y = 0, m = _.length; y < m; )
      switch (_[y++]) {
        case "m":
          (a = _[y++] * e + n), (c = _[y++] * e + i), o.moveTo(a, c);
          break;
        case "l":
          (a = _[y++] * e + n), (c = _[y++] * e + i), o.lineTo(a, c);
          break;
        case "q":
          (l = _[y++] * e + n),
            (u = _[y++] * e + i),
            (h = _[y++] * e + n),
            (d = _[y++] * e + i),
            o.quadraticCurveTo(h, d, l, u);
          break;
        case "b":
          (l = _[y++] * e + n),
            (u = _[y++] * e + i),
            (h = _[y++] * e + n),
            (d = _[y++] * e + i),
            (f = _[y++] * e + n),
            (p = _[y++] * e + i),
            o.bezierCurveTo(h, d, f, p, l, u);
          break;
      }
  }
  return { offsetX: s.ha * e, path: o };
}
function ng(t) {
  Wt.call(this, t);
}
ng.prototype = Object.assign(Object.create(Wt.prototype), {
  constructor: ng,
  load: function (t, e, n, i) {
    const r = this,
      s = new qn(this.manager);
    s.setPath(this.path),
      s.load(
        t,
        function (o) {
          let a;
          try {
            a = JSON.parse(o);
          } catch {
            console.warn(
              "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
            ),
              (a = JSON.parse(o.substring(65, o.length - 2)));
          }
          const c = r.parse(a);
          e && e(c);
        },
        n,
        i
      );
  },
  parse: function (t) {
    return new eg(t);
  },
});
let xl;
const ig = {
  getContext: function () {
    return (
      xl === void 0 &&
        (xl = new (window.AudioContext || window.webkitAudioContext)()),
      xl
    );
  },
  setContext: function (t) {
    xl = t;
  },
};
function pf(t) {
  Wt.call(this, t);
}
pf.prototype = Object.assign(Object.create(Wt.prototype), {
  constructor: pf,
  load: function (t, e, n, i) {
    const r = this,
      s = new qn(r.manager);
    s.setResponseType("arraybuffer"),
      s.setPath(r.path),
      s.load(
        t,
        function (o) {
          try {
            const a = o.slice(0);
            ig.getContext().decodeAudioData(a, function (l) {
              e(l);
            });
          } catch (a) {
            i ? i(a) : console.error(a), r.manager.itemError(t);
          }
        },
        n,
        i
      );
  },
});
function rg(t, e, n) {
  On.call(this, void 0, n);
  const i = new lt().set(t),
    r = new lt().set(e),
    s = new S(i.r, i.g, i.b),
    o = new S(r.r, r.g, r.b),
    a = Math.sqrt(Math.PI),
    c = a * Math.sqrt(0.75);
  this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a),
    this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(c);
}
rg.prototype = Object.assign(Object.create(On.prototype), {
  constructor: rg,
  isHemisphereLightProbe: !0,
  copy: function (t) {
    return On.prototype.copy.call(this, t), this;
  },
  toJSON: function (t) {
    return On.prototype.toJSON.call(this, t);
  },
});
function sg(t, e) {
  On.call(this, void 0, e);
  const n = new lt().set(t);
  this.sh.coefficients[0]
    .set(n.r, n.g, n.b)
    .multiplyScalar(2 * Math.sqrt(Math.PI));
}
sg.prototype = Object.assign(Object.create(On.prototype), {
  constructor: sg,
  isAmbientLightProbe: !0,
  copy: function (t) {
    return On.prototype.copy.call(this, t), this;
  },
  toJSON: function (t) {
    return On.prototype.toJSON.call(this, t);
  },
});
const og = new Rt(),
  ag = new Rt();
function e1() {
  (this.type = "StereoCamera"),
    (this.aspect = 1),
    (this.eyeSep = 0.064),
    (this.cameraL = new Pe()),
    this.cameraL.layers.enable(1),
    (this.cameraL.matrixAutoUpdate = !1),
    (this.cameraR = new Pe()),
    this.cameraR.layers.enable(2),
    (this.cameraR.matrixAutoUpdate = !1),
    (this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null,
    });
}
Object.assign(e1.prototype, {
  update: function (t) {
    const e = this._cache;
    if (
      e.focus !== t.focus ||
      e.fov !== t.fov ||
      e.aspect !== t.aspect * this.aspect ||
      e.near !== t.near ||
      e.far !== t.far ||
      e.zoom !== t.zoom ||
      e.eyeSep !== this.eyeSep
    ) {
      (e.focus = t.focus),
        (e.fov = t.fov),
        (e.aspect = t.aspect * this.aspect),
        (e.near = t.near),
        (e.far = t.far),
        (e.zoom = t.zoom),
        (e.eyeSep = this.eyeSep);
      const i = t.projectionMatrix.clone(),
        r = e.eyeSep / 2,
        s = (r * e.near) / e.focus,
        o = (e.near * Math.tan(Pt.DEG2RAD * e.fov * 0.5)) / e.zoom;
      let a, c;
      (ag.elements[12] = -r),
        (og.elements[12] = r),
        (a = -o * e.aspect + s),
        (c = o * e.aspect + s),
        (i.elements[0] = (2 * e.near) / (c - a)),
        (i.elements[8] = (c + a) / (c - a)),
        this.cameraL.projectionMatrix.copy(i),
        (a = -o * e.aspect - s),
        (c = o * e.aspect - s),
        (i.elements[0] = (2 * e.near) / (c - a)),
        (i.elements[8] = (c + a) / (c - a)),
        this.cameraR.projectionMatrix.copy(i);
    }
    this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(ag),
      this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(og);
  },
});
function cg(t) {
  (this.autoStart = t !== void 0 ? t : !0),
    (this.startTime = 0),
    (this.oldTime = 0),
    (this.elapsedTime = 0),
    (this.running = !1);
}
Object.assign(cg.prototype, {
  start: function () {
    (this.startTime = (
      typeof performance == "undefined" ? Date : performance
    ).now()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  },
  stop: function () {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  },
  getElapsedTime: function () {
    return this.getDelta(), this.elapsedTime;
  },
  getDelta: function () {
    let t = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const e = (typeof performance == "undefined" ? Date : performance).now();
      (t = (e - this.oldTime) / 1e3),
        (this.oldTime = e),
        (this.elapsedTime += t);
    }
    return t;
  },
});
const vr = new S(),
  lg = new Ae(),
  n1 = new S(),
  br = new S();
function ug() {
  nt.call(this),
    (this.type = "AudioListener"),
    (this.context = ig.getContext()),
    (this.gain = this.context.createGain()),
    this.gain.connect(this.context.destination),
    (this.filter = null),
    (this.timeDelta = 0),
    (this._clock = new cg());
}
ug.prototype = Object.assign(Object.create(nt.prototype), {
  constructor: ug,
  getInput: function () {
    return this.gain;
  },
  removeFilter: function () {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  },
  getFilter: function () {
    return this.filter;
  },
  setFilter: function (t) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = t),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  },
  getMasterVolume: function () {
    return this.gain.gain.value;
  },
  setMasterVolume: function (t) {
    return (
      this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this
    );
  },
  updateMatrixWorld: function (t) {
    nt.prototype.updateMatrixWorld.call(this, t);
    const e = this.context.listener,
      n = this.up;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(vr, lg, n1),
      br.set(0, 0, -1).applyQuaternion(lg),
      e.positionX)
    ) {
      const i = this.context.currentTime + this.timeDelta;
      e.positionX.linearRampToValueAtTime(vr.x, i),
        e.positionY.linearRampToValueAtTime(vr.y, i),
        e.positionZ.linearRampToValueAtTime(vr.z, i),
        e.forwardX.linearRampToValueAtTime(br.x, i),
        e.forwardY.linearRampToValueAtTime(br.y, i),
        e.forwardZ.linearRampToValueAtTime(br.z, i),
        e.upX.linearRampToValueAtTime(n.x, i),
        e.upY.linearRampToValueAtTime(n.y, i),
        e.upZ.linearRampToValueAtTime(n.z, i);
    } else
      e.setPosition(vr.x, vr.y, vr.z),
        e.setOrientation(br.x, br.y, br.z, n.x, n.y, n.z);
  },
});
function la(t) {
  nt.call(this),
    (this.type = "Audio"),
    (this.listener = t),
    (this.context = t.context),
    (this.gain = this.context.createGain()),
    this.gain.connect(t.getInput()),
    (this.autoplay = !1),
    (this.buffer = null),
    (this.detune = 0),
    (this.loop = !1),
    (this.loopStart = 0),
    (this.loopEnd = 0),
    (this.offset = 0),
    (this.duration = void 0),
    (this.playbackRate = 1),
    (this.isPlaying = !1),
    (this.hasPlaybackControl = !0),
    (this.sourceType = "empty"),
    (this._startedAt = 0),
    (this._progress = 0),
    (this.filters = []);
}
la.prototype = Object.assign(Object.create(nt.prototype), {
  constructor: la,
  getOutput: function () {
    return this.gain;
  },
  setNodeSource: function (t) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = t),
      this.connect(),
      this
    );
  },
  setMediaElementSource: function (t) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(t)),
      this.connect(),
      this
    );
  },
  setMediaStreamSource: function (t) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(t)),
      this.connect(),
      this
    );
  },
  setBuffer: function (t) {
    return (
      (this.buffer = t),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  },
  play: function (t) {
    if ((t === void 0 && (t = 0), this.isPlaying === !0)) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + t;
    const e = this.context.createBufferSource();
    return (
      (e.buffer = this.buffer),
      (e.loop = this.loop),
      (e.loopStart = this.loopStart),
      (e.loopEnd = this.loopEnd),
      (e.onended = this.onEnded.bind(this)),
      e.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = e),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  },
  pause: function () {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  },
  stop: function () {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source.stop(),
      (this.source.onended = null),
      (this.isPlaying = !1),
      this
    );
  },
  connect: function () {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let t = 1, e = this.filters.length; t < e; t++)
        this.filters[t - 1].connect(this.filters[t]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return this;
  },
  disconnect: function () {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let t = 1, e = this.filters.length; t < e; t++)
        this.filters[t - 1].disconnect(this.filters[t]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else this.source.disconnect(this.getOutput());
    return this;
  },
  getFilters: function () {
    return this.filters;
  },
  setFilters: function (t) {
    return (
      t || (t = []),
      this.isPlaying === !0
        ? (this.disconnect(), (this.filters = t), this.connect())
        : (this.filters = t),
      this
    );
  },
  setDetune: function (t) {
    if (((this.detune = t), this.source.detune !== void 0))
      return (
        this.isPlaying === !0 &&
          this.source.detune.setTargetAtTime(
            this.detune,
            this.context.currentTime,
            0.01
          ),
        this
      );
  },
  getDetune: function () {
    return this.detune;
  },
  getFilter: function () {
    return this.getFilters()[0];
  },
  setFilter: function (t) {
    return this.setFilters(t ? [t] : []);
  },
  setPlaybackRate: function (t) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = t),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  },
  getPlaybackRate: function () {
    return this.playbackRate;
  },
  onEnded: function () {
    this.isPlaying = !1;
  },
  getLoop: function () {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  },
  setLoop: function (t) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = t),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  },
  setLoopStart: function (t) {
    return (this.loopStart = t), this;
  },
  setLoopEnd: function (t) {
    return (this.loopEnd = t), this;
  },
  getVolume: function () {
    return this.gain.gain.value;
  },
  setVolume: function (t) {
    return (
      this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this
    );
  },
});
const wr = new S(),
  hg = new Ae(),
  i1 = new S(),
  Mr = new S();
function fg(t) {
  la.call(this, t),
    (this.panner = this.context.createPanner()),
    (this.panner.panningModel = "HRTF"),
    this.panner.connect(this.gain);
}
fg.prototype = Object.assign(Object.create(la.prototype), {
  constructor: fg,
  getOutput: function () {
    return this.panner;
  },
  getRefDistance: function () {
    return this.panner.refDistance;
  },
  setRefDistance: function (t) {
    return (this.panner.refDistance = t), this;
  },
  getRolloffFactor: function () {
    return this.panner.rolloffFactor;
  },
  setRolloffFactor: function (t) {
    return (this.panner.rolloffFactor = t), this;
  },
  getDistanceModel: function () {
    return this.panner.distanceModel;
  },
  setDistanceModel: function (t) {
    return (this.panner.distanceModel = t), this;
  },
  getMaxDistance: function () {
    return this.panner.maxDistance;
  },
  setMaxDistance: function (t) {
    return (this.panner.maxDistance = t), this;
  },
  setDirectionalCone: function (t, e, n) {
    return (
      (this.panner.coneInnerAngle = t),
      (this.panner.coneOuterAngle = e),
      (this.panner.coneOuterGain = n),
      this
    );
  },
  updateMatrixWorld: function (t) {
    if (
      (nt.prototype.updateMatrixWorld.call(this, t),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    this.matrixWorld.decompose(wr, hg, i1), Mr.set(0, 0, 1).applyQuaternion(hg);
    const e = this.panner;
    if (e.positionX) {
      const n = this.context.currentTime + this.listener.timeDelta;
      e.positionX.linearRampToValueAtTime(wr.x, n),
        e.positionY.linearRampToValueAtTime(wr.y, n),
        e.positionZ.linearRampToValueAtTime(wr.z, n),
        e.orientationX.linearRampToValueAtTime(Mr.x, n),
        e.orientationY.linearRampToValueAtTime(Mr.y, n),
        e.orientationZ.linearRampToValueAtTime(Mr.z, n);
    } else e.setPosition(wr.x, wr.y, wr.z), e.setOrientation(Mr.x, Mr.y, Mr.z);
  },
});
function dg(t, e) {
  (this.analyser = t.context.createAnalyser()),
    (this.analyser.fftSize = e !== void 0 ? e : 2048),
    (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
    t.getOutput().connect(this.analyser);
}
Object.assign(dg.prototype, {
  getFrequencyData: function () {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  },
  getAverageFrequency: function () {
    let t = 0;
    const e = this.getFrequencyData();
    for (let n = 0; n < e.length; n++) t += e[n];
    return t / e.length;
  },
});
function pg(t, e, n) {
  (this.binding = t), (this.valueSize = n);
  let i, r, s;
  switch (e) {
    case "quaternion":
      (i = this._slerp),
        (r = this._slerpAdditive),
        (s = this._setAdditiveIdentityQuaternion),
        (this.buffer = new Float64Array(n * 6)),
        (this._workIndex = 5);
      break;
    case "string":
    case "bool":
      (i = this._select),
        (r = this._select),
        (s = this._setAdditiveIdentityOther),
        (this.buffer = new Array(n * 5));
      break;
    default:
      (i = this._lerp),
        (r = this._lerpAdditive),
        (s = this._setAdditiveIdentityNumeric),
        (this.buffer = new Float64Array(n * 5));
  }
  (this._mixBufferRegion = i),
    (this._mixBufferRegionAdditive = r),
    (this._setIdentity = s),
    (this._origIndex = 3),
    (this._addIndex = 4),
    (this.cumulativeWeight = 0),
    (this.cumulativeWeightAdditive = 0),
    (this.useCount = 0),
    (this.referenceCount = 0);
}
Object.assign(pg.prototype, {
  accumulate: function (t, e) {
    const n = this.buffer,
      i = this.valueSize,
      r = t * i + i;
    let s = this.cumulativeWeight;
    if (s === 0) {
      for (let o = 0; o !== i; ++o) n[r + o] = n[o];
      s = e;
    } else {
      s += e;
      const o = e / s;
      this._mixBufferRegion(n, r, 0, o, i);
    }
    this.cumulativeWeight = s;
  },
  accumulateAdditive: function (t) {
    const e = this.buffer,
      n = this.valueSize,
      i = n * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(e, i, 0, t, n),
      (this.cumulativeWeightAdditive += t);
  },
  apply: function (t) {
    const e = this.valueSize,
      n = this.buffer,
      i = t * e + e,
      r = this.cumulativeWeight,
      s = this.cumulativeWeightAdditive,
      o = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), r < 1)
    ) {
      const a = e * this._origIndex;
      this._mixBufferRegion(n, i, a, 1 - r, e);
    }
    s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
    for (let a = e, c = e + e; a !== c; ++a)
      if (n[a] !== n[a + e]) {
        o.setValue(n, i);
        break;
      }
  },
  saveOriginalState: function () {
    const t = this.binding,
      e = this.buffer,
      n = this.valueSize,
      i = n * this._origIndex;
    t.getValue(e, i);
    for (let r = n, s = i; r !== s; ++r) e[r] = e[i + (r % n)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  },
  restoreOriginalState: function () {
    const t = this.valueSize * 3;
    this.binding.setValue(this.buffer, t);
  },
  _setAdditiveIdentityNumeric: function () {
    const t = this._addIndex * this.valueSize,
      e = t + this.valueSize;
    for (let n = t; n < e; n++) this.buffer[n] = 0;
  },
  _setAdditiveIdentityQuaternion: function () {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * 4 + 3] = 1);
  },
  _setAdditiveIdentityOther: function () {
    const t = this._origIndex * this.valueSize,
      e = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[e + n] = this.buffer[t + n];
  },
  _select: function (t, e, n, i, r) {
    if (i >= 0.5) for (let s = 0; s !== r; ++s) t[e + s] = t[n + s];
  },
  _slerp: function (t, e, n, i) {
    Ae.slerpFlat(t, e, t, e, t, n, i);
  },
  _slerpAdditive: function (t, e, n, i, r) {
    const s = this._workIndex * r;
    Ae.multiplyQuaternionsFlat(t, s, t, e, t, n),
      Ae.slerpFlat(t, e, t, e, t, s, i);
  },
  _lerp: function (t, e, n, i, r) {
    const s = 1 - i;
    for (let o = 0; o !== r; ++o) {
      const a = e + o;
      t[a] = t[a] * s + t[n + o] * i;
    }
  },
  _lerpAdditive: function (t, e, n, i, r) {
    for (let s = 0; s !== r; ++s) {
      const o = e + s;
      t[o] = t[o] + t[n + s] * i;
    }
  },
});
const mf = "\\[\\]\\.:\\/",
  r1 = new RegExp("[" + mf + "]", "g"),
  gf = "[^" + mf + "]",
  s1 = "[^" + mf.replace("\\.", "") + "]",
  o1 = /((?:WC+[\/:])*)/.source.replace("WC", gf),
  a1 = /(WCOD+)?/.source.replace("WCOD", s1),
  c1 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", gf),
  l1 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", gf),
  u1 = new RegExp("^" + o1 + a1 + c1 + l1 + "$"),
  h1 = ["material", "materials", "bones"];
function mg(t, e, n) {
  const i = n || Ve.parseTrackName(e);
  (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
}
Object.assign(mg.prototype, {
  getValue: function (t, e) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_,
      i = this._bindings[n];
    i !== void 0 && i.getValue(t, e);
  },
  setValue: function (t, e) {
    const n = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
      n[i].setValue(t, e);
  },
  bind: function () {
    const t = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
      t[e].bind();
  },
  unbind: function () {
    const t = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
      t[e].unbind();
  },
});
function Ve(t, e, n) {
  (this.path = e),
    (this.parsedPath = n || Ve.parseTrackName(e)),
    (this.node = Ve.findNode(t, this.parsedPath.nodeName) || t),
    (this.rootNode = t);
}
Object.assign(Ve, {
  Composite: mg,
  create: function (t, e, n) {
    return t && t.isAnimationObjectGroup
      ? new Ve.Composite(t, e, n)
      : new Ve(t, e, n);
  },
  sanitizeNodeName: function (t) {
    return t.replace(/\s/g, "_").replace(r1, "");
  },
  parseTrackName: function (t) {
    const e = u1.exec(t);
    if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
    const n = {
        nodeName: e[2],
        objectName: e[3],
        objectIndex: e[4],
        propertyName: e[5],
        propertyIndex: e[6],
      },
      i = n.nodeName && n.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const r = n.nodeName.substring(i + 1);
      h1.indexOf(r) !== -1 &&
        ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = r));
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + t
      );
    return n;
  },
  findNode: function (t, e) {
    if (!e || e === "" || e === "." || e === -1 || e === t.name || e === t.uuid)
      return t;
    if (t.skeleton) {
      const n = t.skeleton.getBoneByName(e);
      if (n !== void 0) return n;
    }
    if (t.children) {
      const n = function (r) {
          for (let s = 0; s < r.length; s++) {
            const o = r[s];
            if (o.name === e || o.uuid === e) return o;
            const a = n(o.children);
            if (a) return a;
          }
          return null;
        },
        i = n(t.children);
      if (i) return i;
    }
    return null;
  },
});
Object.assign(Ve.prototype, {
  _getValue_unavailable: function () {},
  _setValue_unavailable: function () {},
  BindingType: {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3,
  },
  Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
  GetterByBindingType: [
    function (e, n) {
      e[n] = this.node[this.propertyName];
    },
    function (e, n) {
      const i = this.resolvedProperty;
      for (let r = 0, s = i.length; r !== s; ++r) e[n++] = i[r];
    },
    function (e, n) {
      e[n] = this.resolvedProperty[this.propertyIndex];
    },
    function (e, n) {
      this.resolvedProperty.toArray(e, n);
    },
  ],
  SetterByBindingTypeAndVersioning: [
    [
      function (e, n) {
        this.targetObject[this.propertyName] = e[n];
      },
      function (e, n) {
        (this.targetObject[this.propertyName] = e[n]),
          (this.targetObject.needsUpdate = !0);
      },
      function (e, n) {
        (this.targetObject[this.propertyName] = e[n]),
          (this.targetObject.matrixWorldNeedsUpdate = !0);
      },
    ],
    [
      function (e, n) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[n++];
      },
      function (e, n) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[n++];
        this.targetObject.needsUpdate = !0;
      },
      function (e, n) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[n++];
        this.targetObject.matrixWorldNeedsUpdate = !0;
      },
    ],
    [
      function (e, n) {
        this.resolvedProperty[this.propertyIndex] = e[n];
      },
      function (e, n) {
        (this.resolvedProperty[this.propertyIndex] = e[n]),
          (this.targetObject.needsUpdate = !0);
      },
      function (e, n) {
        (this.resolvedProperty[this.propertyIndex] = e[n]),
          (this.targetObject.matrixWorldNeedsUpdate = !0);
      },
    ],
    [
      function (e, n) {
        this.resolvedProperty.fromArray(e, n);
      },
      function (e, n) {
        this.resolvedProperty.fromArray(e, n),
          (this.targetObject.needsUpdate = !0);
      },
      function (e, n) {
        this.resolvedProperty.fromArray(e, n),
          (this.targetObject.matrixWorldNeedsUpdate = !0);
      },
    ],
  ],
  getValue: function (e, n) {
    this.bind(), this.getValue(e, n);
  },
  setValue: function (e, n) {
    this.bind(), this.setValue(e, n);
  },
  bind: function () {
    let t = this.node,
      e = this.parsedPath,
      n = e.objectName,
      i = e.propertyName,
      r = e.propertyIndex;
    if (
      (t ||
        ((t = Ve.findNode(this.rootNode, e.nodeName) || this.rootNode),
        (this.node = t)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !t)
    ) {
      console.error(
        "THREE.PropertyBinding: Trying to update node for track: " +
          this.path +
          " but it wasn't found."
      );
      return;
    }
    if (n) {
      let c = e.objectIndex;
      switch (n) {
        case "materials":
          if (!t.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!t.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          t = t.material.materials;
          break;
        case "bones":
          if (!t.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          t = t.skeleton.bones;
          for (let l = 0; l < t.length; l++)
            if (t[l].name === c) {
              c = l;
              break;
            }
          break;
        default:
          if (t[n] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          t = t[n];
      }
      if (c !== void 0) {
        if (t[c] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            t
          );
          return;
        }
        t = t[c];
      }
    }
    const s = t[i];
    if (s === void 0) {
      const c = e.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          c +
          "." +
          i +
          " but it wasn't found.",
        t
      );
      return;
    }
    let o = this.Versioning.None;
    (this.targetObject = t),
      t.needsUpdate !== void 0
        ? (o = this.Versioning.NeedsUpdate)
        : t.matrixWorldNeedsUpdate !== void 0 &&
          (o = this.Versioning.MatrixWorldNeedsUpdate);
    let a = this.BindingType.Direct;
    if (r !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!t.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (t.geometry.isBufferGeometry) {
          if (!t.geometry.morphAttributes) {
            console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
              this
            );
            return;
          }
          t.morphTargetDictionary[r] !== void 0 &&
            (r = t.morphTargetDictionary[r]);
        } else {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
            this
          );
          return;
        }
      }
      (a = this.BindingType.ArrayElement),
        (this.resolvedProperty = s),
        (this.propertyIndex = r);
    } else
      s.fromArray !== void 0 && s.toArray !== void 0
        ? ((a = this.BindingType.HasFromToArray), (this.resolvedProperty = s))
        : Array.isArray(s)
        ? ((a = this.BindingType.EntireArray), (this.resolvedProperty = s))
        : (this.propertyName = i);
    (this.getValue = this.GetterByBindingType[a]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[a][o]);
  },
  unbind: function () {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  },
});
Object.assign(Ve.prototype, {
  _getValue_unbound: Ve.prototype.getValue,
  _setValue_unbound: Ve.prototype.setValue,
});
function f1() {
  (this.uuid = Pt.generateUUID()),
    (this._objects = Array.prototype.slice.call(arguments)),
    (this.nCachedObjects_ = 0);
  const t = {};
  this._indicesByUUID = t;
  for (let n = 0, i = arguments.length; n !== i; ++n) t[arguments[n].uuid] = n;
  (this._paths = []),
    (this._parsedPaths = []),
    (this._bindings = []),
    (this._bindingsIndicesByPath = {});
  const e = this;
  this.stats = {
    objects: {
      get total() {
        return e._objects.length;
      },
      get inUse() {
        return this.total - e.nCachedObjects_;
      },
    },
    get bindingsPerObject() {
      return e._bindings.length;
    },
  };
}
Object.assign(f1.prototype, {
  isAnimationObjectGroup: !0,
  add: function () {
    const t = this._objects,
      e = this._indicesByUUID,
      n = this._paths,
      i = this._parsedPaths,
      r = this._bindings,
      s = r.length;
    let o,
      a = t.length,
      c = this.nCachedObjects_;
    for (let l = 0, u = arguments.length; l !== u; ++l) {
      const h = arguments[l],
        d = h.uuid;
      let f = e[d];
      if (f === void 0) {
        (f = a++), (e[d] = f), t.push(h);
        for (let p = 0, _ = s; p !== _; ++p) r[p].push(new Ve(h, n[p], i[p]));
      } else if (f < c) {
        o = t[f];
        const p = --c,
          _ = t[p];
        (e[_.uuid] = f), (t[f] = _), (e[d] = p), (t[p] = h);
        for (let y = 0, m = s; y !== m; ++y) {
          const g = r[y],
            b = g[p];
          let x = g[f];
          (g[f] = b), x === void 0 && (x = new Ve(h, n[y], i[y])), (g[p] = x);
        }
      } else
        t[f] !== o &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
    }
    this.nCachedObjects_ = c;
  },
  remove: function () {
    const t = this._objects,
      e = this._indicesByUUID,
      n = this._bindings,
      i = n.length;
    let r = this.nCachedObjects_;
    for (let s = 0, o = arguments.length; s !== o; ++s) {
      const a = arguments[s],
        c = a.uuid,
        l = e[c];
      if (l !== void 0 && l >= r) {
        const u = r++,
          h = t[u];
        (e[h.uuid] = l), (t[l] = h), (e[c] = u), (t[u] = a);
        for (let d = 0, f = i; d !== f; ++d) {
          const p = n[d],
            _ = p[u],
            y = p[l];
          (p[l] = _), (p[u] = y);
        }
      }
    }
    this.nCachedObjects_ = r;
  },
  uncache: function () {
    const t = this._objects,
      e = this._indicesByUUID,
      n = this._bindings,
      i = n.length;
    let r = this.nCachedObjects_,
      s = t.length;
    for (let o = 0, a = arguments.length; o !== a; ++o) {
      const c = arguments[o],
        l = c.uuid,
        u = e[l];
      if (u !== void 0)
        if ((delete e[l], u < r)) {
          const h = --r,
            d = t[h],
            f = --s,
            p = t[f];
          (e[d.uuid] = u), (t[u] = d), (e[p.uuid] = h), (t[h] = p), t.pop();
          for (let _ = 0, y = i; _ !== y; ++_) {
            const m = n[_],
              g = m[h],
              b = m[f];
            (m[u] = g), (m[h] = b), m.pop();
          }
        } else {
          const h = --s,
            d = t[h];
          (e[d.uuid] = u), (t[u] = d), t.pop();
          for (let f = 0, p = i; f !== p; ++f) {
            const _ = n[f];
            (_[u] = _[h]), _.pop();
          }
        }
    }
    this.nCachedObjects_ = r;
  },
  subscribe_: function (t, e) {
    let n = this._bindingsIndicesByPath,
      i = n[t],
      r = this._bindings;
    if (i !== void 0) return r[i];
    const s = this._paths,
      o = this._parsedPaths,
      a = this._objects,
      c = a.length,
      l = this.nCachedObjects_,
      u = new Array(c);
    (i = r.length), (n[t] = i), s.push(t), o.push(e), r.push(u);
    for (let h = l, d = a.length; h !== d; ++h) {
      const f = a[h];
      u[h] = new Ve(f, t, e);
    }
    return u;
  },
  unsubscribe_: function (t) {
    const e = this._bindingsIndicesByPath,
      n = e[t];
    if (n !== void 0) {
      const i = this._paths,
        r = this._parsedPaths,
        s = this._bindings,
        o = s.length - 1,
        a = s[o],
        c = t[o];
      (e[c] = n),
        (s[n] = a),
        s.pop(),
        (r[n] = r[o]),
        r.pop(),
        (i[n] = i[o]),
        i.pop();
    }
  },
});
function gg(t, e, n, i) {
  (this._mixer = t),
    (this._clip = e),
    (this._localRoot = n || null),
    (this.blendMode = i || e.blendMode);
  const r = e.tracks,
    s = r.length,
    o = new Array(s),
    a = { endingStart: es, endingEnd: es };
  for (let c = 0; c !== s; ++c) {
    const l = r[c].createInterpolant(null);
    (o[c] = l), (l.settings = a);
  }
  (this._interpolantSettings = a),
    (this._interpolants = o),
    (this._propertyBindings = new Array(s)),
    (this._cacheIndex = null),
    (this._byClipCacheIndex = null),
    (this._timeScaleInterpolant = null),
    (this._weightInterpolant = null),
    (this.loop = $0),
    (this._loopCount = -1),
    (this._startTime = null),
    (this.time = 0),
    (this.timeScale = 1),
    (this._effectiveTimeScale = 1),
    (this.weight = 1),
    (this._effectiveWeight = 1),
    (this.repetitions = 1 / 0),
    (this.paused = !1),
    (this.enabled = !0),
    (this.clampWhenFinished = !1),
    (this.zeroSlopeAtStart = !0),
    (this.zeroSlopeAtEnd = !0);
}
Object.assign(gg.prototype, {
  play: function () {
    return this._mixer._activateAction(this), this;
  },
  stop: function () {
    return this._mixer._deactivateAction(this), this.reset();
  },
  reset: function () {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  },
  isRunning: function () {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  },
  isScheduled: function () {
    return this._mixer._isActiveAction(this);
  },
  startAt: function (t) {
    return (this._startTime = t), this;
  },
  setLoop: function (t, e) {
    return (this.loop = t), (this.repetitions = e), this;
  },
  setEffectiveWeight: function (t) {
    return (
      (this.weight = t),
      (this._effectiveWeight = this.enabled ? t : 0),
      this.stopFading()
    );
  },
  getEffectiveWeight: function () {
    return this._effectiveWeight;
  },
  fadeIn: function (t) {
    return this._scheduleFading(t, 0, 1);
  },
  fadeOut: function (t) {
    return this._scheduleFading(t, 1, 0);
  },
  crossFadeFrom: function (t, e, n) {
    if ((t.fadeOut(e), this.fadeIn(e), n)) {
      const i = this._clip.duration,
        r = t._clip.duration,
        s = r / i,
        o = i / r;
      t.warp(1, s, e), this.warp(o, 1, e);
    }
    return this;
  },
  crossFadeTo: function (t, e, n) {
    return t.crossFadeFrom(this, e, n);
  },
  stopFading: function () {
    let t = this._weightInterpolant;
    return (
      t !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(t)),
      this
    );
  },
  setEffectiveTimeScale: function (t) {
    return (
      (this.timeScale = t),
      (this._effectiveTimeScale = this.paused ? 0 : t),
      this.stopWarping()
    );
  },
  getEffectiveTimeScale: function () {
    return this._effectiveTimeScale;
  },
  setDuration: function (t) {
    return (this.timeScale = this._clip.duration / t), this.stopWarping();
  },
  syncWith: function (t) {
    return (
      (this.time = t.time), (this.timeScale = t.timeScale), this.stopWarping()
    );
  },
  halt: function (t) {
    return this.warp(this._effectiveTimeScale, 0, t);
  },
  warp: function (t, e, n) {
    const i = this._mixer,
      r = i.time,
      s = this.timeScale;
    let o = this._timeScaleInterpolant;
    o === null &&
      ((o = i._lendControlInterpolant()), (this._timeScaleInterpolant = o));
    const a = o.parameterPositions,
      c = o.sampleValues;
    return (a[0] = r), (a[1] = r + n), (c[0] = t / s), (c[1] = e / s), this;
  },
  stopWarping: function () {
    let t = this._timeScaleInterpolant;
    return (
      t !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(t)),
      this
    );
  },
  getMixer: function () {
    return this._mixer;
  },
  getClip: function () {
    return this._clip;
  },
  getRoot: function () {
    return this._localRoot || this._mixer._root;
  },
  _update: function (t, e, n, i) {
    if (!this.enabled) {
      this._updateWeight(t);
      return;
    }
    const r = this._startTime;
    if (r !== null) {
      const a = (t - r) * n;
      if (a < 0 || n === 0) return;
      (this._startTime = null), (e = n * a);
    }
    e *= this._updateTimeScale(t);
    const s = this._updateTime(e),
      o = this._updateWeight(t);
    if (o > 0) {
      const a = this._interpolants,
        c = this._propertyBindings;
      switch (this.blendMode) {
        case Bp:
          for (let l = 0, u = a.length; l !== u; ++l)
            a[l].evaluate(s), c[l].accumulateAdditive(o);
          break;
        case Zu:
        default:
          for (let l = 0, u = a.length; l !== u; ++l)
            a[l].evaluate(s), c[l].accumulate(i, o);
      }
    }
  },
  _updateWeight: function (t) {
    let e = 0;
    if (this.enabled) {
      e = this.weight;
      const n = this._weightInterpolant;
      if (n !== null) {
        const i = n.evaluate(t)[0];
        (e *= i),
          t > n.parameterPositions[1] &&
            (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = e), e;
  },
  _updateTimeScale: function (t) {
    let e = 0;
    if (!this.paused) {
      e = this.timeScale;
      const n = this._timeScaleInterpolant;
      n !== null &&
        ((e *= n.evaluate(t)[0]),
        t > n.parameterPositions[1] &&
          (this.stopWarping(),
          e === 0 ? (this.paused = !0) : (this.timeScale = e)));
    }
    return (this._effectiveTimeScale = e), e;
  },
  _updateTime: function (t) {
    const e = this._clip.duration,
      n = this.loop;
    let i = this.time + t,
      r = this._loopCount;
    const s = n === Q0;
    if (t === 0) return r === -1 ? i : s && (r & 1) == 1 ? e - i : i;
    if (n === J0) {
      r === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      t: {
        if (i >= e) i = e;
        else if (i < 0) i = 0;
        else {
          this.time = i;
          break t;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = i),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: t < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (r === -1 &&
          (t >= 0
            ? ((r = 0), this._setEndings(!0, this.repetitions === 0, s))
            : this._setEndings(this.repetitions === 0, !0, s)),
        i >= e || i < 0)
      ) {
        const o = Math.floor(i / e);
        (i -= e * o), (r += Math.abs(o));
        const a = this.repetitions - r;
        if (a <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (i = t > 0 ? e : 0),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: t > 0 ? 1 : -1,
            });
        else {
          if (a === 1) {
            const c = t < 0;
            this._setEndings(c, !c, s);
          } else this._setEndings(!1, !1, s);
          (this._loopCount = r),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: o,
            });
        }
      } else this.time = i;
      if (s && (r & 1) == 1) return e - i;
    }
    return i;
  },
  _setEndings: function (t, e, n) {
    const i = this._interpolantSettings;
    n
      ? ((i.endingStart = ns), (i.endingEnd = ns))
      : (t
          ? (i.endingStart = this.zeroSlopeAtStart ? ns : es)
          : (i.endingStart = uc),
        e ? (i.endingEnd = this.zeroSlopeAtEnd ? ns : es) : (i.endingEnd = uc));
  },
  _scheduleFading: function (t, e, n) {
    const i = this._mixer,
      r = i.time;
    let s = this._weightInterpolant;
    s === null &&
      ((s = i._lendControlInterpolant()), (this._weightInterpolant = s));
    const o = s.parameterPositions,
      a = s.sampleValues;
    return (o[0] = r), (a[0] = e), (o[1] = r + t), (a[1] = n), this;
  },
});
function yg(t) {
  (this._root = t),
    this._initMemoryManager(),
    (this._accuIndex = 0),
    (this.time = 0),
    (this.timeScale = 1);
}
yg.prototype = Object.assign(Object.create(si.prototype), {
  constructor: yg,
  _bindAction: function (t, e) {
    const n = t._localRoot || this._root,
      i = t._clip.tracks,
      r = i.length,
      s = t._propertyBindings,
      o = t._interpolants,
      a = n.uuid,
      c = this._bindingsByRootAndName;
    let l = c[a];
    l === void 0 && ((l = {}), (c[a] = l));
    for (let u = 0; u !== r; ++u) {
      const h = i[u],
        d = h.name;
      let f = l[d];
      if (f !== void 0) s[u] = f;
      else {
        if (((f = s[u]), f !== void 0)) {
          f._cacheIndex === null &&
            (++f.referenceCount, this._addInactiveBinding(f, a, d));
          continue;
        }
        const p = e && e._propertyBindings[u].binding.parsedPath;
        (f = new pg(Ve.create(n, d, p), h.ValueTypeName, h.getValueSize())),
          ++f.referenceCount,
          this._addInactiveBinding(f, a, d),
          (s[u] = f);
      }
      o[u].resultBuffer = f.buffer;
    }
  },
  _activateAction: function (t) {
    if (!this._isActiveAction(t)) {
      if (t._cacheIndex === null) {
        const n = (t._localRoot || this._root).uuid,
          i = t._clip.uuid,
          r = this._actionsByClip[i];
        this._bindAction(t, r && r.knownActions[0]),
          this._addInactiveAction(t, i, n);
      }
      const e = t._propertyBindings;
      for (let n = 0, i = e.length; n !== i; ++n) {
        const r = e[n];
        r.useCount++ == 0 && (this._lendBinding(r), r.saveOriginalState());
      }
      this._lendAction(t);
    }
  },
  _deactivateAction: function (t) {
    if (this._isActiveAction(t)) {
      const e = t._propertyBindings;
      for (let n = 0, i = e.length; n !== i; ++n) {
        const r = e[n];
        --r.useCount == 0 &&
          (r.restoreOriginalState(), this._takeBackBinding(r));
      }
      this._takeBackAction(t);
    }
  },
  _initMemoryManager: function () {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const t = this;
    this.stats = {
      actions: {
        get total() {
          return t._actions.length;
        },
        get inUse() {
          return t._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return t._bindings.length;
        },
        get inUse() {
          return t._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return t._controlInterpolants.length;
        },
        get inUse() {
          return t._nActiveControlInterpolants;
        },
      },
    };
  },
  _isActiveAction: function (t) {
    const e = t._cacheIndex;
    return e !== null && e < this._nActiveActions;
  },
  _addInactiveAction: function (t, e, n) {
    const i = this._actions,
      r = this._actionsByClip;
    let s = r[e];
    if (s === void 0)
      (s = { knownActions: [t], actionByRoot: {} }),
        (t._byClipCacheIndex = 0),
        (r[e] = s);
    else {
      const o = s.knownActions;
      (t._byClipCacheIndex = o.length), o.push(t);
    }
    (t._cacheIndex = i.length), i.push(t), (s.actionByRoot[n] = t);
  },
  _removeInactiveAction: function (t) {
    const e = this._actions,
      n = e[e.length - 1],
      i = t._cacheIndex;
    (n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null);
    const r = t._clip.uuid,
      s = this._actionsByClip,
      o = s[r],
      a = o.knownActions,
      c = a[a.length - 1],
      l = t._byClipCacheIndex;
    (c._byClipCacheIndex = l),
      (a[l] = c),
      a.pop(),
      (t._byClipCacheIndex = null);
    const u = o.actionByRoot,
      h = (t._localRoot || this._root).uuid;
    delete u[h],
      a.length === 0 && delete s[r],
      this._removeInactiveBindingsForAction(t);
  },
  _removeInactiveBindingsForAction: function (t) {
    const e = t._propertyBindings;
    for (let n = 0, i = e.length; n !== i; ++n) {
      const r = e[n];
      --r.referenceCount == 0 && this._removeInactiveBinding(r);
    }
  },
  _lendAction: function (t) {
    const e = this._actions,
      n = t._cacheIndex,
      i = this._nActiveActions++,
      r = e[i];
    (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
  },
  _takeBackAction: function (t) {
    const e = this._actions,
      n = t._cacheIndex,
      i = --this._nActiveActions,
      r = e[i];
    (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
  },
  _addInactiveBinding: function (t, e, n) {
    const i = this._bindingsByRootAndName,
      r = this._bindings;
    let s = i[e];
    s === void 0 && ((s = {}), (i[e] = s)),
      (s[n] = t),
      (t._cacheIndex = r.length),
      r.push(t);
  },
  _removeInactiveBinding: function (t) {
    const e = this._bindings,
      n = t.binding,
      i = n.rootNode.uuid,
      r = n.path,
      s = this._bindingsByRootAndName,
      o = s[i],
      a = e[e.length - 1],
      c = t._cacheIndex;
    (a._cacheIndex = c),
      (e[c] = a),
      e.pop(),
      delete o[r],
      Object.keys(o).length === 0 && delete s[i];
  },
  _lendBinding: function (t) {
    const e = this._bindings,
      n = t._cacheIndex,
      i = this._nActiveBindings++,
      r = e[i];
    (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
  },
  _takeBackBinding: function (t) {
    const e = this._bindings,
      n = t._cacheIndex,
      i = --this._nActiveBindings,
      r = e[i];
    (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
  },
  _lendControlInterpolant: function () {
    const t = this._controlInterpolants,
      e = this._nActiveControlInterpolants++;
    let n = t[e];
    return (
      n === void 0 &&
        ((n = new pl(
          new Float32Array(2),
          new Float32Array(2),
          1,
          this._controlInterpolantsResultBuffer
        )),
        (n.__cacheIndex = e),
        (t[e] = n)),
      n
    );
  },
  _takeBackControlInterpolant: function (t) {
    const e = this._controlInterpolants,
      n = t.__cacheIndex,
      i = --this._nActiveControlInterpolants,
      r = e[i];
    (t.__cacheIndex = i), (e[i] = t), (r.__cacheIndex = n), (e[n] = r);
  },
  _controlInterpolantsResultBuffer: new Float32Array(1),
  clipAction: function (t, e, n) {
    const i = e || this._root,
      r = i.uuid;
    let s = typeof t == "string" ? Pn.findByName(i, t) : t;
    const o = s !== null ? s.uuid : t;
    let a = this._actionsByClip[o],
      c = null;
    if (
      (n === void 0 && (s !== null ? (n = s.blendMode) : (n = Zu)),
      a !== void 0)
    ) {
      const u = a.actionByRoot[r];
      if (u !== void 0 && u.blendMode === n) return u;
      (c = a.knownActions[0]), s === null && (s = c._clip);
    }
    if (s === null) return null;
    const l = new gg(this, s, e, n);
    return this._bindAction(l, c), this._addInactiveAction(l, o, r), l;
  },
  existingAction: function (t, e) {
    const n = e || this._root,
      i = n.uuid,
      r = typeof t == "string" ? Pn.findByName(n, t) : t,
      s = r ? r.uuid : t,
      o = this._actionsByClip[s];
    return (o !== void 0 && o.actionByRoot[i]) || null;
  },
  stopAllAction: function () {
    const t = this._actions,
      e = this._nActiveActions;
    for (let n = e - 1; n >= 0; --n) t[n].stop();
    return this;
  },
  update: function (t) {
    t *= this.timeScale;
    const e = this._actions,
      n = this._nActiveActions,
      i = (this.time += t),
      r = Math.sign(t),
      s = (this._accuIndex ^= 1);
    for (let c = 0; c !== n; ++c) e[c]._update(i, t, r, s);
    const o = this._bindings,
      a = this._nActiveBindings;
    for (let c = 0; c !== a; ++c) o[c].apply(s);
    return this;
  },
  setTime: function (t) {
    this.time = 0;
    for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
    return this.update(t);
  },
  getRoot: function () {
    return this._root;
  },
  uncacheClip: function (t) {
    const e = this._actions,
      n = t.uuid,
      i = this._actionsByClip,
      r = i[n];
    if (r !== void 0) {
      const s = r.knownActions;
      for (let o = 0, a = s.length; o !== a; ++o) {
        const c = s[o];
        this._deactivateAction(c);
        const l = c._cacheIndex,
          u = e[e.length - 1];
        (c._cacheIndex = null),
          (c._byClipCacheIndex = null),
          (u._cacheIndex = l),
          (e[l] = u),
          e.pop(),
          this._removeInactiveBindingsForAction(c);
      }
      delete i[n];
    }
  },
  uncacheRoot: function (t) {
    const e = t.uuid,
      n = this._actionsByClip;
    for (const s in n) {
      const o = n[s].actionByRoot,
        a = o[e];
      a !== void 0 &&
        (this._deactivateAction(a), this._removeInactiveAction(a));
    }
    const i = this._bindingsByRootAndName,
      r = i[e];
    if (r !== void 0)
      for (const s in r) {
        const o = r[s];
        o.restoreOriginalState(), this._removeInactiveBinding(o);
      }
  },
  uncacheAction: function (t, e) {
    const n = this.existingAction(t, e);
    n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
  },
});
function yf(t) {
  typeof t == "string" &&
    (console.warn("THREE.Uniform: Type parameter is no longer needed."),
    (t = arguments[1])),
    (this.value = t);
}
yf.prototype.clone = function () {
  return new yf(this.value.clone === void 0 ? this.value : this.value.clone());
};
function _g(t, e, n) {
  gn.call(this, t, e), (this.meshPerAttribute = n || 1);
}
_g.prototype = Object.assign(Object.create(gn.prototype), {
  constructor: _g,
  isInstancedInterleavedBuffer: !0,
  copy: function (t) {
    return (
      gn.prototype.copy.call(this, t),
      (this.meshPerAttribute = t.meshPerAttribute),
      this
    );
  },
  clone: function (t) {
    const e = gn.prototype.clone.call(this, t);
    return (e.meshPerAttribute = this.meshPerAttribute), e;
  },
  toJSON: function (t) {
    const e = gn.prototype.toJSON.call(this, t);
    return (
      (e.isInstancedInterleavedBuffer = !0),
      (e.meshPerAttribute = this.meshPerAttribute),
      e
    );
  },
});
function xg(t, e, n, i) {
  (this.ray = new hs(t, e)),
    (this.near = n || 0),
    (this.far = i || 1 / 0),
    (this.camera = null),
    (this.layers = new Qu()),
    (this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {},
    }),
    Object.defineProperties(this.params, {
      PointCloud: {
        get: function () {
          return (
            console.warn(
              "THREE.Raycaster: params.PointCloud has been renamed to params.Points."
            ),
            this.Points
          );
        },
      },
    });
}
function vg(t, e) {
  return t.distance - e.distance;
}
function _f(t, e, n, i) {
  if ((t.layers.test(e.layers) && t.raycast(e, n), i === !0)) {
    const r = t.children;
    for (let s = 0, o = r.length; s < o; s++) _f(r[s], e, n, !0);
  }
}
Object.assign(xg.prototype, {
  set: function (t, e) {
    this.ray.set(t, e);
  },
  setFromCamera: function (t, e) {
    e && e.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
        this.ray.direction
          .set(t.x, t.y, 0.5)
          .unproject(e)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = e))
      : e && e.isOrthographicCamera
      ? (this.ray.origin
          .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
          .unproject(e),
        this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
        (this.camera = e))
      : console.error("THREE.Raycaster: Unsupported camera type.");
  },
  intersectObject: function (t, e, n) {
    const i = n || [];
    return _f(t, this, i, e), i.sort(vg), i;
  },
  intersectObjects: function (t, e, n) {
    const i = n || [];
    if (Array.isArray(t) === !1)
      return (
        console.warn(
          "THREE.Raycaster.intersectObjects: objects is not an Array."
        ),
        i
      );
    for (let r = 0, s = t.length; r < s; r++) _f(t[r], this, i, e);
    return i.sort(vg), i;
  },
});
function d1(t, e, n) {
  return (
    (this.radius = t !== void 0 ? t : 1),
    (this.phi = e !== void 0 ? e : 0),
    (this.theta = n !== void 0 ? n : 0),
    this
  );
}
Object.assign(d1.prototype, {
  set: function (t, e, n) {
    return (this.radius = t), (this.phi = e), (this.theta = n), this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return (
      (this.radius = t.radius), (this.phi = t.phi), (this.theta = t.theta), this
    );
  },
  makeSafe: function () {
    const t = 1e-6;
    return (this.phi = Math.max(t, Math.min(Math.PI - t, this.phi))), this;
  },
  setFromVector3: function (t) {
    return this.setFromCartesianCoords(t.x, t.y, t.z);
  },
  setFromCartesianCoords: function (t, e, n) {
    return (
      (this.radius = Math.sqrt(t * t + e * e + n * n)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(t, n)),
          (this.phi = Math.acos(Pt.clamp(e / this.radius, -1, 1)))),
      this
    );
  },
});
function p1(t, e, n) {
  return (
    (this.radius = t !== void 0 ? t : 1),
    (this.theta = e !== void 0 ? e : 0),
    (this.y = n !== void 0 ? n : 0),
    this
  );
}
Object.assign(p1.prototype, {
  set: function (t, e, n) {
    return (this.radius = t), (this.theta = e), (this.y = n), this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return (
      (this.radius = t.radius), (this.theta = t.theta), (this.y = t.y), this
    );
  },
  setFromVector3: function (t) {
    return this.setFromCartesianCoords(t.x, t.y, t.z);
  },
  setFromCartesianCoords: function (t, e, n) {
    return (
      (this.radius = Math.sqrt(t * t + n * n)),
      (this.theta = Math.atan2(t, n)),
      (this.y = e),
      this
    );
  },
});
const bg = new H();
function wg(t, e) {
  (this.min = t !== void 0 ? t : new H(1 / 0, 1 / 0)),
    (this.max = e !== void 0 ? e : new H(-1 / 0, -1 / 0));
}
Object.assign(wg.prototype, {
  set: function (t, e) {
    return this.min.copy(t), this.max.copy(e), this;
  },
  setFromPoints: function (t) {
    this.makeEmpty();
    for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
    return this;
  },
  setFromCenterAndSize: function (t, e) {
    const n = bg.copy(e).multiplyScalar(0.5);
    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return this.min.copy(t.min), this.max.copy(t.max), this;
  },
  makeEmpty: function () {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  },
  isEmpty: function () {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  },
  getCenter: function (t) {
    return (
      t === void 0 &&
        (console.warn("THREE.Box2: .getCenter() target is now required"),
        (t = new H())),
      this.isEmpty()
        ? t.set(0, 0)
        : t.addVectors(this.min, this.max).multiplyScalar(0.5)
    );
  },
  getSize: function (t) {
    return (
      t === void 0 &&
        (console.warn("THREE.Box2: .getSize() target is now required"),
        (t = new H())),
      this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
    );
  },
  expandByPoint: function (t) {
    return this.min.min(t), this.max.max(t), this;
  },
  expandByVector: function (t) {
    return this.min.sub(t), this.max.add(t), this;
  },
  expandByScalar: function (t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this;
  },
  containsPoint: function (t) {
    return !(
      t.x < this.min.x ||
      t.x > this.max.x ||
      t.y < this.min.y ||
      t.y > this.max.y
    );
  },
  containsBox: function (t) {
    return (
      this.min.x <= t.min.x &&
      t.max.x <= this.max.x &&
      this.min.y <= t.min.y &&
      t.max.y <= this.max.y
    );
  },
  getParameter: function (t, e) {
    return (
      e === void 0 &&
        (console.warn("THREE.Box2: .getParameter() target is now required"),
        (e = new H())),
      e.set(
        (t.x - this.min.x) / (this.max.x - this.min.x),
        (t.y - this.min.y) / (this.max.y - this.min.y)
      )
    );
  },
  intersectsBox: function (t) {
    return !(
      t.max.x < this.min.x ||
      t.min.x > this.max.x ||
      t.max.y < this.min.y ||
      t.min.y > this.max.y
    );
  },
  clampPoint: function (t, e) {
    return (
      e === void 0 &&
        (console.warn("THREE.Box2: .clampPoint() target is now required"),
        (e = new H())),
      e.copy(t).clamp(this.min, this.max)
    );
  },
  distanceToPoint: function (t) {
    return bg.copy(t).clamp(this.min, this.max).sub(t).length();
  },
  intersect: function (t) {
    return this.min.max(t.min), this.max.min(t.max), this;
  },
  union: function (t) {
    return this.min.min(t.min), this.max.max(t.max), this;
  },
  translate: function (t) {
    return this.min.add(t), this.max.add(t), this;
  },
  equals: function (t) {
    return t.min.equals(this.min) && t.max.equals(this.max);
  },
});
const Mg = new S(),
  vl = new S();
function Sg(t, e) {
  (this.start = t !== void 0 ? t : new S()),
    (this.end = e !== void 0 ? e : new S());
}
Object.assign(Sg.prototype, {
  set: function (t, e) {
    return this.start.copy(t), this.end.copy(e), this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return this.start.copy(t.start), this.end.copy(t.end), this;
  },
  getCenter: function (t) {
    return (
      t === void 0 &&
        (console.warn("THREE.Line3: .getCenter() target is now required"),
        (t = new S())),
      t.addVectors(this.start, this.end).multiplyScalar(0.5)
    );
  },
  delta: function (t) {
    return (
      t === void 0 &&
        (console.warn("THREE.Line3: .delta() target is now required"),
        (t = new S())),
      t.subVectors(this.end, this.start)
    );
  },
  distanceSq: function () {
    return this.start.distanceToSquared(this.end);
  },
  distance: function () {
    return this.start.distanceTo(this.end);
  },
  at: function (t, e) {
    return (
      e === void 0 &&
        (console.warn("THREE.Line3: .at() target is now required"),
        (e = new S())),
      this.delta(e).multiplyScalar(t).add(this.start)
    );
  },
  closestPointToPointParameter: function (t, e) {
    Mg.subVectors(t, this.start), vl.subVectors(this.end, this.start);
    const n = vl.dot(vl);
    let r = vl.dot(Mg) / n;
    return e && (r = Pt.clamp(r, 0, 1)), r;
  },
  closestPointToPoint: function (t, e, n) {
    const i = this.closestPointToPointParameter(t, e);
    return (
      n === void 0 &&
        (console.warn(
          "THREE.Line3: .closestPointToPoint() target is now required"
        ),
        (n = new S())),
      this.delta(n).multiplyScalar(i).add(this.start)
    );
  },
  applyMatrix4: function (t) {
    return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
  },
  equals: function (t) {
    return t.start.equals(this.start) && t.end.equals(this.end);
  },
});
function bl(t) {
  nt.call(this),
    (this.material = t),
    (this.render = function () {}),
    (this.hasPositions = !1),
    (this.hasNormals = !1),
    (this.hasColors = !1),
    (this.hasUvs = !1),
    (this.positionArray = null),
    (this.normalArray = null),
    (this.colorArray = null),
    (this.uvArray = null),
    (this.count = 0);
}
bl.prototype = Object.create(nt.prototype);
bl.prototype.constructor = bl;
bl.prototype.isImmediateRenderObject = !0;
const Tg = new S();
function ua(t, e) {
  nt.call(this),
    (this.light = t),
    this.light.updateMatrixWorld(),
    (this.matrix = t.matrixWorld),
    (this.matrixAutoUpdate = !1),
    (this.color = e);
  const n = new ct(),
    i = [
      0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
      0, 0, 0, 0, -1, 1,
    ];
  for (let s = 0, o = 1, a = 32; s < a; s++, o++) {
    const c = (s / a) * Math.PI * 2,
      l = (o / a) * Math.PI * 2;
    i.push(Math.cos(c), Math.sin(c), 1, Math.cos(l), Math.sin(l), 1);
  }
  n.setAttribute("position", new rt(i, 3));
  const r = new me({ fog: !1, toneMapped: !1 });
  (this.cone = new ve(n, r)), this.add(this.cone), this.update();
}
ua.prototype = Object.create(nt.prototype);
ua.prototype.constructor = ua;
ua.prototype.dispose = function () {
  this.cone.geometry.dispose(), this.cone.material.dispose();
};
ua.prototype.update = function () {
  this.light.updateMatrixWorld();
  const t = this.light.distance ? this.light.distance : 1e3,
    e = t * Math.tan(this.light.angle);
  this.cone.scale.set(e, e, t),
    Tg.setFromMatrixPosition(this.light.target.matrixWorld),
    this.cone.lookAt(Tg),
    this.color !== void 0
      ? this.cone.material.color.set(this.color)
      : this.cone.material.color.copy(this.light.color);
};
const Vi = new S(),
  wl = new Rt(),
  xf = new Rt();
function Eg(t) {
  const e = [];
  t && t.isBone && e.push(t);
  for (let n = 0; n < t.children.length; n++)
    e.push.apply(e, Eg(t.children[n]));
  return e;
}
function js(t) {
  const e = Eg(t),
    n = new ct(),
    i = [],
    r = [],
    s = new lt(0, 0, 1),
    o = new lt(0, 1, 0);
  for (let c = 0; c < e.length; c++) {
    const l = e[c];
    l.parent &&
      l.parent.isBone &&
      (i.push(0, 0, 0),
      i.push(0, 0, 0),
      r.push(s.r, s.g, s.b),
      r.push(o.r, o.g, o.b));
  }
  n.setAttribute("position", new rt(i, 3)),
    n.setAttribute("color", new rt(r, 3));
  const a = new me({
    vertexColors: !0,
    depthTest: !1,
    depthWrite: !1,
    toneMapped: !1,
    transparent: !0,
  });
  ve.call(this, n, a),
    (this.type = "SkeletonHelper"),
    (this.root = t),
    (this.bones = e),
    (this.matrix = t.matrixWorld),
    (this.matrixAutoUpdate = !1);
}
js.prototype = Object.create(ve.prototype);
js.prototype.constructor = js;
js.prototype.isSkeletonHelper = !0;
js.prototype.updateMatrixWorld = function (t) {
  const e = this.bones,
    n = this.geometry,
    i = n.getAttribute("position");
  xf.getInverse(this.root.matrixWorld);
  for (let r = 0, s = 0; r < e.length; r++) {
    const o = e[r];
    o.parent &&
      o.parent.isBone &&
      (wl.multiplyMatrices(xf, o.matrixWorld),
      Vi.setFromMatrixPosition(wl),
      i.setXYZ(s, Vi.x, Vi.y, Vi.z),
      wl.multiplyMatrices(xf, o.parent.matrixWorld),
      Vi.setFromMatrixPosition(wl),
      i.setXYZ(s + 1, Vi.x, Vi.y, Vi.z),
      (s += 2));
  }
  (n.getAttribute("position").needsUpdate = !0),
    nt.prototype.updateMatrixWorld.call(this, t);
};
function ha(t, e, n) {
  (this.light = t), this.light.updateMatrixWorld(), (this.color = n);
  const i = new Ds(e, 4, 2),
    r = new Ln({ wireframe: !0, fog: !1, toneMapped: !1 });
  he.call(this, i, r),
    (this.type = "PointLightHelper"),
    (this.matrix = this.light.matrixWorld),
    (this.matrixAutoUpdate = !1),
    this.update();
}
ha.prototype = Object.create(he.prototype);
ha.prototype.constructor = ha;
ha.prototype.dispose = function () {
  this.geometry.dispose(), this.material.dispose();
};
ha.prototype.update = function () {
  this.color !== void 0
    ? this.material.color.set(this.color)
    : this.material.color.copy(this.light.color);
};
const m1 = new S(),
  Ag = new lt(),
  Lg = new lt();
function fa(t, e, n) {
  nt.call(this),
    (this.light = t),
    this.light.updateMatrixWorld(),
    (this.matrix = t.matrixWorld),
    (this.matrixAutoUpdate = !1),
    (this.color = n);
  const i = new Ps(e);
  i.rotateY(Math.PI * 0.5),
    (this.material = new Ln({ wireframe: !0, fog: !1, toneMapped: !1 })),
    this.color === void 0 && (this.material.vertexColors = !0);
  const r = i.getAttribute("position"),
    s = new Float32Array(r.count * 3);
  i.setAttribute("color", new wt(s, 3)),
    this.add(new he(i, this.material)),
    this.update();
}
fa.prototype = Object.create(nt.prototype);
fa.prototype.constructor = fa;
fa.prototype.dispose = function () {
  this.children[0].geometry.dispose(), this.children[0].material.dispose();
};
fa.prototype.update = function () {
  const t = this.children[0];
  if (this.color !== void 0) this.material.color.set(this.color);
  else {
    const e = t.geometry.getAttribute("color");
    Ag.copy(this.light.color), Lg.copy(this.light.groundColor);
    for (let n = 0, i = e.count; n < i; n++) {
      const r = n < i / 2 ? Ag : Lg;
      e.setXYZ(n, r.r, r.g, r.b);
    }
    e.needsUpdate = !0;
  }
  t.lookAt(m1.setFromMatrixPosition(this.light.matrixWorld).negate());
};
function vf(t, e, n, i) {
  (t = t || 10),
    (e = e || 10),
    (n = new lt(n !== void 0 ? n : 4473924)),
    (i = new lt(i !== void 0 ? i : 8947848));
  const r = e / 2,
    s = t / e,
    o = t / 2,
    a = [],
    c = [];
  for (let h = 0, d = 0, f = -o; h <= e; h++, f += s) {
    a.push(-o, 0, f, o, 0, f), a.push(f, 0, -o, f, 0, o);
    const p = h === r ? n : i;
    p.toArray(c, d),
      (d += 3),
      p.toArray(c, d),
      (d += 3),
      p.toArray(c, d),
      (d += 3),
      p.toArray(c, d),
      (d += 3);
  }
  const l = new ct();
  l.setAttribute("position", new rt(a, 3)),
    l.setAttribute("color", new rt(c, 3));
  const u = new me({ vertexColors: !0, toneMapped: !1 });
  ve.call(this, l, u), (this.type = "GridHelper");
}
vf.prototype = Object.assign(Object.create(ve.prototype), {
  constructor: vf,
  copy: function (t) {
    return (
      ve.prototype.copy.call(this, t),
      this.geometry.copy(t.geometry),
      this.material.copy(t.material),
      this
    );
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
});
function bf(t, e, n, i, r, s) {
  (t = t || 10),
    (e = e || 16),
    (n = n || 8),
    (i = i || 64),
    (r = new lt(r !== void 0 ? r : 4473924)),
    (s = new lt(s !== void 0 ? s : 8947848));
  const o = [],
    a = [];
  for (let u = 0; u <= e; u++) {
    const h = (u / e) * (Math.PI * 2),
      d = Math.sin(h) * t,
      f = Math.cos(h) * t;
    o.push(0, 0, 0), o.push(d, 0, f);
    const p = u & 1 ? r : s;
    a.push(p.r, p.g, p.b), a.push(p.r, p.g, p.b);
  }
  for (let u = 0; u <= n; u++) {
    const h = u & 1 ? r : s,
      d = t - (t / n) * u;
    for (let f = 0; f < i; f++) {
      let p = (f / i) * (Math.PI * 2),
        _ = Math.sin(p) * d,
        y = Math.cos(p) * d;
      o.push(_, 0, y),
        a.push(h.r, h.g, h.b),
        (p = ((f + 1) / i) * (Math.PI * 2)),
        (_ = Math.sin(p) * d),
        (y = Math.cos(p) * d),
        o.push(_, 0, y),
        a.push(h.r, h.g, h.b);
    }
  }
  const c = new ct();
  c.setAttribute("position", new rt(o, 3)),
    c.setAttribute("color", new rt(a, 3));
  const l = new me({ vertexColors: !0, toneMapped: !1 });
  ve.call(this, c, l), (this.type = "PolarGridHelper");
}
bf.prototype = Object.create(ve.prototype);
bf.prototype.constructor = bf;
const Pg = new S(),
  Ml = new S(),
  Cg = new S();
function da(t, e, n) {
  nt.call(this),
    (this.light = t),
    this.light.updateMatrixWorld(),
    (this.matrix = t.matrixWorld),
    (this.matrixAutoUpdate = !1),
    (this.color = n),
    e === void 0 && (e = 1);
  let i = new ct();
  i.setAttribute(
    "position",
    new rt([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)
  );
  const r = new me({ fog: !1, toneMapped: !1 });
  (this.lightPlane = new yn(i, r)),
    this.add(this.lightPlane),
    (i = new ct()),
    i.setAttribute("position", new rt([0, 0, 0, 0, 0, 1], 3)),
    (this.targetLine = new yn(i, r)),
    this.add(this.targetLine),
    this.update();
}
da.prototype = Object.create(nt.prototype);
da.prototype.constructor = da;
da.prototype.dispose = function () {
  this.lightPlane.geometry.dispose(),
    this.lightPlane.material.dispose(),
    this.targetLine.geometry.dispose(),
    this.targetLine.material.dispose();
};
da.prototype.update = function () {
  Pg.setFromMatrixPosition(this.light.matrixWorld),
    Ml.setFromMatrixPosition(this.light.target.matrixWorld),
    Cg.subVectors(Ml, Pg),
    this.lightPlane.lookAt(Ml),
    this.color !== void 0
      ? (this.lightPlane.material.color.set(this.color),
        this.targetLine.material.color.set(this.color))
      : (this.lightPlane.material.color.copy(this.light.color),
        this.targetLine.material.color.copy(this.light.color)),
    this.targetLine.lookAt(Ml),
    (this.targetLine.scale.z = Cg.length());
};
const Sl = new S(),
  fe = new fi();
function Tl(t) {
  const e = new ct(),
    n = new me({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
    i = [],
    r = [],
    s = {},
    o = new lt(16755200),
    a = new lt(16711680),
    c = new lt(43775),
    l = new lt(16777215),
    u = new lt(3355443);
  h("n1", "n2", o),
    h("n2", "n4", o),
    h("n4", "n3", o),
    h("n3", "n1", o),
    h("f1", "f2", o),
    h("f2", "f4", o),
    h("f4", "f3", o),
    h("f3", "f1", o),
    h("n1", "f1", o),
    h("n2", "f2", o),
    h("n3", "f3", o),
    h("n4", "f4", o),
    h("p", "n1", a),
    h("p", "n2", a),
    h("p", "n3", a),
    h("p", "n4", a),
    h("u1", "u2", c),
    h("u2", "u3", c),
    h("u3", "u1", c),
    h("c", "t", l),
    h("p", "c", u),
    h("cn1", "cn2", u),
    h("cn3", "cn4", u),
    h("cf1", "cf2", u),
    h("cf3", "cf4", u);
  function h(f, p, _) {
    d(f, _), d(p, _);
  }
  function d(f, p) {
    i.push(0, 0, 0),
      r.push(p.r, p.g, p.b),
      s[f] === void 0 && (s[f] = []),
      s[f].push(i.length / 3 - 1);
  }
  e.setAttribute("position", new rt(i, 3)),
    e.setAttribute("color", new rt(r, 3)),
    ve.call(this, e, n),
    (this.type = "CameraHelper"),
    (this.camera = t),
    this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
    (this.matrix = t.matrixWorld),
    (this.matrixAutoUpdate = !1),
    (this.pointMap = s),
    this.update();
}
Tl.prototype = Object.create(ve.prototype);
Tl.prototype.constructor = Tl;
Tl.prototype.update = function () {
  const t = this.geometry,
    e = this.pointMap,
    n = 1,
    i = 1;
  fe.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
    ge("c", e, t, fe, 0, 0, -1),
    ge("t", e, t, fe, 0, 0, 1),
    ge("n1", e, t, fe, -n, -i, -1),
    ge("n2", e, t, fe, n, -i, -1),
    ge("n3", e, t, fe, -n, i, -1),
    ge("n4", e, t, fe, n, i, -1),
    ge("f1", e, t, fe, -n, -i, 1),
    ge("f2", e, t, fe, n, -i, 1),
    ge("f3", e, t, fe, -n, i, 1),
    ge("f4", e, t, fe, n, i, 1),
    ge("u1", e, t, fe, n * 0.7, i * 1.1, -1),
    ge("u2", e, t, fe, -n * 0.7, i * 1.1, -1),
    ge("u3", e, t, fe, 0, i * 2, -1),
    ge("cf1", e, t, fe, -n, 0, 1),
    ge("cf2", e, t, fe, n, 0, 1),
    ge("cf3", e, t, fe, 0, -i, 1),
    ge("cf4", e, t, fe, 0, i, 1),
    ge("cn1", e, t, fe, -n, 0, -1),
    ge("cn2", e, t, fe, n, 0, -1),
    ge("cn3", e, t, fe, 0, -i, -1),
    ge("cn4", e, t, fe, 0, i, -1),
    (t.getAttribute("position").needsUpdate = !0);
};
function ge(t, e, n, i, r, s, o) {
  Sl.set(r, s, o).unproject(i);
  const a = e[t];
  if (a !== void 0) {
    const c = n.getAttribute("position");
    for (let l = 0, u = a.length; l < u; l++) c.setXYZ(a[l], Sl.x, Sl.y, Sl.z);
  }
}
const El = new Hn();
function Sr(t, e) {
  (this.object = t), e === void 0 && (e = 16776960);
  const n = new Uint16Array([
      0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
    ]),
    i = new Float32Array(8 * 3),
    r = new ct();
  r.setIndex(new wt(n, 1)),
    r.setAttribute("position", new wt(i, 3)),
    ve.call(this, r, new me({ color: e, toneMapped: !1 })),
    (this.type = "BoxHelper"),
    (this.matrixAutoUpdate = !1),
    this.update();
}
Sr.prototype = Object.create(ve.prototype);
Sr.prototype.constructor = Sr;
Sr.prototype.update = function (t) {
  if (
    (t !== void 0 &&
      console.warn("THREE.BoxHelper: .update() has no longer arguments."),
    this.object !== void 0 && El.setFromObject(this.object),
    El.isEmpty())
  )
    return;
  const e = El.min,
    n = El.max,
    i = this.geometry.attributes.position,
    r = i.array;
  (r[0] = n.x),
    (r[1] = n.y),
    (r[2] = n.z),
    (r[3] = e.x),
    (r[4] = n.y),
    (r[5] = n.z),
    (r[6] = e.x),
    (r[7] = e.y),
    (r[8] = n.z),
    (r[9] = n.x),
    (r[10] = e.y),
    (r[11] = n.z),
    (r[12] = n.x),
    (r[13] = n.y),
    (r[14] = e.z),
    (r[15] = e.x),
    (r[16] = n.y),
    (r[17] = e.z),
    (r[18] = e.x),
    (r[19] = e.y),
    (r[20] = e.z),
    (r[21] = n.x),
    (r[22] = e.y),
    (r[23] = e.z),
    (i.needsUpdate = !0),
    this.geometry.computeBoundingSphere();
};
Sr.prototype.setFromObject = function (t) {
  return (this.object = t), this.update(), this;
};
Sr.prototype.copy = function (t) {
  return ve.prototype.copy.call(this, t), (this.object = t.object), this;
};
Sr.prototype.clone = function () {
  return new this.constructor().copy(this);
};
function Al(t, e) {
  (this.type = "Box3Helper"), (this.box = t), (e = e || 16776960);
  const n = new Uint16Array([
      0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
    ]),
    i = [
      1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
      1, -1, -1,
    ],
    r = new ct();
  r.setIndex(new wt(n, 1)),
    r.setAttribute("position", new rt(i, 3)),
    ve.call(this, r, new me({ color: e, toneMapped: !1 })),
    (this.type = "Box3Helper"),
    this.geometry.computeBoundingSphere();
}
Al.prototype = Object.create(ve.prototype);
Al.prototype.constructor = Al;
Al.prototype.updateMatrixWorld = function (t) {
  const e = this.box;
  e.isEmpty() ||
    (e.getCenter(this.position),
    e.getSize(this.scale),
    this.scale.multiplyScalar(0.5),
    nt.prototype.updateMatrixWorld.call(this, t));
};
function Ll(t, e, n) {
  (this.plane = t), (this.size = e === void 0 ? 1 : e);
  const i = n !== void 0 ? n : 16776960,
    r = [
      1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1,
      1, 1, 0, 0, 1, 0, 0, 0,
    ],
    s = new ct();
  s.setAttribute("position", new rt(r, 3)),
    s.computeBoundingSphere(),
    yn.call(this, s, new me({ color: i, toneMapped: !1 })),
    (this.type = "PlaneHelper");
  const o = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
    a = new ct();
  a.setAttribute("position", new rt(o, 3)),
    a.computeBoundingSphere(),
    this.add(
      new he(
        a,
        new Ln({
          color: i,
          opacity: 0.2,
          transparent: !0,
          depthWrite: !1,
          toneMapped: !1,
        })
      )
    );
}
Ll.prototype = Object.create(yn.prototype);
Ll.prototype.constructor = Ll;
Ll.prototype.updateMatrixWorld = function (t) {
  let e = -this.plane.constant;
  Math.abs(e) < 1e-8 && (e = 1e-8),
    this.scale.set(0.5 * this.size, 0.5 * this.size, e),
    (this.children[0].material.side = e < 0 ? Ee : po),
    this.lookAt(this.plane.normal),
    nt.prototype.updateMatrixWorld.call(this, t);
};
const Rg = new S();
let Pl, wf;
function Wi(t, e, n, i, r, s) {
  nt.call(this),
    (this.type = "ArrowHelper"),
    t === void 0 && (t = new S(0, 0, 1)),
    e === void 0 && (e = new S(0, 0, 0)),
    n === void 0 && (n = 1),
    i === void 0 && (i = 16776960),
    r === void 0 && (r = 0.2 * n),
    s === void 0 && (s = 0.2 * r),
    Pl === void 0 &&
      ((Pl = new ct()),
      Pl.setAttribute("position", new rt([0, 0, 0, 0, 1, 0], 3)),
      (wf = new Gi(0, 0.5, 1, 5, 1)),
      wf.translate(0, -0.5, 0)),
    this.position.copy(e),
    (this.line = new yn(Pl, new me({ color: i, toneMapped: !1 }))),
    (this.line.matrixAutoUpdate = !1),
    this.add(this.line),
    (this.cone = new he(wf, new Ln({ color: i, toneMapped: !1 }))),
    (this.cone.matrixAutoUpdate = !1),
    this.add(this.cone),
    this.setDirection(t),
    this.setLength(n, r, s);
}
Wi.prototype = Object.create(nt.prototype);
Wi.prototype.constructor = Wi;
Wi.prototype.setDirection = function (t) {
  if (t.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
  else if (t.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
  else {
    Rg.set(t.z, 0, -t.x).normalize();
    const e = Math.acos(t.y);
    this.quaternion.setFromAxisAngle(Rg, e);
  }
};
Wi.prototype.setLength = function (t, e, n) {
  e === void 0 && (e = 0.2 * t),
    n === void 0 && (n = 0.2 * e),
    this.line.scale.set(1, Math.max(1e-4, t - e), 1),
    this.line.updateMatrix(),
    this.cone.scale.set(n, e, n),
    (this.cone.position.y = t),
    this.cone.updateMatrix();
};
Wi.prototype.setColor = function (t) {
  this.line.material.color.set(t), this.cone.material.color.set(t);
};
Wi.prototype.copy = function (t) {
  return (
    nt.prototype.copy.call(this, t, !1),
    this.line.copy(t.line),
    this.cone.copy(t.cone),
    this
  );
};
Wi.prototype.clone = function () {
  return new this.constructor().copy(this);
};
function Mf(t) {
  t = t || 1;
  const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
    n = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
    i = new ct();
  i.setAttribute("position", new rt(e, 3)),
    i.setAttribute("color", new rt(n, 3));
  const r = new me({ vertexColors: !0, toneMapped: !1 });
  ve.call(this, i, r), (this.type = "AxesHelper");
}
Mf.prototype = Object.create(ve.prototype);
Mf.prototype.constructor = Mf;
const Cl = 4,
  Rl = 8,
  Og = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  g1 = Rl - Cl + 1 + Og.length;
new ca();
y1();
const Tr = (1 + Math.sqrt(5)) / 2,
  qs = 1 / Tr;
new S(1, 1, 1),
  new S(-1, 1, 1),
  new S(1, 1, -1),
  new S(-1, 1, -1),
  new S(0, Tr, qs),
  new S(0, Tr, -qs),
  new S(qs, 0, Tr),
  new S(-qs, 0, Tr),
  new S(Tr, qs, 0),
  new S(-Tr, qs, 0);
function y1() {
  const t = [],
    e = [],
    n = [];
  let i = Rl;
  for (let r = 0; r < g1; r++) {
    const s = Math.pow(2, i);
    e.push(s);
    let o = 1 / s;
    r > Rl - Cl ? (o = Og[r - Rl + Cl - 1]) : r == 0 && (o = 0), n.push(o);
    const a = 1 / (s - 1),
      c = -a / 2,
      l = 1 + a / 2,
      u = [c, c, l, c, l, l, c, c, l, l, c, l],
      h = 6,
      d = 6,
      f = 3,
      p = 2,
      _ = 1,
      y = new Float32Array(f * d * h),
      m = new Float32Array(p * d * h),
      g = new Float32Array(_ * d * h);
    for (let x = 0; x < h; x++) {
      const v = ((x % 3) * 2) / 3 - 1,
        w = x > 2 ? 0 : -1,
        M = [
          v,
          w,
          0,
          v + 2 / 3,
          w,
          0,
          v + 2 / 3,
          w + 1,
          0,
          v,
          w,
          0,
          v + 2 / 3,
          w + 1,
          0,
          v,
          w + 1,
          0,
        ];
      y.set(M, f * d * x), m.set(u, p * d * x);
      const C = [x, x, x, x, x, x];
      g.set(C, _ * d * x);
    }
    const b = new ct();
    b.setAttribute("position", new wt(y, f)),
      b.setAttribute("uv", new wt(m, p)),
      b.setAttribute("faceIndex", new wt(g, _)),
      t.push(b),
      i > Cl && i--;
  }
  return { _lodPlanes: t, _sizeLods: e, _sigmas: n };
}
_t.create = function (t, e) {
  return (
    console.log("THREE.Curve.create() has been deprecated"),
    (t.prototype = Object.create(_t.prototype)),
    (t.prototype.constructor = t),
    (t.prototype.getPoint = e),
    t
  );
};
Object.assign(Hi.prototype, {
  createPointsGeometry: function (t) {
    console.warn(
      "THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
    );
    const e = this.getPoints(t);
    return this.createGeometry(e);
  },
  createSpacedPointsGeometry: function (t) {
    console.warn(
      "THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
    );
    const e = this.getSpacedPoints(t);
    return this.createGeometry(e);
  },
  createGeometry: function (t) {
    console.warn(
      "THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
    );
    const e = new Mt();
    for (let n = 0, i = t.length; n < i; n++) {
      const r = t[n];
      e.vertices.push(new S(r.x, r.y, r.z || 0));
    }
    return e;
  },
});
Object.assign($n.prototype, {
  fromPoints: function (t) {
    return (
      console.warn(
        "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
      ),
      this.setFromPoints(t)
    );
  },
});
function Dg(t) {
  console.warn(
    "THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."
  ),
    Rn.call(this, t),
    (this.type = "catmullrom");
}
Dg.prototype = Object.create(Rn.prototype);
Object.assign(Dg.prototype, {
  initFromArray: function () {
    console.error("THREE.Spline: .initFromArray() has been removed.");
  },
  getControlPointsArray: function () {
    console.error("THREE.Spline: .getControlPointsArray() has been removed.");
  },
  reparametrizeByArcLength: function () {
    console.error(
      "THREE.Spline: .reparametrizeByArcLength() has been removed."
    );
  },
});
vf.prototype.setColors = function () {
  console.error(
    "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
  );
};
js.prototype.update = function () {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
Object.assign(Wt.prototype, {
  extractUrlBase: function (t) {
    return (
      console.warn(
        "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
      ),
      Jm.extractUrlBase(t)
    );
  },
});
Wt.Handlers = {
  add: function () {
    console.error(
      "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
    );
  },
  get: function () {
    console.error(
      "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
    );
  },
};
Object.assign(df.prototype, {
  setTexturePath: function (t) {
    return (
      console.warn(
        "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
      ),
      this.setResourcePath(t)
    );
  },
});
Object.assign(wg.prototype, {
  center: function (t) {
    return (
      console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),
      this.getCenter(t)
    );
  },
  empty: function () {
    return (
      console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
      this.isEmpty()
    );
  },
  isIntersectionBox: function (t) {
    return (
      console.warn(
        "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
      ),
      this.intersectsBox(t)
    );
  },
  size: function (t) {
    return (
      console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
      this.getSize(t)
    );
  },
});
Object.assign(Hn.prototype, {
  center: function (t) {
    return (
      console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
      this.getCenter(t)
    );
  },
  empty: function () {
    return (
      console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
      this.isEmpty()
    );
  },
  isIntersectionBox: function (t) {
    return (
      console.warn(
        "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
      ),
      this.intersectsBox(t)
    );
  },
  isIntersectionSphere: function (t) {
    return (
      console.warn(
        "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
      ),
      this.intersectsSphere(t)
    );
  },
  size: function (t) {
    return (
      console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
      this.getSize(t)
    );
  },
});
Object.assign(ci.prototype, {
  empty: function () {
    return (
      console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),
      this.isEmpty()
    );
  },
});
Ro.prototype.setFromMatrix = function (t) {
  return (
    console.warn(
      "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
    ),
    this.setFromProjectionMatrix(t)
  );
};
Sg.prototype.center = function (t) {
  return (
    console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),
    this.getCenter(t)
  );
};
Object.assign(Pt, {
  random16: function () {
    return (
      console.warn(
        "THREE.Math: .random16() has been deprecated. Use Math.random() instead."
      ),
      Math.random()
    );
  },
  nearestPowerOfTwo: function (t) {
    return (
      console.warn(
        "THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."
      ),
      Pt.floorPowerOfTwo(t)
    );
  },
  nextPowerOfTwo: function (t) {
    return (
      console.warn(
        "THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."
      ),
      Pt.ceilPowerOfTwo(t)
    );
  },
});
Object.assign(Ge.prototype, {
  flattenToArrayOffset: function (t, e) {
    return (
      console.warn(
        "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
      ),
      this.toArray(t, e)
    );
  },
  multiplyVector3: function (t) {
    return (
      console.warn(
        "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
      ),
      t.applyMatrix3(this)
    );
  },
  multiplyVector3Array: function () {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
  },
  applyToBufferAttribute: function (t) {
    return (
      console.warn(
        "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
      ),
      t.applyMatrix3(this)
    );
  },
  applyToVector3Array: function () {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
  },
});
Object.assign(Rt.prototype, {
  extractPosition: function (t) {
    return (
      console.warn(
        "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
      ),
      this.copyPosition(t)
    );
  },
  flattenToArrayOffset: function (t, e) {
    return (
      console.warn(
        "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
      ),
      this.toArray(t, e)
    );
  },
  getPosition: function () {
    return (
      console.warn(
        "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
      ),
      new S().setFromMatrixColumn(this, 3)
    );
  },
  setRotationFromQuaternion: function (t) {
    return (
      console.warn(
        "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
      ),
      this.makeRotationFromQuaternion(t)
    );
  },
  multiplyToArray: function () {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
  },
  multiplyVector3: function (t) {
    return (
      console.warn(
        "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
      ),
      t.applyMatrix4(this)
    );
  },
  multiplyVector4: function (t) {
    return (
      console.warn(
        "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
      ),
      t.applyMatrix4(this)
    );
  },
  multiplyVector3Array: function () {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
  },
  rotateAxis: function (t) {
    console.warn(
      "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
    ),
      t.transformDirection(this);
  },
  crossVector: function (t) {
    return (
      console.warn(
        "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
      ),
      t.applyMatrix4(this)
    );
  },
  translate: function () {
    console.error("THREE.Matrix4: .translate() has been removed.");
  },
  rotateX: function () {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
  },
  rotateY: function () {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
  },
  rotateZ: function () {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
  },
  rotateByAxis: function () {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
  },
  applyToBufferAttribute: function (t) {
    return (
      console.warn(
        "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
      ),
      t.applyMatrix4(this)
    );
  },
  applyToVector3Array: function () {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
  },
  makeFrustum: function (t, e, n, i, r, s) {
    return (
      console.warn(
        "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
      ),
      this.makePerspective(t, e, i, n, r, s)
    );
  },
});
Vn.prototype.isIntersectionLine = function (t) {
  return (
    console.warn(
      "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
    ),
    this.intersectsLine(t)
  );
};
Ae.prototype.multiplyVector3 = function (t) {
  return (
    console.warn(
      "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
    ),
    t.applyQuaternion(this)
  );
};
Object.assign(hs.prototype, {
  isIntersectionBox: function (t) {
    return (
      console.warn(
        "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
      ),
      this.intersectsBox(t)
    );
  },
  isIntersectionPlane: function (t) {
    return (
      console.warn(
        "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
      ),
      this.intersectsPlane(t)
    );
  },
  isIntersectionSphere: function (t) {
    return (
      console.warn(
        "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
      ),
      this.intersectsSphere(t)
    );
  },
});
Object.assign(Re.prototype, {
  area: function () {
    return (
      console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
      this.getArea()
    );
  },
  barycoordFromPoint: function (t, e) {
    return (
      console.warn(
        "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
      ),
      this.getBarycoord(t, e)
    );
  },
  midpoint: function (t) {
    return (
      console.warn(
        "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
      ),
      this.getMidpoint(t)
    );
  },
  normal: function (t) {
    return (
      console.warn(
        "THREE.Triangle: .normal() has been renamed to .getNormal()."
      ),
      this.getNormal(t)
    );
  },
  plane: function (t) {
    return (
      console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),
      this.getPlane(t)
    );
  },
});
Object.assign(Re, {
  barycoordFromPoint: function (t, e, n, i, r) {
    return (
      console.warn(
        "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
      ),
      Re.getBarycoord(t, e, n, i, r)
    );
  },
  normal: function (t, e, n, i) {
    return (
      console.warn(
        "THREE.Triangle: .normal() has been renamed to .getNormal()."
      ),
      Re.getNormal(t, e, n, i)
    );
  },
});
Object.assign(xr.prototype, {
  extractAllPoints: function (t) {
    return (
      console.warn(
        "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
      ),
      this.extractPoints(t)
    );
  },
  extrude: function (t) {
    return (
      console.warn(
        "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
      ),
      new Os(this, t)
    );
  },
  makeGeometry: function (t) {
    return (
      console.warn(
        "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
      ),
      new Is(this, t)
    );
  },
});
Object.assign(H.prototype, {
  fromAttribute: function (t, e, n) {
    return (
      console.warn(
        "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
      ),
      this.fromBufferAttribute(t, e, n)
    );
  },
  distanceToManhattan: function (t) {
    return (
      console.warn(
        "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
      ),
      this.manhattanDistanceTo(t)
    );
  },
  lengthManhattan: function () {
    return (
      console.warn(
        "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
      ),
      this.manhattanLength()
    );
  },
});
Object.assign(S.prototype, {
  setEulerFromRotationMatrix: function () {
    console.error(
      "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
    );
  },
  setEulerFromQuaternion: function () {
    console.error(
      "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
    );
  },
  getPositionFromMatrix: function (t) {
    return (
      console.warn(
        "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
      ),
      this.setFromMatrixPosition(t)
    );
  },
  getScaleFromMatrix: function (t) {
    return (
      console.warn(
        "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
      ),
      this.setFromMatrixScale(t)
    );
  },
  getColumnFromMatrix: function (t, e) {
    return (
      console.warn(
        "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
      ),
      this.setFromMatrixColumn(e, t)
    );
  },
  applyProjection: function (t) {
    return (
      console.warn(
        "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
      ),
      this.applyMatrix4(t)
    );
  },
  fromAttribute: function (t, e, n) {
    return (
      console.warn(
        "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
      ),
      this.fromBufferAttribute(t, e, n)
    );
  },
  distanceToManhattan: function (t) {
    return (
      console.warn(
        "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
      ),
      this.manhattanDistanceTo(t)
    );
  },
  lengthManhattan: function () {
    return (
      console.warn(
        "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
      ),
      this.manhattanLength()
    );
  },
});
Object.assign(Vt.prototype, {
  fromAttribute: function (t, e, n) {
    return (
      console.warn(
        "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
      ),
      this.fromBufferAttribute(t, e, n)
    );
  },
  lengthManhattan: function () {
    return (
      console.warn(
        "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
      ),
      this.manhattanLength()
    );
  },
});
Object.assign(Mt.prototype, {
  computeTangents: function () {
    console.error("THREE.Geometry: .computeTangents() has been removed.");
  },
  computeLineDistances: function () {
    console.error(
      "THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
    );
  },
  applyMatrix: function (t) {
    return (
      console.warn(
        "THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."
      ),
      this.applyMatrix4(t)
    );
  },
});
Object.assign(nt.prototype, {
  getChildByName: function (t) {
    return (
      console.warn(
        "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
      ),
      this.getObjectByName(t)
    );
  },
  renderDepth: function () {
    console.warn(
      "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
    );
  },
  translate: function (t, e) {
    return (
      console.warn(
        "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
      ),
      this.translateOnAxis(e, t)
    );
  },
  getWorldRotation: function () {
    console.error(
      "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
    );
  },
  applyMatrix: function (t) {
    return (
      console.warn(
        "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
      ),
      this.applyMatrix4(t)
    );
  },
});
Object.defineProperties(nt.prototype, {
  eulerOrder: {
    get: function () {
      return (
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
        this.rotation.order
      );
    },
    set: function (t) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
        (this.rotation.order = t);
    },
  },
  useQuaternion: {
    get: function () {
      console.warn(
        "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
      );
    },
    set: function () {
      console.warn(
        "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
      );
    },
  },
});
Object.assign(he.prototype, {
  setDrawMode: function () {
    console.error(
      "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
    );
  },
});
Object.defineProperties(he.prototype, {
  drawMode: {
    get: function () {
      return (
        console.error(
          "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
        ),
        K0
      );
    },
    set: function () {
      console.error(
        "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
      );
    },
  },
});
Object.defineProperties(Bc.prototype, {
  objects: {
    get: function () {
      return (
        console.warn("THREE.LOD: .objects has been renamed to .levels."),
        this.levels
      );
    },
  },
});
Object.defineProperty(Oh.prototype, "useVertexTexture", {
  get: function () {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  },
  set: function () {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  },
});
Rh.prototype.initBones = function () {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
Object.defineProperty(_t.prototype, "__arcLengthDivisions", {
  get: function () {
    return (
      console.warn(
        "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
      ),
      this.arcLengthDivisions
    );
  },
  set: function (t) {
    console.warn(
      "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
    ),
      (this.arcLengthDivisions = t);
  },
});
Pe.prototype.setLens = function (t, e) {
  console.warn(
    "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
  ),
    e !== void 0 && (this.filmGauge = e),
    this.setFocalLength(t);
};
Object.defineProperties(ee.prototype, {
  onlyShadow: {
    set: function () {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    },
  },
  shadowCameraFov: {
    set: function (t) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
        (this.shadow.camera.fov = t);
    },
  },
  shadowCameraLeft: {
    set: function (t) {
      console.warn(
        "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
      ),
        (this.shadow.camera.left = t);
    },
  },
  shadowCameraRight: {
    set: function (t) {
      console.warn(
        "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
      ),
        (this.shadow.camera.right = t);
    },
  },
  shadowCameraTop: {
    set: function (t) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
        (this.shadow.camera.top = t);
    },
  },
  shadowCameraBottom: {
    set: function (t) {
      console.warn(
        "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
      ),
        (this.shadow.camera.bottom = t);
    },
  },
  shadowCameraNear: {
    set: function (t) {
      console.warn(
        "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
      ),
        (this.shadow.camera.near = t);
    },
  },
  shadowCameraFar: {
    set: function (t) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
        (this.shadow.camera.far = t);
    },
  },
  shadowCameraVisible: {
    set: function () {
      console.warn(
        "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
      );
    },
  },
  shadowBias: {
    set: function (t) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
        (this.shadow.bias = t);
    },
  },
  shadowDarkness: {
    set: function () {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    },
  },
  shadowMapWidth: {
    set: function (t) {
      console.warn(
        "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
      ),
        (this.shadow.mapSize.width = t);
    },
  },
  shadowMapHeight: {
    set: function (t) {
      console.warn(
        "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
      ),
        (this.shadow.mapSize.height = t);
    },
  },
});
Object.defineProperties(wt.prototype, {
  length: {
    get: function () {
      return (
        console.warn(
          "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
        ),
        this.array.length
      );
    },
  },
  dynamic: {
    get: function () {
      return (
        console.warn(
          "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
        ),
        this.usage === bo
      );
    },
    set: function () {
      console.warn(
        "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
      ),
        this.setUsage(bo);
    },
  },
});
Object.assign(wt.prototype, {
  setDynamic: function (t) {
    return (
      console.warn(
        "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
      ),
      this.setUsage(t === !0 ? bo : hc),
      this
    );
  },
  copyIndicesArray: function () {
    console.error(
      "THREE.BufferAttribute: .copyIndicesArray() has been removed."
    );
  },
  setArray: function () {
    console.error(
      "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
    );
  },
});
Object.assign(ct.prototype, {
  addIndex: function (t) {
    console.warn(
      "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
    ),
      this.setIndex(t);
  },
  addAttribute: function (t, e) {
    return (
      console.warn(
        "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
      ),
      !(e && e.isBufferAttribute) && !(e && e.isInterleavedBufferAttribute)
        ? (console.warn(
            "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
          ),
          this.setAttribute(t, new wt(arguments[1], arguments[2])))
        : t === "index"
        ? (console.warn(
            "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
          ),
          this.setIndex(e),
          this)
        : this.setAttribute(t, e)
    );
  },
  addDrawCall: function (t, e, n) {
    n !== void 0 &&
      console.warn(
        "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
      ),
      console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
      this.addGroup(t, e);
  },
  clearDrawCalls: function () {
    console.warn(
      "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
    ),
      this.clearGroups();
  },
  computeTangents: function () {
    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
  },
  computeOffsets: function () {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
  },
  removeAttribute: function (t) {
    return (
      console.warn(
        "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
      ),
      this.deleteAttribute(t)
    );
  },
  applyMatrix: function (t) {
    return (
      console.warn(
        "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
      ),
      this.applyMatrix4(t)
    );
  },
});
Object.defineProperties(ct.prototype, {
  drawcalls: {
    get: function () {
      return (
        console.error(
          "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
        ),
        this.groups
      );
    },
  },
  offsets: {
    get: function () {
      return (
        console.warn(
          "THREE.BufferGeometry: .offsets has been renamed to .groups."
        ),
        this.groups
      );
    },
  },
});
Object.defineProperties(yl.prototype, {
  maxInstancedCount: {
    get: function () {
      return (
        console.warn(
          "THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."
        ),
        this.instanceCount
      );
    },
    set: function (t) {
      console.warn(
        "THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."
      ),
        (this.instanceCount = t);
    },
  },
});
Object.defineProperties(xg.prototype, {
  linePrecision: {
    get: function () {
      return (
        console.warn(
          "THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."
        ),
        this.params.Line.threshold
      );
    },
    set: function (t) {
      console.warn(
        "THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."
      ),
        (this.params.Line.threshold = t);
    },
  },
});
Object.defineProperties(gn.prototype, {
  dynamic: {
    get: function () {
      return (
        console.warn(
          "THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."
        ),
        this.usage === bo
      );
    },
    set: function (t) {
      console.warn(
        "THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."
      ),
        this.setUsage(t);
    },
  },
});
Object.assign(gn.prototype, {
  setDynamic: function (t) {
    return (
      console.warn(
        "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
      ),
      this.setUsage(t === !0 ? bo : hc),
      this
    );
  },
  setArray: function () {
    console.error(
      "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
    );
  },
});
Object.assign(pi.prototype, {
  getArrays: function () {
    console.error(
      "THREE.ExtrudeBufferGeometry: .getArrays() has been removed."
    );
  },
  addShapeList: function () {
    console.error(
      "THREE.ExtrudeBufferGeometry: .addShapeList() has been removed."
    );
  },
  addShape: function () {
    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
  },
});
Object.defineProperties(yf.prototype, {
  dynamic: {
    set: function () {
      console.warn(
        "THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead."
      );
    },
  },
  onUpdate: {
    value: function () {
      return (
        console.warn(
          "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
        ),
        this
      );
    },
  },
});
Object.defineProperties(bt.prototype, {
  wrapAround: {
    get: function () {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function () {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
  },
  overdraw: {
    get: function () {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function () {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
  },
  wrapRGB: {
    get: function () {
      return (
        console.warn("THREE.Material: .wrapRGB has been removed."), new lt()
      );
    },
  },
  shading: {
    get: function () {
      console.error(
        "THREE." +
          this.type +
          ": .shading has been removed. Use the boolean .flatShading instead."
      );
    },
    set: function (t) {
      console.warn(
        "THREE." +
          this.type +
          ": .shading has been removed. Use the boolean .flatShading instead."
      ),
        (this.flatShading = t === yp);
    },
  },
  stencilMask: {
    get: function () {
      return (
        console.warn(
          "THREE." +
            this.type +
            ": .stencilMask has been removed. Use .stencilFuncMask instead."
        ),
        this.stencilFuncMask
      );
    },
    set: function (t) {
      console.warn(
        "THREE." +
          this.type +
          ": .stencilMask has been removed. Use .stencilFuncMask instead."
      ),
        (this.stencilFuncMask = t);
    },
  },
});
Object.defineProperties(_r.prototype, {
  metal: {
    get: function () {
      return (
        console.warn(
          "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."
        ),
        !1
      );
    },
    set: function () {
      console.warn(
        "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"
      );
    },
  },
});
Object.defineProperties(Je.prototype, {
  derivatives: {
    get: function () {
      return (
        console.warn(
          "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
        ),
        this.extensions.derivatives
      );
    },
    set: function (t) {
      console.warn(
        "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
      ),
        (this.extensions.derivatives = t);
    },
  },
});
Object.assign(Oc.prototype, {
  clearTarget: function (t, e, n, i) {
    console.warn(
      "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
    ),
      this.setRenderTarget(t),
      this.clear(e, n, i);
  },
  animate: function (t) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
      this.setAnimationLoop(t);
  },
  getCurrentRenderTarget: function () {
    return (
      console.warn(
        "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
      ),
      this.getRenderTarget()
    );
  },
  getMaxAnisotropy: function () {
    return (
      console.warn(
        "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
      ),
      this.capabilities.getMaxAnisotropy()
    );
  },
  getPrecision: function () {
    return (
      console.warn(
        "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
      ),
      this.capabilities.precision
    );
  },
  resetGLState: function () {
    return (
      console.warn(
        "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
      ),
      this.state.reset()
    );
  },
  supportsFloatTextures: function () {
    return (
      console.warn(
        "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
      ),
      this.extensions.get("OES_texture_float")
    );
  },
  supportsHalfFloatTextures: function () {
    return (
      console.warn(
        "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
      ),
      this.extensions.get("OES_texture_half_float")
    );
  },
  supportsStandardDerivatives: function () {
    return (
      console.warn(
        "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
      ),
      this.extensions.get("OES_standard_derivatives")
    );
  },
  supportsCompressedTextureS3TC: function () {
    return (
      console.warn(
        "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
      ),
      this.extensions.get("WEBGL_compressed_texture_s3tc")
    );
  },
  supportsCompressedTexturePVRTC: function () {
    return (
      console.warn(
        "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
      ),
      this.extensions.get("WEBGL_compressed_texture_pvrtc")
    );
  },
  supportsBlendMinMax: function () {
    return (
      console.warn(
        "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
      ),
      this.extensions.get("EXT_blend_minmax")
    );
  },
  supportsVertexTextures: function () {
    return (
      console.warn(
        "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
      ),
      this.capabilities.vertexTextures
    );
  },
  supportsInstancedArrays: function () {
    return (
      console.warn(
        "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
      ),
      this.extensions.get("ANGLE_instanced_arrays")
    );
  },
  enableScissorTest: function (t) {
    console.warn(
      "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
    ),
      this.setScissorTest(t);
  },
  initMaterial: function () {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
  },
  addPrePlugin: function () {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
  },
  addPostPlugin: function () {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
  },
  updateShadowMap: function () {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
  },
  setFaceCulling: function () {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
  },
  allocTextureUnit: function () {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
  },
  setTexture: function () {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
  },
  setTexture2D: function () {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
  },
  setTextureCube: function () {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
  },
  getActiveMipMapLevel: function () {
    return (
      console.warn(
        "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
      ),
      this.getActiveMipmapLevel()
    );
  },
});
Object.defineProperties(Oc.prototype, {
  shadowMapEnabled: {
    get: function () {
      return this.shadowMap.enabled;
    },
    set: function (t) {
      console.warn(
        "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
      ),
        (this.shadowMap.enabled = t);
    },
  },
  shadowMapType: {
    get: function () {
      return this.shadowMap.type;
    },
    set: function (t) {
      console.warn(
        "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
      ),
        (this.shadowMap.type = t);
    },
  },
  shadowMapCullFace: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
      );
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
      );
    },
  },
  context: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
        ),
        this.getContext()
      );
    },
  },
  vr: {
    get: function () {
      return (
        console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
        this.xr
      );
    },
  },
  gammaInput: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
        ),
        !1
      );
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
      );
    },
  },
  gammaOutput: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
        ),
        !1
      );
    },
    set: function (t) {
      console.warn(
        "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
      ),
        (this.outputEncoding = t === !0 ? zp : vo);
    },
  },
  toneMappingWhitePoint: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
        ),
        1
      );
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
      );
    },
  },
});
Object.defineProperties(bm.prototype, {
  cullFace: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
      );
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
      );
    },
  },
  renderReverseSided: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
      );
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
      );
    },
  },
  renderSingleSided: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
      );
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
      );
    },
  },
});
Object.defineProperties(Sn.prototype, {
  wrapS: {
    get: function () {
      return (
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
        this.texture.wrapS
      );
    },
    set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
        (this.texture.wrapS = t);
    },
  },
  wrapT: {
    get: function () {
      return (
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
        this.texture.wrapT
      );
    },
    set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
        (this.texture.wrapT = t);
    },
  },
  magFilter: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
        ),
        this.texture.magFilter
      );
    },
    set: function (t) {
      console.warn(
        "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
      ),
        (this.texture.magFilter = t);
    },
  },
  minFilter: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
        ),
        this.texture.minFilter
      );
    },
    set: function (t) {
      console.warn(
        "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
      ),
        (this.texture.minFilter = t);
    },
  },
  anisotropy: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
        ),
        this.texture.anisotropy
      );
    },
    set: function (t) {
      console.warn(
        "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
      ),
        (this.texture.anisotropy = t);
    },
  },
  offset: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .offset is now .texture.offset."
        ),
        this.texture.offset
      );
    },
    set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
        (this.texture.offset = t);
    },
  },
  repeat: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
        ),
        this.texture.repeat
      );
    },
    set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
        (this.texture.repeat = t);
    },
  },
  format: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .format is now .texture.format."
        ),
        this.texture.format
      );
    },
    set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
        (this.texture.format = t);
    },
  },
  type: {
    get: function () {
      return (
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
        this.texture.type
      );
    },
    set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
        (this.texture.type = t);
    },
  },
  generateMipmaps: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
        ),
        this.texture.generateMipmaps
      );
    },
    set: function (t) {
      console.warn(
        "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
      ),
        (this.texture.generateMipmaps = t);
    },
  },
});
Object.defineProperties(la.prototype, {
  load: {
    value: function (t) {
      console.warn(
        "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
      );
      const e = this;
      return (
        new pf().load(t, function (i) {
          e.setBuffer(i);
        }),
        this
      );
    },
  },
  startTime: {
    set: function () {
      console.warn("THREE.Audio: .startTime is now .play( delay ).");
    },
  },
});
dg.prototype.getData = function () {
  return (
    console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),
    this.getFrequencyData()
  );
};
Po.prototype.updateCubeMap = function (t, e) {
  return (
    console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
    this.update(t, e)
  );
};
cr.crossOrigin = void 0;
cr.loadTexture = function (t, e, n, i) {
  console.warn(
    "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
  );
  const r = new Xh();
  r.setCrossOrigin(this.crossOrigin);
  const s = r.load(t, n, void 0, i);
  return e && (s.mapping = e), s;
};
cr.loadTextureCube = function (t, e, n, i) {
  console.warn(
    "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
  );
  const r = new qh();
  r.setCrossOrigin(this.crossOrigin);
  const s = r.load(t, n, void 0, i);
  return e && (s.mapping = e), s;
};
cr.loadCompressedTexture = function () {
  console.error(
    "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
  );
};
cr.loadCompressedTextureCube = function () {
  console.error(
    "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
  );
};
typeof __THREE_DEVTOOLS__ != "undefined" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: P_ } })
  );
export {
  wt as B,
  lt as C,
  WM as D,
  _1 as E,
  rt as F,
  w1 as H,
  he as M,
  nt as O,
  Pe as P,
  ea as R,
  ue as S,
  Xh as T,
  H as V,
  v1 as W,
  M1 as a,
  pc as b,
  Oc as c,
  S1 as d,
  Cc as e,
  Je as f,
  ky as g,
  Ka as h,
  Sn as i,
  S as j,
  ct as k,
  b1 as l,
  qh as m,
  Vt as n,
  cg as o,
  x1 as s,
};
